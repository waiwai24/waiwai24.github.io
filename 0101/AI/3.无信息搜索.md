# 无信息搜索

> 无信息搜索(盲目搜索，Blind search): 只使用搜索树中的信息
>
> 有信息搜索(启发式搜索，Heuristic search): 使用搜索树以外的信息

## 1.宽度优先搜索（breath-first-search）

* 基本思想：优先扩展深度较浅的结点
* 活结点集合 frontier 通常用先进先出队列实现！

评价：

* 完备的，如果 b 和 d 均有限

* 最优的，如果单步代价相同

* 时空复杂性都是 O(b^d): 状态空间中每个状态最多有 *b* 个后继状态, 目标结点的深度(Depth) *d* 



## 2.一致代价搜索（uniform-cost-search）

* 先扩展当前路径代价最小的节点(代价要累加)
* 活结点集合按路径代价排序
* 即，搜索过程中以当前状态到起始状态的代价作为评价函数，每次选择代价最小的节点进行扩展

评价：

* 如果单步代价都一样，一致代价搜索就等价于宽度优先搜索

* 完备的、最优的，如果每一步的代价都大于等于某个小的正常数 ε

* 生成结点总数(最坏情况) 为 $\mathcal{O}(b^{1+\lfloor C^*/\varepsilon\rfloor})$, 时间和空间复杂性均为 $\mathcal{O}(b^{1+\lfloor C^*/\varepsilon\rfloor})$

  * 分支因子(Branching factor) b 
  * 搜索树中最浅的目标结点的深度(Depth) d 
  * C* 表示最优解的代价
  * 假设每个行动的代价至少为 ε 




## 3.深度优先搜索（depth-first-search）

* 总是扩展搜索树当前边缘结点集中最深的结点
* 总是从frontier队列头取拟扩展的结点
* 新扩展的结点加入到frontier队列头
* 可采用递归或堆栈的方法实现

评价：

* 图搜索算法是完备的，如果状态空间有限
* 树搜索算法不完备，可能陷入死循环
* 如果状态空间无限，树搜索和图搜索都不完备
* 树搜索和图搜索都不是最优的
* 时间复杂性为𝑶(𝒃^𝒎) ,空间复杂性为𝑶(𝒃𝒎)或𝑶(𝒎) 
  * 生成结点总数(最坏情况)1 + b + b^2 + … + b^m = O(b^m)
  * 分支因子(Branching factor) **b** 
  * 搜索树中最浅的目标结点的深度(Depth) **d** 
  * 叶结点最大深度**m**



## 4.深度受限搜索（depth-limited-search）

对深度优先搜索设置界限limit，深度大于limit 的结点不被扩展，深度界限的设定依据问题本身的知识



## 5.迭代深入搜索（iteractive-deeping-search）

* 结合了深度优先搜索和宽度优先搜索的优点
* 逐步加大深度限制，进行深度限制搜索，直到找到目标



## 6.双向搜索（bidirectional-search）

同时运行两个搜索，一个从初始状态向前搜索，另一个从目标状态向后搜索，若在中间某点相遇，搜索终止