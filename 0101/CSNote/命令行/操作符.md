# 与命令有关的操作符

## 1.多命令执行符

1. `;` 顺序执行多条命令，不管命令是否执行成功
2. `&& ` 逻辑与，如果前面的命令执行错误则不执行后面的命令
3. `||` 逻辑或，顺序执行多条命令，碰到执行正确的命令后则不执行后面的命令, 即当左侧指令报错时，右侧指令才会执行



## 2.管道符

管道符 `|` 将前一个命令的输出作为后一个命令的操作对象 



## 3.重定向符

> 标准输入（stdin）、标准输出（stdout）和标准错误（stderr）
>
> 这三个默认流具有以下文件描述符编号 File Descriptor (FD)：stdin = 0、stdout = 1 和 stderr = 2

![pipe11-640x129](./assets/操作符/pipe11-640x129.png)

1. `>` 输出重定向
2. `>>` 追加重定向
3. `<` 输入重定向
4. `2>&1 ` 让 2 重定向到 1，也就是让 `stderr` 标准错误重定向到 `stdout` 标准输出，然后两个并在一起再重定向

`tee` 命令：从标准输入读取数据并重定向到标准输出和文件

```
tee [OPTION]... [FILE]...
    -a：追加到文件而不是覆盖。使用该选项，可以将输出内容追加到指定文件的末尾。
    -i：交互式地提示覆盖已存在文件。当指定的输出文件已存在时，使用该选项会询问用户是否覆盖文件。
    -p：保持管道的性能，不输出到终端。在某些情况下，使用该选项可以提高性能。

echo "Hello, Linux!" | tee output.txt
```

注意：`>` 和 `>>` 如果文件不存在，会自动创建新文件，而不需要提前 touch，且他会覆盖文件原本的内容

```
hacker@dojo:~$ echo hi > asdf
hacker@dojo:~$ echo hi 1> asdf
上面两者等价

hacker@dojo:~$ /challenge/run 2> errors.log
重定向错误

hacker@dojo:~$ some_command > output.log 2> errors.log
将输出重定向到output.log，错误重定向到errors.log
```



## 4.通配符

1. `*` 用于匹配 0 个或多个字符
2. `?` 匹配一个任意字符
3. `[]` 匹配括号中任意一个字符
4. `[^]，[!]` 逻辑非，中的第一个字符是^或！，匹配不是括号中的字符
5. `[0-9]` 匹配 0-9 之间的单个数字字符，`[^0-9]` 匹配一个不是数字的字符
6. `[abc]` 匹配 a, b, c 三个字符中的任意一个字符



## 5.转义符

1. `\` 反斜杠转义符，去除紧跟其后的元字符的特殊意义

2. `''` 单引号，强引用，转义其中的所有变量为单纯的字符串
3. `""` 双引号，弱引用，只保留 $ 、 ` 和 \ 三种元字符的特殊含义



## 7.其他

1. `$` 标识变量，用 `=` 写入变量（写入变量的时候不用带$,\$只用于访问），等号周围不能有空格

2. `$$` 表示当前程序的进程 ID 号

3. `!` 非操作符  

4. `#` 注释

5. `read` 命令：从键盘读取变量的值，通常用在 shell 脚本中与用户进行交互的场合

   ```shell
   -p：指定读取值时的提示符；
   -t：指定读取值时等待的时间（秒）
   ```

6. `#` 注释符

7. 输入命令时在后边加入 `&` 符号会把命令程序直接放到后台执行，此时可以用 jobs 命令查看后台执行程序的列表, 等同于 ctrl+z

8. 通过将一条命令封装在 ` 中，可以将它嵌入另一条命令;

9. 命令替换还有另外一种格式，即将命令放入 `$()` 中



