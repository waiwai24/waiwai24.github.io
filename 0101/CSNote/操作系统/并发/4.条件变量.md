# 条件变量

## 1.低效的实现

多线程程序中，我们经常希望一个线程等待某些条件

简单的方案是自旋直到条件满足，这是极其低效的，某些情况下甚至是错误的



## 2.定义

线程可以使用条件变量（condition variable），来等待一个条件变成真。条件变量是一个显式队列，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等待（waiting）该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行

* 是一个显示队列，根据某些特定条件(condition)决定线程行为
* 等待条件：当条件不满足时，线程加入队列（休眠）
* 发出信号：对于其他线程，当改变状态（使条件满足时），可以在队列中唤醒线程
* 条件变量可以处理线程的等待和唤醒
* 在条件变量上等待的线程，会在休眠前解锁，被唤醒后立刻加锁
* 通过条件变量可以实现事件类型，描述事件发生与否

声明：

```c
pthread_cond_t c;
```

条件变量有两种相关操作：wait()和 signal()

* 线程要睡眠的时候，调用 wait()，同时会释放锁
* 当线程想唤醒等待在某个条件变量上的睡眠线程时，调用 signal()
* 调用 signal 和 wait 时要持有锁



## 3.生产者消费者问题

假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费

例如 grep foo file.txt | wc -l

这个例子并发执行了两个进程，grep 进程从 file.txt 中查找包括“foo”的行，写到标准输出；UNIX shell 把输出重定向到管道（通过 pipe 系统调用创建）。管道的另一端是 wc 进程的标准输入，wc 统计完行数后打印出结果。因此，grep 进程是生产者，wc 是进程是消费者，它们之间是内核中的有界缓冲区



* 简单实现：在检查缓冲区时使用的是if，如果缓冲区不满足消费者（生产者）的条件，调用生产者（消费者），但是当存在许多消费者的时候，就有可能在customer1消费时，buf为0，回到producer，然后生产完后customer2消费了buf，回到customer1，消费就会出出现错误
* 改进：一个简单规则，在使用条件变量时记得用while，这样会再检查一遍buf
* 加强：当存在多个生产者和多个消费者的时候，消费者不应该唤醒消费者，而应该只唤醒生产者；生产者不能唤醒其他产者，而应该只唤醒消费者。解决：生产者在empty队列中等待，发送信号唤醒fill中线程(消费者相反)



## 4.覆盖条件

不该被唤醒的线程会在检查条件后继续休眠代价：唤醒太多线程，引入开销

实例：分配内存的问题

thread1要allocate(100)，thread2要allocate(10)，此时thread3 free(50)，当他发信号唤醒等待线程时，可能不会唤醒thread2，而thread1又由于内存不够，会继续等待。因为不知道唤醒哪些线程，所以没法工作了。

可以通过一个广播信号唤醒所有的等待线程，但是这样就会严重的影响性能，因为不必要地唤醒了其他许多等待的线程，它们本来（还）不应该被唤醒。这些线程被唤醒后，重新检查条件，马上再次睡眠

这种条件变量叫作覆盖条件（covering condition），因为它能覆盖所有需要唤醒线程的场景（保守策略）
