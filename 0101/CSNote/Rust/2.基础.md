# 基础

## 1.变量

- 变量绑定：let 声明，变量归属所有权
- 变量默认不可变，关键字 mut 可变（类型不可变）
- 下划线忽略未使用的变量：let _hello = "hi";
- 变量遮蔽：后声明的变量会遮蔽前面声明的变量
- 解构：使用 `let` 关键字配合模式，可以将一个复合类型的值拆解，直接绑定到多个变量上



## 2.常量

* const 声明
* 必须类型标注
* 命名规则：单词之间使用下划线，并且全部大写

```rust
const MAX_POINTS: u32 = 100_000;
```



## 3.基本类型

rust 属于静态类型语言，也就是编译器在编译的时候需要确定变量类型，但这并不意味着需要为每一个变量指定类型，rust 编译器有时可以根据上下文自动推断出变量类型

- 数值类型：有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 `&str`，用 `""`，UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)
- 布尔类型：`true` 和 `false`，占 1 字节
- 字符类型：表示单个 Unicode 字符，存储为 4 个字节，用 `''`
- 单元类型Unit：即 `()` ，其唯一的值也是 `()`，内存占用大小 0 字节

只有同样类型，才能进行计算

计算类型的大小：`use std::mem::size_of_val;`

序列 range（只允许用于数字或字符）：例如 `1..5`，生成从 1 到 4 的连续数字，不包含 5 ；`1..=5`，生成从 1 到 5 的连续数字，包含 5

使用 as 可以实现类型转换



## 4.语句和表达式

Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，表达式最后不能包含分号

表达式如果不返回任何值，会隐式地返回一个 `()`



## 5.函数

![img](./assets/2.基础/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png)

由于 Rust 是静态类型语言，因此需要为每一个函数参数都标识出它的具体类型

Rust 中表达式就是函数的返回值，也可以使用 return 提前返回

特殊返回类型：

- 无返回值()：
  - 函数没有返回值，那么返回一个 `()`
  - 通过 `;` 结尾的语句返回一个 `()`
- 永不返回的发散函数：! 作为返回类型



## 6.所有权

- 所有权基本规则：
  - Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
  - 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
  - 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)
- Rust 永远也不会自动创建数据的 “深拷贝”（但可以使用 clone 方法）
- 浅拷贝只发生在栈上，因此性能很高
- 像整数，浮点数，字符这种简单的类型，不受所有权规则的约束，称为Copy类型



## 7.引用与借用

**reference 引用**：通过&创建，指向对象存储的内存地址，但并没有所有权：

* 可变引用：添加 mut，允许修改数据，但在同一时间只能有一个可变引用，且不可与不可变引用共存
* 不可变引用：只能读取数据，不能修改
* 解引用：*
* 同一时刻，只能拥有要么一个可变引用，要么任意多个不可变引用

**borrow 借用**：指按引用传递对象的方式，即通过引用访问数据而不转移所有权

| 概念 | 说明                                   | 例子                         |
| :--- | :------------------------------------- | :--------------------------- |
| 引用 | 指向数据的指针，是一种类型             | `let r = &s;`                |
| 借用 | 获取引用的行为，借用数据而不转移所有权 | `fn foo(s: &String) { ... }` |



## 8.字符串

Struct String ：定义在标准库中的类型，分配在堆上，可以动态的增长。它的底层存储是动态字节数组的方式( Vec<u8> )，但是与字节数组不同，String 是 UTF-8 编码

* 创建：String:: from()
* 追加：push(), push_str()
* 插入：insert(), insert_str()
* 替换：replace(), replacen(), replace_range()
* 删除：pop(), remove(), truncate(), clear()
* 连接：
  * `+`，相当于调用了标准库中的 add() 方法，add() 方法的第二个参数是一个引用的类型，返回一个新的字符串
  * format!，适用于 String 和 &str ，用法与 print! 的用法类似
* 可以使用 String::from 或 to_string 将 &str 转换成 String 类型



## 9.元组

元组是由多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的

创建元组示例：`let tup: (i32, f64, u8) = (500, 6.4, 1);`

元组用`.`来访问



## 10.结构体

结构体声明为可变的，才可以修改里面的字段，不支持将某个字段声明为可变的



## 11.枚举

枚举类型是一个类型，它会包含所有可能的枚举成员，而枚举值是该类型中的具体某个成员的实例，使用`::`该枚举类型的成员

任何类型的数据都可以放入枚举成员中：例如字符串、数值、结构体甚至另一个枚举

```rust
enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}
```



## 12.数组

长度固定：array，存储在栈上

动态数组：Vector，存储在堆上

声明示例：

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    let b: [i32; 5] = [1, 2, 3, 4, 5]; // 类型;长度
    let a = [3; 5]; // 5次重复
}
```

数组切片：创建切片的代价非常小，因为切片只是针对底层数组的一个引用

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
let slice: &[i32] = &a[1..3];
assert_eq!(slice, &[2, 3]);
```

`Vec::new` 创建动态数组，`vec!` 来创建数组在创建同时可以赋予初始化值

## 13.流程控制

```rust
if condition == true {
    // A...
} else {
    // B...
}
```

```rust
for item in &container {
  // ...
}
```

| 使用方法                      | 等价使用方式                                      | 所有权     |
| ----------------------------- | ------------------------------------------------- | ---------- |
| `for item in collection`      | `for item in IntoIterator::into_iter(collection)` | 转移所有权 |
| `for item in &collection`     | `for item in collection.iter()`                   | 不可变借用 |
| `for item in &mut collection` | `for item in collection.iter_mut()`               | 可变借用   |

`continue` 可以跳过当前当次的循环，开始下次的循环；`break` 可以直接跳出当前整个循环

`while` 适用：当该条件为 `true` 时，继续循环，条件为 `false`，跳出循环

`loop` 一个简单的无限循环，可以在内部实现逻辑通过 `break` 关键字来控制循环何时结束



## 14.模式匹配

```rust
match target {
    模式1 => 表达式1,
    模式2 => {
        语句1;
        语句2;
        表达式2
    },
    _ => 表达式3 // 通配符模式，匹配所有其他情况（类似 default）
}
```



## 15.方法

使用 impl（Implementation）定义方法

rust 语言对象定义与方法定义是分析的，也就是数据与使用时分离的

rust 的可见性系统基于默认私有原则：除非显式声明为公有，否则所有项目都是私有的

关联函数：impl中没有self的函数



## 16.泛型

泛型就是一种多态，用同一功能的函数处理不同类型的数据

所有的泛型参数都要提前声明

const 泛型：针对值的泛型



## 17.特征

trait 类似于接口

where约束
