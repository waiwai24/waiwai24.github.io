# 布尔与比较



## 1.AND指令

```assembly
AND destination，source
```

两个操作数的对应位进行按位与操作（只有都为1时才为1），并将结果存放在目标操作数中

注意：

* 两个操作数必须是同样大小
* 两个目标操作数不能同为内存操作数

应用：

* 将字符串小写转换为大写

  对比A（65）和a（97）的ASCII码，相差32，就会发现只有位5（$2^5$）不同，其他的字符也是同样的关系，故把任何一个字符与`1101 1111`进行and操作除位5外其他所有的位都不变，把位5清0，小写字母也就转换成大写了



## 2.OR指令

```assembly
OR destination，source
```

两个操作数的对应位进行按位或操作（只有都为0时才为0），并将结果存放在目标操作数中



## 3.XOR指令

```assembly
XOR destination，source
```

两个操作数的对应位进行按位逻辑异或操作（同0异1），并将结果存放在目标操作数中

特点：

* 与0异或值保持不变，与1异或值求补
* **可逆性对相同操作数进行两次XOR操作，则结果逆转为本身$(x\oplus y)\oplus y=x$**



## 4.NOT指令

```assembly
NOT reg
NOT mem
```

翻转操作数中的所有位，结果称为反码，NOT指令不影响标志位



## 5.CMP指令

```assembly
CMP destination，source
```

CMP指令执行从目的操作数减去源操作数的隐含减法操作，并且**不修改**任何操作数

|        CMP结果        |  ZF  |  CF  |
| :-------------------: | :--: | :--: |
| 目的操作数 < 源操作数 |  0   |  1   |
| 目的操作数 > 源操作数 |  0   |  0   |
| 目的操作数 = 源操作数 |  1   |  0   |

|        CMP结果        | 标志位  |
| :-------------------: | :-----: |
| 目的操作数 < 源操作数 | SF ≠ OF |
| 目的操作数 > 源操作数 |  SF=OF  |
| 目的操作数 = 源操作数 |  ZF=1   |