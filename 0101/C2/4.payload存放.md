# payload 存放

## 1.存放位置

有效载荷可以存储在以下 PE 部分之一中：

- .data：数据段，PE 文件的 .data 段是 PE 文件的可执行部分中包含已初始化全局变量和静态变量的部分。此节可读写，适合需要在运行时解密的加密有效负载。有效负载如果是全局或局部变量，将存储在 .data 节中，具体取决于编译器设置

- .rdata：只读数据段，使用 const 限定符指定的变量被写为常量。这类变量被认为是“只读”数据。.rdata 中的字母 “r” 表示此含义，任何尝试更改这些变量的行为都会导致访问冲突。此外，根据编译器及其设置，.data 和 .rdata 可能会被合并，甚至被合并到 .text 节中

- .text：代码段，告诉编译器将 Text_rawData 变量放在 .text 中，而不是 .rdata 中。.text 是特殊的，因为它存储具有可执行内存权限的变量，允许它们直接执行，而无需编辑内存区域权限。这对于大约小于 10 个字节的小型负载很有用：

  ```c
  #pragma section(".text")
  __declspec(allocate(".text")) const unsigned char Text_RawData[] = {}
  ```

- .rsrc：包含了模块的资源信息，只读内存，将有效负载保存在 .rsrc 段是一种更简洁的方法，因为较大的有效负载无法存储在 .data 或 .rdata 段中，因为存在大小限制，从而导致编译期间 Visual Studio 报错，但有效负载无法直接从资源部分编辑，因此必须将其移动到一个临时缓冲区

  - Visual Studio 中，右键单击“资源文件”，然后单击添加 > 新建项
  - 资源文件中选 rc，Resource.rc
  - 然后添加资源，选择导入，将原始 shellcode 文件命名为 .ico 扩展名有效负载
  - 资源类型输入 RCDATA

  ```c
  #include <Windows.h>
  #include <stdio.h>
  #include "resource.h"
  
  int main() {
  
      HRSRC       hRsrc = NULL;
      HGLOBAL     hGlobal = NULL;
      PVOID       pPayloadAddress = NULL;
      SIZE_T      sPayloadSize = NULL;
  
      // 根据其 ID *IDR_RCDATA1* 获取存储在 .rsrc 中的数据的位置，RT_RCDATA 是资源类型
      hRsrc = FindResourceW(NULL, MAKEINTRESOURCEW(IDR_RCDATA1), RT_RCDATA);
      if (hRsrc == NULL) {
          // 函数发生错误
          printf("[!] FindResourceW 失败，错误信息：%d \n", GetLastError());
          return -1;
      }
  
      // 后续调用 LockResource，因此需要获取 HGLOBAL 或指定资源数据的句柄
      hGlobal = LoadResource(NULL, hRsrc);
      if (hGlobal == NULL) {
          // 函数发生错误
          printf("[!] LoadResource 失败，错误信息：%d \n", GetLastError());
          return -1;
      }
  
      // 获取 .rsrc 部分中有效负载的地址
      pPayloadAddress = LockResource(hGlobal);
      if (pPayloadAddress == NULL) {
          // 函数发生错误
          printf("[!] LockResource 失败，错误信息：%d \n", GetLastError());
          return -1;
      }
  
      // 获取 .rsrc 部分中有效负载的尺寸
      sPayloadSize = SizeofResource(NULL, hRsrc);
      if (sPayloadSize == NULL) {
          // 函数发生错误
          printf("[!] SizeofResource 失败，错误信息：%d \n", GetLastError());
          return -1;
      }
  
      // 在屏幕上打印指针和尺寸
      printf("[i] pPayloadAddress 变量：0x%p \n", pPayloadAddress);
      printf("[i] sPayloadSize 变量：%ld \n", sPayloadSize);
      printf("[#] 按下 <Enter> 退出...");
  
  	PVOID pTmpBuffer = HeapAlloc(GetProcessHeap(), 0, sPayloadSize);
  	if (pTmpBuffer != NULL) {
      	// 将有效负载从资源部分复制到新缓冲区
      	memcpy(pTmpBuffer, pPayloadAddress, sPayloadSize);
  	}
  
  	// 打印缓冲区 (pTmpBuffer) 的基址
  	printf("[i] pTmpBuffer var : 0x%p \n", pTmpBuffer);
      getchar();
      return 0;
  }
  ```