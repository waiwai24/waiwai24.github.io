# 逆向基本

## 1.函数调用约定

函数原型: 参数个数及类型、返回值

函数序言和尾声：开辟和释放栈帧



C++程序：

* x86 架构：cdecl，stdcall，fastcall，thiscall
* x86-64 架构：变形 fastcall，thiscall

### 1.1 __cdecl

* C 调用约定
* UNIX 系统中常用的钟函数调用约定
* 传参：逆序传参
* 栈平衡，**调用者** 清理

### 1.2 __stdcall

* 标准调用约定
* Windows API 使用 stdcall
* 传参：逆序传参
* 栈平衡，**被调用者** 清理，retn + 数字

### 1.3 __fastcall

* 快速调用约定
* windows 中的一种高效调用
* 传参：前两个参数 ecx，edx 传，后面 stdcall，将参数优先从寄存器传入，剩下的参数再从右向左从栈传入
* 参数个数小于等于 2 个时不存在栈平衡的问题

### 1.4 __thiscall

* 用于 x86 体系结构上的 C++ 类成员函数
* 栈平衡，被调用者清理



## 2.基本数据类型

> 二进制代码中只有内存大小，没有类型信息

* 全局变量位于全局数据区，已被初始化：初始化全局变量的常量已被赋值到全局数据区，没有产生代码

* 局部变量:
  * 位于栈中，使用 [ebp-x] 的格式对其引用
  * 产生汇编代码实现初始化赋值
  * 先声明的变量位于栈底，高地址
  * 后声明的变量位于栈顶，低地址
  * 数字常量作为指令的立即数，位于代码段
  * 字符串常量位于全局静态区

* 指针：int *，double*，char *



## 3.基本操作类型

* 加，减，乘，除（cdq 指令，有符号数的扩展）

  | 被除数  | 除数      | 商   | 余数 |
  | ------- | --------- | ---- | ---- |
  | AX      | reg/mem8  | AL   | AH   |
  | DX: AX   | reg/mem16 | AX   | DX   |
  | EDX: EAX | reg/mem32 | EAX  | EDX  |

* 逻辑运算
* 浮点指令



## 4.基本控制结构

### 4.1 顺序结构

### 4.2 分支结构

* if/else：编译时，跳转指令为 true 是 else 的内容，跳转指令后面是 if 的内容

* switch

  ![image-20240906092845075](./assets/2.逆向基本/image-20240906092845075.png)
  
  * case 分支小于 4 个时，其反汇编与 if...else 类似：一系列的 cmp 和跳转指令
  
    ![image-20240909080658679](./assets/2.逆向基本/image-20240909080658679.png)
  * 当 case 分支大于等于 4 个且连续时，会在一段连续内存中存储每个 case 所对应语句块的起始地址（称其为大表或跳转表），根据[edx*4+xxxxxxh]即可确定跳转地址
    * case 条件连续时，使用单跳转表
  
      ![image-20240909081236790](./assets/2.逆向基本/image-20240909081236790.png)
    * case 条件不连续时，使用二级跳转表技术, 不存在的常量地址填补 default 段的首地址
  
      ![image-20240909081927464](./assets/2.逆向基本/image-20240909081927464.png)
  
  
  
* break，continue：被编译成无条件跳转

### 4.3 循环结构

* while 循环：流程图一般含 2 个基本块

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  void main()
  {
      int i=0,a =0;
      while (i<=10)
      {
      	a+=i;
      	i++
  	}
  	return 0;
  }
  ```

  ![image-20240906110603979](./assets/2.逆向基本/image-20240906110603979.png)
* do/while 循环：流程图一般含 1 个基本块，与其他循环的显著区别就是为真判断时继续执行，回跳的线为绿色

  ![image-20240909082440781](./assets/2.逆向基本/image-20240909082440781.png)
* for 循环：流程图一般含 3 个基本块

  ![image-20240909082544847](./assets/2.逆向基本/image-20240909082544847.png)

## 5.数据结构

* 结构体 struct
* 联合体 union：所有成员公用一块内存空间，size 为成员的最大 size。特点：同一个内存位置进行不同赋值
* 位段：指定了各成员存储位数的结构体或联合体，表示存储该成员的位数，称为位宽。在 unsigned 类型或 int 类型的成员（只能这两种）名后依次加上冒号和代表位段宽度的整数常量。对成员变量运算时采取移位操作，再 and 或 or
* 枚举 enum
* 自引用结构：结构体中包含指针类型的成员变量，这些指针变量的数据类型与当前结构体相同，即指向与自身同类型的指针
  * 链表
  * 队列
  * 二叉树
  * 堆栈
* 用点.访问：编译时就直接定位了，逆向时看不出是结构体
* 用箭头-> 访问：根据结构体偏移，可以识别出是结构体

## 6.类与对象

### 6.1 内存布局

* 先声明的成员变量位于低地址，后声明的成员变量位于高地址
* 静态成员变量位于全局变量区，不占用对象自身的空间
* 对齐值 = min(数据成员类型长度，指定给编译器的对其长度)
* 成员变量的分布在对齐值的整数倍上
* 对象，结构体的大小是 q 的整数倍：
  * M~max~= max(M~i~)，q = min(M~max~，N)
  * Mi 为第 i 个数据成员的类型长度，N 为指定给编译器的对齐长度

  * ```c
    #pragma pack(N)
    // N 表示对齐字节，即成员变量首地址是 N 的倍数
    ```

### 6.2 this 指针

* 通过 this 指针访问数据成员，this 指针使用过程被编译器隐藏，this 指针指向对象/结构体的首地址，用于访问数据成员变量和成员函数
* this 调用约定：使用 ecx 寄存器保存对象的首地址，并使用寄存器传参方式传递到成员函数中。表明本次成员函数的调用是由该 this 指针指向的对象指针调用的。隐藏了 this 指针的传递，即所有的成员函数将 this 指针作为一个参数，隐含传递 this 指针。**被调用者** 负责处理栈平衡
* 注意：不能指定某个函数使用 thiscall 调用约定，没有对应的关键字

### 6.3 对象参数

* 对象参数：将对象/结构体作为函数的参数，对象参数的传递过程复杂，传递方式独特，传递对象的所有数据成员，使用 **拷贝** 的方式

### 6.4 对象返回值

* 将对象/结构体作为函数的返回值

## 7.构造函数与析构函数

生命周期由对象所在的作用域决定

对象进入作用域时生命周期开始，调用构造函数

对象退出作用域时生命周期结束，调用析构函数 

对象类型：局部对象，堆对象，堆对象数组，参数对象，返回对象，全局对象，静态对象

### 7.1 构造函数出现时机与识别

#### 7.1.1 局部对象

* 在函数体内定义的对象
* 对象产生时由编译器实现构造函数的调用
* 构造函数默认使用 thiscall 调用约定，返回 this 指针

#### 7.1.2 堆对象

* 通过 new、malloc 或其他同功能的函数申请堆空间，例如： Cnumber * pNumber = new CNumber;
* 申请成功后即调用无参构造函数
* 注意：new 分配成功才调用构造函数，故双分支

#### 7.1.3 参数对象

* 参数对象属于局部对象中的一种特殊情况
* 对象作为函数参数时，被调用函数将调用一个特殊的构造函数：拷贝构造函数

* 拷贝构造函数：只有一个参数，类型为对象的引用
  * 例：CMyString(CMyString &obj)
  * obj 是被拷贝的对象
  * 函数语义：将参数指向的对象深拷贝到调用拷贝构造函数的对象
  * 深拷贝：不仅拷贝对象体，还拷贝对象引用的内存资源，如堆内存
  * 拷贝的实现代码由程序员实现

#### 7.1.4 返回对象

* 对象作为函数的返回值，是局部对象中的一种特殊情况
* 对象被返回时，调用拷贝构造函数
  * 原因是对象返回时需要拷贝返回对象
  * 新对象的生命周期开始则调用构造函数
  * 调用时机是在函数返回时

#### 7.1.5 全局对象和静态对象

* 全局对象是定义在全局作用域中的对象
* 静态对象是使用 static 关键字定义的对象
* 二者的构造函数调用时机相同

### 7.2 默认构造函数

并非每个对象都有默认的构造函数

条件：

* 本类、本类中定义的成员对象或者父类中有虚函数存在
  * 此时，虚表的初始化工作需要在构造函数中隐式完成
* 父类或本类中定义的成员对象带有构造函数
  * 此时，继承关系的构造过程是先构造父类，再构造子类，父类的构造函数在子类的构造函数中调用

### 7.3 析构函数

该函数的调用时某对象在作用域内的最后一次成员函数调用，通过 this 指针来分辨是那个对象的成员函数。使用 thiscal 调用方式，使用 ecx 寄存器来传递 this 指针。没有返回值。也没有参数。不支持重载，且形式上是一个无参函数

#### 7.3.1 局部对象

* 定义局部对象的函数执行结束后，由编译器实现析构函数的调用

#### 7.3.2 堆对象

* 在释放对象的内存空间时调用其析构函数
* C++代码中，释放对象需由程序员编写代码实现，若代码中未写释放对象的代码，则对象不会被析构
* 编译器产生析构代理函数实现 delete 函数的调用，完成对象释放

#### 7.3.3 参数对象

* 函数代码执行结束后，调用参数对象的析构函数，释放内存空间
* 参数传递时拷贝参数对象，调用被拷贝参数对象的析构函数

#### 7.3.4 返回对象

* 函数代码执行结束后，调用返回对象的析构函数，释放内存空间

#### 7.3.5 全局对象和静态对象

* 全局对象是定义在全局作用域中的对象，静态对象是使用 static 关键字定义的对象，二者的析构函数调用时机相同
* main 函数执行结束后，调用 exit-> doexit，实现析构函数调用

## 8.虚函数

* 虚函数是面向对象程序设计的关键组成部分，是 C++ 的精髓；用于完成面向对象程序设计中对象的多态性；虚函数必须是类的成员函数

* 使用 virtual 声明虚函数

* 编译器在对象的首地址处预留一个隐式的数据成员，填入虚表的内存地址，即虚表指针
* 编译器将类的所有虚函数的首地址保存在一张地址表中，这张表被称为虚函数地址表，简称虚表，虚表中存放着具体实现代码的首地址

![image-20241011084237806](./assets/2.逆向基本/image-20241011084237806.png)

虚函数的调用过程：

* 对象指针通过虚表指针调用虚函数，使用 this 调用预定
  * 通过 this 指针取出虚表指针
  * 通过虚表指针定位到虚表，将虚表指针临时存入寄存器
  * 将 this 指针传递到寄存器，this 调用约定，一般是 ecx 寄存器，通过 call [寄存器+偏移] 的指令格式调用虚函数，使用偏移值定位到虚表中的虚函数指针，偏移值在编译时确定
* 对象直接调用自身的虚函数，无需虚表指针

逆向分析是一个相互佐证的过程：

* 使用虚表指针识别构造函数和析构函数
* 只有构造函数和析构函数中存在对虚表指针的操作，找到虚表后，使用 IDA 的引用参考可索引到所有对构造函数和析构函数，“交叉参考到”xrefs to VirTable 的快捷键是 x 键

虚函数安全性问题：误用导致的 UAF 漏洞：

* Use After Free，是指一块内存被释放后再次被使用
* 分为以下几种情况：
  * 内存被释放后，其对应的指针被置为 NULL，再次使用导致崩溃；
  * 内存被释放后，其对应的指针未被置为 NULL，在下次使用前，没有代码修改这块内存，则程序的执行本身可能正常运行；
  * 内存被释放后，其对应的指针未被置为 NULL，但在下次使用前，这块内存被修改，则可能会导致安全缺陷问题。

![image-20241105203355973](./assets/2.逆向基本/image-20241105203355973.png)

## 9.继承关系

继承关系中对象的构造与析构顺序:

* 构造过程：父类 -> 子类 … -> 当前类
* 析构过程：当前类 -> 子类 … -> 父类
