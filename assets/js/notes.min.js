document.addEventListener("DOMContentLoaded", function() {
    // From header.js
    setActiveLink();
    setupNavToggle();
    if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(function() {
            document.documentElement.classList.add('fonts-loaded');
        });
    } else {
        setTimeout(function() {
            document.documentElement.classList.add('fonts-loaded');
        }, 100);
    }

    // From knowledge.js
    const fileTreeContainer = document.getElementById('file-tree');
    const contentDisplay = document.getElementById('content-display');
    const searchBox = document.getElementById('search-box');
    const contentSearchBox = document.getElementById('content-search-box');
    const expandAllBtn = document.getElementById('expand-all-btn');
    const collapseAllBtn = document.getElementById('collapse-all-btn');
    if (fileTreeContainer && contentDisplay) {
        const placeholder = contentDisplay.innerHTML;

        fetch('assets/data/notes-tree.json')
            .then(response => {
                if (!response.ok) throw new Error('Network response was not ok.');
                return response.json();
            })
            .then(data => {
                if (data && data.children) {
                    fileTreeContainer.innerHTML = '';
                    fileTreeContainer.appendChild(createTree(data.children));
                } else {
                    showError('Invalid or empty notes-tree.json');
                }
            })
            .catch(error => {
                console.error('Error fetching or parsing knowledge tree:', error);
                showError('无法加载笔记列表，请确认 `notes-tree.json` 文件存在且格式正确。');
            });

        function createTree(nodes) {
            const ul = document.createElement('ul');
            nodes.forEach(node => {
                const li = document.createElement('li');
                if (node.type === 'directory') {
                    const details = document.createElement('details');
                    details.className = 'folder-details';
                    details.open = false;

                    const summary = document.createElement('summary');
                    summary.className = 'folder-summary';
                    summary.innerHTML = `<svg class="icon folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg><svg class="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg><span class="folder-name">${node.name}</span>`;
                    
                    const subUl = createTree(node.children);
                    
                    details.appendChild(summary);
                    details.appendChild(subUl);
                    li.appendChild(details);
                } else if (node.type === 'file' && node.name.endsWith('.md')) {
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'file';
                    fileDiv.innerHTML = `<svg class="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg><span>${node.name.replace('.md', '')}</span>`;
                    fileDiv.dataset.path = node.path;
                    fileDiv.setAttribute('role', 'button');
                    fileDiv.setAttribute('tabindex', '0');
                    fileDiv.setAttribute('aria-label', `Open article: ${node.name.replace('.md', '')}`);
                    
                    const loadFile = (e) => {
                        document.querySelectorAll('.file.active').forEach(activeEl => {
                            activeEl.classList.remove('active');
                        });
                        e.currentTarget.classList.add('active');
                        
                        // Now we don't hide the search box, so the user can perform another search.
                        
                        // Construct the path to the pre-built HTML file
                        const htmlPath = `/articles/${e.currentTarget.dataset.path.replace(/\.md$/, '.html')}`;
                        
                        // Fetch and insert the content directly without iframe
                        fetch(htmlPath)
                            .then(response => response.text())
                            .then(html => {
                                // Create a temporary element to parse the HTML
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(html, 'text/html');
                                
                                // Extract the content from the main element
                                const mainContent = doc.querySelector('.content');

                                if (mainContent) {
                                    // 合并连续的 <p> 标签，解决行间距过大的问题
                                    let correctedHTML = mainContent.innerHTML.replace(/<\/p>\s*<p>/g, '<br>');
                                    contentDisplay.innerHTML = correctedHTML;
                                    initCodeCopyButtons();
                                } else {
                                    // Fallback to iframe if content cannot be extracted
                                    // 移动端使用容器包裹iframe以支持滚动
                                    const isMobile = window.innerWidth <= 900;
                                    if (isMobile) {
                                        contentDisplay.innerHTML = `
                                            <div class="iframe-container" style="overflow-y: auto; -webkit-overflow-scrolling: touch; max-height: ${window.innerHeight - 180}px;">
                                                <iframe src="${htmlPath}" frameborder="0" style="width: 100%; height: auto; min-height: 600px;"></iframe>
                                            </div>
                                        `;
                                    } else {
                                        contentDisplay.innerHTML = `<iframe src="${htmlPath}" frameborder="0" style="width: 100%; height: 100%; min-height: calc(100vh - 60px);"></iframe>`;
                                    }
                                }
                                
                                // 修复移动端滚动
                                fixMobileScrolling();
                            })
                            .catch(error => {
                                console.error('Error loading article:', error);
                                contentDisplay.innerHTML = `<p>Error loading article. Please try again later.</p>`;
                            });
                    };

                    fileDiv.addEventListener('click', loadFile);
                    fileDiv.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            loadFile(e);
                        }
                    });

                    li.appendChild(fileDiv);
                }
                ul.appendChild(li);
            });
            return ul;
        }

        function showError(message) {
            contentDisplay.innerHTML = `<div class="placeholder">${message}</div>`;
        }
        
        searchBox.addEventListener('input', () => {
            const searchTerm = searchBox.value.toLowerCase();
            const files = fileTreeContainer.querySelectorAll('.file');
            const folders = fileTreeContainer.querySelectorAll('.folder-details');

            files.forEach(file => {
                const fileName = file.textContent.toLowerCase();
                const fileVisible = fileName.includes(searchTerm);
                file.style.display = fileVisible ? '' : 'none';
            });

            folders.forEach(folder => {
                const folderName = folder.querySelector('.folder-summary').textContent.toLowerCase();
                const folderVisible = folderName.includes(searchTerm);
                const childFiles = folder.querySelectorAll('.file');
                let hasVisibleChild = false;
                childFiles.forEach(child => {
                    if (child.style.display !== 'none') {
                        hasVisibleChild = true;
                    }
                });

                if (folderVisible || hasVisibleChild) {
                    folder.style.display = '';
                    folder.open = searchTerm && hasVisibleChild;
                } else {
                    folder.style.display = 'none';
                }
            });
    
        });

        expandAllBtn.addEventListener('click', () => {
            const details = fileTreeContainer.querySelectorAll('details');
            details.forEach(detail => detail.open = true);
        });

        collapseAllBtn.addEventListener('click', () => {
            const details = fileTreeContainer.querySelectorAll('details');
            details.forEach(detail => detail.open = false);
        });

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        function createSnippet(content, term, maxLength = 200) {
            const lowerContent = content.toLowerCase();
            const lowerTerm = term.toLowerCase();
            const regex = new RegExp(lowerTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            
            let match;
            let bestSnippet = '';
            let maxScore = -1;

            if ((match = regex.exec(lowerContent)) !== null) {
                const index = match.index;
                const start = Math.max(0, index - Math.floor(maxLength / 2));
                const end = Math.min(content.length, start + maxLength);
                let snippet = content.slice(start, end);
                
                snippet = snippet.replace(regex, (match) => `<mark class="highlight">${match}</mark>`);
                
                if (start > 0) snippet = '...' + snippet;
                if (end < content.length) snippet = snippet + '...';
                
                bestSnippet = snippet;
            } else {
                bestSnippet = content.slice(0, maxLength) + (content.length > maxLength ? '...' : '');
            }

            return bestSnippet;
        }

        let searchIndex = [];
        let isIndexBuilt = false;

        function buildSearchIndex() {
            const allFiles = Array.from(fileTreeContainer.querySelectorAll('.file'));
            const fetchPromises = allFiles.map(file => {
                const htmlPath = `/articles/${file.dataset.path.replace(/\.md$/, '.html')}`;
                return fetch(htmlPath)
                    .then(response => response.text())
                    .then(html => {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const mainContent = doc.querySelector('.content');
                        return {
                            path: file.dataset.path,
                            content: mainContent ? mainContent.textContent.toLowerCase() : '',
                            name: file.textContent.toLowerCase(),
                            displayName: file.textContent
                        };
                    }).catch(() => null);
            });

            return Promise.all(fetchPromises).then(filesData => {
                searchIndex = filesData.filter(Boolean);
                isIndexBuilt = true;
            });
        }
        
        const debouncedSearch = debounce(() => {
            const currentContentSearchBox = document.getElementById('content-search-box');
            if (!currentContentSearchBox) return;
            const searchTerm = currentContentSearchBox.value.toLowerCase().trim();

            if (searchTerm === '') {
                contentDisplay.innerHTML = placeholder;
                const newContentSearchBox = document.getElementById('content-search-box');
                if (newContentSearchBox) {
                    newContentSearchBox.addEventListener('input', debouncedSearch);
                    addEnterKeyListener(newContentSearchBox);
                }
                return;
            }

            if (!isIndexBuilt) {
                contentDisplay.innerHTML = '<p>正在建立搜索索引，请稍候...</p>';
                buildSearchIndex().then(() => debouncedSearch());
                return;
            }

            contentDisplay.innerHTML = '<p>搜索中...</p>';
            
            setTimeout(() => {
                const matchedFiles = searchIndex.filter(fileData =>
                    fileData.content.includes(searchTerm) || fileData.name.includes(searchTerm)
                );
    
                const searchWrapperHTML = `<div class="content-search-wrapper">
                    <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    <input type="text" id="content-search-box" placeholder="Search content..." class="search-box" aria-label="Search content" value="${document.getElementById('content-search-box')?.value || ''}">
                </div>`;

                if (matchedFiles.length > 0) {
                    const resultsHTML = matchedFiles.map(fileData => {
                        const snippet = createSnippet(fileData.content, searchTerm);
                        return `<div class="search-result-item" data-path="${fileData.path}">
                                    <a href="#" class="search-result-link">${fileData.displayName}</a>
                                    <p class="search-result-snippet">${snippet}</p>
                                </div>`;
                    }).join('');
                    contentDisplay.innerHTML = searchWrapperHTML + `<div class="search-results">${resultsHTML}</div>`;
    
                    document.querySelectorAll('.search-result-item').forEach(item => {
                        item.addEventListener('click', (e) => {
                            e.preventDefault();
                            const path = item.dataset.path;
                            const fileElement = fileTreeContainer.querySelector(`.file[data-path="${path}"]`);
                            if (fileElement) {
                                fileElement.click();
                            }
                        });
                    });
                    const newContentSearchBox = document.getElementById('content-search-box');
                    if (newContentSearchBox) {
                        newContentSearchBox.addEventListener('input', debouncedSearch);
                        addEnterKeyListener(newContentSearchBox);
                        newContentSearchBox.focus();
                    }
                } else {
                    contentDisplay.innerHTML = searchWrapperHTML + `<p>未找到关于 "${currentContentSearchBox.value}" 的结果</p>`;
                    const newContentSearchBox = document.getElementById('content-search-box');
                    if (newContentSearchBox) {
                        newContentSearchBox.addEventListener('input', debouncedSearch);
                        addEnterKeyListener(newContentSearchBox);
                        newContentSearchBox.focus();
                    }
                }
            }, 50);

        }, 300);

        function addEnterKeyListener(element) {
            element.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    debouncedSearch();
                }
            });
        }

        contentSearchBox.addEventListener('input', debouncedSearch);
        addEnterKeyListener(contentSearchBox);

        contentSearchBox.addEventListener('focus', () => {
            if (!isIndexBuilt) {
                buildSearchIndex();
            }
        }, { once: true });

        function copyToClipboard(text) {
            if (navigator.clipboard && window.isSecureContext) {
                return navigator.clipboard.writeText(text);
            }
            return new Promise((resolve, reject) => {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.top = '-9999px';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        resolve();
                    } else {
                        reject(new Error('Copy command was unsuccessful.'));
                    }
                } catch (err) {
                    reject(err);
                } finally {
                    document.body.removeChild(textArea);
                }
            });
        }
    }

    function initCodeCopyButtons() {
        const codeBlocks = document.querySelectorAll('#content-display pre');
        codeBlocks.forEach(block => {
            // 防止重复添加按钮
            if (block.querySelector('.copy-btn')) {
                return;
            }
    
            const button = document.createElement('button');
            button.className = 'copy-btn';
            button.textContent = 'Copy';
            button.setAttribute('aria-label', 'Copy code to clipboard');
            block.appendChild(button);
    
            button.addEventListener('click', () => {
                const code = block.querySelector('code');
                if (code) {
                    copyToClipboard(code.textContent).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        button.textContent = 'Error';
                    });
                }
            });
        });
    }

 // From sidebar.js
const toggle = document.getElementById('sidebar-toggle');
const body = document.body;
const sidebar = document.querySelector('.sidebar');
let overlay = null;

// 移动端滚动修复函数
function fixMobileScrolling() {
    if (window.innerWidth <= 900) {
        // 修复主容器
        const mainWrapper = document.querySelector('.main-content-wrapper');
        if (mainWrapper) {
            mainWrapper.style.overflow = 'visible';
            mainWrapper.style.minHeight = 'auto';
        }
        
        // 修复内容区域
        const content = document.getElementById('content-display');
        if (content) {
            content.style.overflowY = 'auto';
            content.style.webkitOverflowScrolling = 'touch';
            content.style.maxHeight = window.innerHeight - 120 + 'px';
        }
        
        // 修复iframe容器
        const iframeContainers = document.querySelectorAll('.iframe-container');
        iframeContainers.forEach(container => {
            container.style.maxHeight = window.innerHeight - 180 + 'px';
            container.style.overflowY = 'auto';
            container.style.webkitOverflowScrolling = 'touch';
        });
    }
}

// 汉堡菜单拖拽功能 - 增强版
function initDraggableButton() {
    const button = document.getElementById('sidebar-toggle');
    if (!button) return;

    let isDragging = false;
    let startX, startY, initialX, initialY;
    let currentX = 16, currentY = 20; // 初始位置
    let dragThreshold = 5; // 拖拽阈值，防止误触
    let hasMoved = false;

    // 创建边界指示器
    const boundaryIndicator = document.createElement('div');
    boundaryIndicator.className = 'drag-boundary';
    document.body.appendChild(boundaryIndicator);

    // 从localStorage读取保存的位置
    const savedPosition = localStorage.getItem('sidebar-toggle-position');
    if (savedPosition) {
        const position = JSON.parse(savedPosition);
        currentX = Math.max(10, Math.min(position.x, window.innerWidth - button.offsetWidth - 10));
        currentY = Math.max(10, Math.min(position.y, window.innerHeight - button.offsetHeight - 10));
        button.style.left = currentX + 'px';
        button.style.top = currentY + 'px';
    }

    // 拖拽开始
    function startDrag(e) {
        if (window.innerWidth > 900) return; // 只在移动端启用拖拽
        
        // 防止点击事件冲突
        const target = e.target.closest('.sidebar-toggle');
        if (!target) return;
        
        isDragging = true;
        hasMoved = false;
        button.classList.add('dragging');
        boundaryIndicator.classList.add('active');
        
        const touch = e.type.includes('touch') ? e.touches[0] : e;
        startX = touch.clientX;
        startY = touch.clientY;
        
        initialX = button.offsetLeft;
        initialY = button.offsetTop;
        
        // 防止页面滚动
        document.body.classList.add('dragging');
        
        e.preventDefault();
        e.stopPropagation();
    }

    // 拖拽中
    function drag(e) {
        if (!isDragging) return;
        
        const touch = e.type.includes('touch') ? e.touches[0] : e;
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;
        
        // 检查是否移动了足够距离
        if (Math.abs(deltaX) > dragThreshold || Math.abs(deltaY) > dragThreshold) {
            hasMoved = true;
        }
        
        if (!hasMoved) return;
        
        let newX = initialX + deltaX;
        let newY = initialY + deltaY;
        
        // 边界检测（带边缘吸附效果）
        const buttonWidth = button.offsetWidth;
        const buttonHeight = button.offsetHeight;
        const maxX = window.innerWidth - buttonWidth - 10;
        const maxY = window.innerHeight - buttonHeight - 10;
        
        // 边缘吸附（10px范围内）
        if (newX < 20) newX = 10;
        if (newX > maxX - 10) newX = maxX;
        if (newY < 20) newY = 10;
        if (newY > maxY - 10) newY = maxY;
        
        button.style.left = newX + 'px';
        button.style.top = newY + 'px';
        
        currentX = newX;
        currentY = newY;
        
        e.preventDefault();
    }

    // 拖拽结束
    function endDrag(e) {
        if (!isDragging) return;

        const wasDragged = hasMoved;

        isDragging = false;
        hasMoved = false; // 立即重置状态
        button.classList.remove('dragging');
        boundaryIndicator.classList.remove('active');
        document.body.classList.remove('dragging');

        // 如果没有拖拽，则视为点击并切换侧边栏
        if (!wasDragged) {
            toggleSidebar();
        } else {
            // 如果拖拽了，则保存位置
            localStorage.setItem('sidebar-toggle-position', JSON.stringify({
                x: currentX,
                y: currentY
            }));
            
            // 添加保存成功的视觉反馈
            button.style.background = 'rgba(40, 167, 69, 0.9)';
            setTimeout(() => {
                button.style.background = 'rgba(255, 255, 255, 0.95)';
            }, 300);
        }
        
        e.preventDefault();
    }

    // 窗口大小改变时重新计算边界
    function handleResize() {
        if (window.innerWidth <= 900) {
            const maxX = window.innerWidth - button.offsetWidth - 10;
            const maxY = window.innerHeight - button.offsetHeight - 10;
            
            currentX = Math.max(10, Math.min(currentX, maxX));
            currentY = Math.max(10, Math.min(currentY, maxY));
            
            button.style.left = currentX + 'px';
            button.style.top = currentY + 'px';
            
            // 重新保存位置
            localStorage.setItem('sidebar-toggle-position', JSON.stringify({
                x: currentX,
                y: currentY
            }));
        }
    }

    // 绑定事件
    button.addEventListener('mousedown', startDrag);
    button.addEventListener('touchstart', startDrag, { passive: false });
    
    document.addEventListener('mousemove', drag);
    document.addEventListener('touchmove', drag, { passive: false });
    
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchend', endDrag);
    
    // 窗口大小改变时重新计算
    window.addEventListener('resize', handleResize);
    
    
    // 双击重置位置
    button.addEventListener('dblclick', function(e) {
        e.preventDefault();
        currentX = 16;
        currentY = 20;
        button.style.left = currentX + 'px';
        button.style.top = currentY + 'px';
        
        localStorage.removeItem('sidebar-toggle-position');
        
        // 视觉反馈
        button.style.background = 'rgba(255, 193, 7, 0.9)';
        setTimeout(() => {
            button.style.background = 'rgba(255, 255, 255, 0.95)';
        }, 300);
    });
}

// 窗口大小改变时重新计算
window.addEventListener('resize', fixMobileScrolling);

// 初始化拖拽功能
initDraggableButton();

    if (toggle && sidebar) {
        function createOverlay() {
            overlay = document.createElement('div');
            overlay.className = 'sidebar-overlay';
            overlay.setAttribute('role', 'presentation');
            overlay.addEventListener('click', closeSidebar);
            document.body.appendChild(overlay);
            window.getComputedStyle(overlay).opacity;
        }

        function removeOverlay() {
            if (overlay) {
                overlay.removeEventListener('click', closeSidebar);
                document.body.removeChild(overlay);
                overlay = null;
            }
        }

        function openSidebar() {
            if (!overlay) createOverlay();
            body.classList.add('sidebar-open');
            toggle.setAttribute('aria-expanded', 'true');
            sidebar.focus();
            sidebar.setAttribute('aria-hidden', 'false');
            scrollActiveIntoView();
        }

        function closeSidebar() {
            body.classList.remove('sidebar-open');
            toggle.setAttribute('aria-expanded', 'false');
            sidebar.setAttribute('aria-hidden', 'true');
            removeOverlay();
            document.body.style.overflow = '';
            toggle.focus();
        }

        function toggleSidebar() {
            if (body.classList.contains('sidebar-open')) closeSidebar();
            else openSidebar();
            
            // 添加激活状态类用于图标动画
            const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
            if (isExpanded) {
                toggle.classList.add('is-active');
            } else {
                toggle.classList.remove('is-active');
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && body.classList.contains('sidebar-open')) {
                closeSidebar();
            }
        });

        function scrollActiveIntoView() {
            const fileTree = document.getElementById('file-tree');
            if (!fileTree) return;
            const active = fileTree.querySelector('.file.active');
            if (active) {
                active.scrollIntoView({ block: 'center', behavior: 'smooth' });
            }
        }

        const observerTarget = document.getElementById('file-tree');
        if (observerTarget) {
            const mo = new MutationObserver(() => {
                scrollActiveIntoView();
            });
            mo.observe(observerTarget, { childList: true, subtree: true, attributes: true, attributeFilter: ['class'] });
        }

        sidebar.setAttribute('aria-hidden', 'true');

        document.getElementById('content-display')?.addEventListener('click', () => {
            if (window.innerWidth <= 900 && body.classList.contains('sidebar-open')) {
                closeSidebar();
            }
        });

        document.addEventListener('focusin', (e) => {
            if (body.classList.contains('sidebar-open') && sidebar && !sidebar.contains(e.target) && e.target !== toggle) {
                const focusableInSidebar = sidebar.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"]), details'
                );
                if (focusableInSidebar.length) {
                    focusableInSidebar.focus();
                }
            }
        });

        const folderDetails = sidebar.querySelectorAll('details');
        folderDetails.forEach(detail => {
            detail.setAttribute('tabindex', '0');
        });
    }
});

function setActiveLink() {
    const navLinks = document.querySelectorAll('.nav-link');
    const currentPage = window.location.pathname.split('/').pop() || 'index.html';
    navLinks.forEach(link => {
        const linkPage = link.getAttribute('href').split('/').pop();
        if (linkPage === currentPage) {
            link.classList.add('active');
        }
    });
}

function setupNavToggle() {
    const navToggle = document.querySelector('.nav-toggle');
    const mainNav = document.querySelector('.main-nav');
    if (navToggle && mainNav) {
        navToggle.addEventListener('click', () => {
            const isExpanded = mainNav.classList.toggle('is-active');
            navToggle.classList.toggle('is-active');
            navToggle.setAttribute('aria-expanded', isExpanded);
            if (isExpanded) {
                mainNav.style.display = 'flex';
                mainNav.style.maxHeight = mainNav.scrollHeight + 'px';
            } else {
                mainNav.style.maxHeight = '0';
            }
        });
    }
}