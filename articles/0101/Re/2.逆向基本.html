<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 逆向基本,逆向基本</title>
    <link rel="stylesheet" href="../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>逆向基本</h1>
<h2>1.函数调用约定</h2>
<p>函数原型: 参数个数及类型、返回值</p>
<p>函数序言和尾声：开辟和释放栈帧</p>
<p>C++程序：</p>
<ul>
<li>x86 架构：cdecl，stdcall，fastcall，thiscall</li>
<li>x86-64 架构：变形 fastcall，thiscall</li>
</ul>
<h3>1.1 __cdecl</h3>
<ul>
<li>C 调用约定</li>
<li>UNIX 系统中常用的钟函数调用约定</li>
<li>传参：逆序传参</li>
<li>栈平衡，<strong>调用者</strong> 清理</li>
</ul>
<h3>1.2 __stdcall</h3>
<ul>
<li>标准调用约定</li>
<li>Windows API 使用 stdcall</li>
<li>传参：逆序传参</li>
<li>栈平衡，<strong>被调用者</strong> 清理，retn + 数字</li>
</ul>
<h3>1.3 __fastcall</h3>
<ul>
<li>快速调用约定</li>
<li>windows 中的一种高效调用</li>
<li>传参：前两个参数 ecx，edx 传，后面 stdcall，将参数优先从寄存器传入，剩下的参数再从右向左从栈传入</li>
<li>参数个数小于等于 2 个时不存在栈平衡的问题</li>
</ul>
<h3>1.4 __thiscall</h3>
<ul>
<li>用于 x86 体系结构上的 C++ 类成员函数</li>
<li>栈平衡，被调用者清理</li>
</ul>
<h2>2.基本数据类型</h2>
<blockquote>
<p>二进制代码中只有内存大小，没有类型信息</p>
</blockquote>
<ul>
<li>
<p>全局变量位于全局数据区，已被初始化：初始化全局变量的常量已被赋值到全局数据区，没有产生代码</p>
</li>
<li>
<p>局部变量:</p>
<ul>
<li>位于栈中，使用 [ebp-x] 的格式对其引用</li>
<li>产生汇编代码实现初始化赋值</li>
<li>先声明的变量位于栈底，高地址</li>
<li>后声明的变量位于栈顶，低地址</li>
<li>数字常量作为指令的立即数，位于代码段</li>
<li>字符串常量位于全局静态区</li>
</ul>
</li>
<li>
<p>指针：int <em>，double</em>，char *</p>
</li>
</ul>
<h2>3.基本操作类型</h2>
<ul>
<li>
<p>加，减，乘，除（cdq 指令，有符号数的扩展）</p>
<table>
<thead>
<tr>
<th>被除数</th>
<th>除数</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AX</td>
<td>reg/mem8</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td>DX: AX</td>
<td>reg/mem16</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr>
<td>EDX: EAX</td>
<td>reg/mem32</td>
<td>EAX</td>
<td>EDX</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>逻辑运算</p>
</li>
<li>
<p>浮点指令</p>
</li>
</ul>
<h2>4.基本控制结构</h2>
<h3>4.1 顺序结构</h3>
<h3>4.2 分支结构</h3>
<ul>
<li>
<p>if/else：编译时，跳转指令为 true 是 else 的内容，跳转指令后面是 if 的内容</p>
</li>
<li>
<p>switch</p>
<p><img src="/0101/Re/assets/2.%E9%80%86%E5%90%91%E5%9F%BA%E6%9C%AC/image-20240906092845075.png" alt="image-20240906092845075"></p>
<ul>
<li>
<p>case 分支小于 4 个时，其反汇编与 if…else 类似：一系列的 cmp 和跳转指令</p>
<p><img src="/0101/Re/assets/2.%E9%80%86%E5%90%91%E5%9F%BA%E6%9C%AC/image-20240909080658679.png" alt="image-20240909080658679"></p>
</li>
<li>
<p>当 case 分支大于等于 4 个且连续时，会在一段连续内存中存储每个 case 所对应语句块的起始地址（称其为大表或跳转表），根据[edx*4+xxxxxxh]即可确定跳转地址</p>
<ul>
<li>
<p>case 条件连续时，使用单跳转表</p>
<p><img src="/0101/Re/assets/2.%E9%80%86%E5%90%91%E5%9F%BA%E6%9C%AC/image-20240909081236790.png" alt="image-20240909081236790"></p>
</li>
<li>
<p>case 条件不连续时，使用二级跳转表技术, 不存在的常量地址填补 default 段的首地址</p>
<p><img src="/0101/Re/assets/2.%E9%80%86%E5%90%91%E5%9F%BA%E6%9C%AC/image-20240909081927464.png" alt="image-20240909081927464"></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>break，continue：被编译成无条件跳转</p>
</li>
</ul>
<h3>4.3 循环结构</h3>
<ul>
<li>
<p>while 循环：流程图一般含 2 个基本块</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main()
{
    int i=0,a =0;
    while (i&lt;=10)
    {
    	a+=i;
    	i++
	}
	return 0;
}
</code></pre>
<p><img src="/0101/Re/assets/2.%E9%80%86%E5%90%91%E5%9F%BA%E6%9C%AC/image-20240906110603979.png" alt="image-20240906110603979"></p>
</li>
<li>
<p>do/while 循环：流程图一般含 1 个基本块，与其他循环的显著区别就是为真判断时继续执行，回跳的线为绿色</p>
<p><img src="/0101/Re/assets/2.%E9%80%86%E5%90%91%E5%9F%BA%E6%9C%AC/image-20240909082440781.png" alt="image-20240909082440781"></p>
</li>
<li>
<p>for 循环：流程图一般含 3 个基本块</p>
<p><img src="/0101/Re/assets/2.%E9%80%86%E5%90%91%E5%9F%BA%E6%9C%AC/image-20240909082544847.png" alt="image-20240909082544847"></p>
</li>
</ul>
<h2>5.数据结构</h2>
<ul>
<li>结构体 struct</li>
<li>联合体 union：所有成员公用一块内存空间，size 为成员的最大 size。特点：同一个内存位置进行不同赋值</li>
<li>位段：指定了各成员存储位数的结构体或联合体，表示存储该成员的位数，称为位宽。在 unsigned 类型或 int 类型的成员（只能这两种）名后依次加上冒号和代表位段宽度的整数常量。对成员变量运算时采取移位操作，再 and 或 or</li>
<li>枚举 enum</li>
<li>自引用结构：结构体中包含指针类型的成员变量，这些指针变量的数据类型与当前结构体相同，即指向与自身同类型的指针
<ul>
<li>链表</li>
<li>队列</li>
<li>二叉树</li>
<li>堆栈</li>
</ul>
</li>
<li>用点.访问：编译时就直接定位了，逆向时看不出是结构体</li>
<li>用箭头-&gt; 访问：根据结构体偏移，可以识别出是结构体</li>
</ul>
<h2>6.类与对象</h2>
<h3>6.1 内存布局</h3>
<ul>
<li>先声明的成员变量位于低地址，后声明的成员变量位于高地址</li>
<li>静态成员变量位于全局变量区，不占用对象自身的空间</li>
<li>对齐值 = min(数据成员类型长度，指定给编译器的对其长度)</li>
<li>成员变量的分布在对齐值的整数倍上</li>
<li>对象，结构体的大小是 q 的整数倍：
<ul>
<li>
<p>M~max~= max(M~i~)，q = min(M~max~，N)</p>
</li>
<li>
<p>Mi 为第 i 个数据成员的类型长度，N 为指定给编译器的对齐长度</p>
</li>
<li>
<pre><code class="language-c">#pragma pack(N)
// N 表示对齐字节，即成员变量首地址是 N 的倍数
</code></pre>
</li>
</ul>
</li>
</ul>
<h3>6.2 this 指针</h3>
<ul>
<li>通过 this 指针访问数据成员，this 指针使用过程被编译器隐藏，this 指针指向对象/结构体的首地址，用于访问数据成员变量和成员函数</li>
<li>this 调用约定：使用 ecx 寄存器保存对象的首地址，并使用寄存器传参方式传递到成员函数中。表明本次成员函数的调用是由该 this 指针指向的对象指针调用的。隐藏了 this 指针的传递，即所有的成员函数将 this 指针作为一个参数，隐含传递 this 指针。<strong>被调用者</strong> 负责处理栈平衡</li>
<li>注意：不能指定某个函数使用 thiscall 调用约定，没有对应的关键字</li>
</ul>
<h3>6.3 对象参数</h3>
<ul>
<li>对象参数：将对象/结构体作为函数的参数，对象参数的传递过程复杂，传递方式独特，传递对象的所有数据成员，使用 <strong>拷贝</strong> 的方式</li>
</ul>
<h3>6.4 对象返回值</h3>
<ul>
<li>将对象/结构体作为函数的返回值</li>
</ul>
<h2>7.构造函数与析构函数</h2>
<p>生命周期由对象所在的作用域决定</p>
<p>对象进入作用域时生命周期开始，调用构造函数</p>
<p>对象退出作用域时生命周期结束，调用析构函数</p>
<p>对象类型：局部对象，堆对象，堆对象数组，参数对象，返回对象，全局对象，静态对象</p>
<h3>7.1 构造函数出现时机与识别</h3>
<h4>7.1.1 局部对象</h4>
<ul>
<li>在函数体内定义的对象</li>
<li>对象产生时由编译器实现构造函数的调用</li>
<li>构造函数默认使用 thiscall 调用约定，返回 this 指针</li>
</ul>
<h4>7.1.2 堆对象</h4>
<ul>
<li>通过 new、malloc 或其他同功能的函数申请堆空间，例如： Cnumber * pNumber = new CNumber;</li>
<li>申请成功后即调用无参构造函数</li>
<li>注意：new 分配成功才调用构造函数，故双分支</li>
</ul>
<h4>7.1.3 参数对象</h4>
<ul>
<li>
<p>参数对象属于局部对象中的一种特殊情况</p>
</li>
<li>
<p>对象作为函数参数时，被调用函数将调用一个特殊的构造函数：拷贝构造函数</p>
</li>
<li>
<p>拷贝构造函数：只有一个参数，类型为对象的引用</p>
<ul>
<li>例：CMyString(CMyString &amp;obj)</li>
<li>obj 是被拷贝的对象</li>
<li>函数语义：将参数指向的对象深拷贝到调用拷贝构造函数的对象</li>
<li>深拷贝：不仅拷贝对象体，还拷贝对象引用的内存资源，如堆内存</li>
<li>拷贝的实现代码由程序员实现</li>
</ul>
</li>
</ul>
<h4>7.1.4 返回对象</h4>
<ul>
<li>对象作为函数的返回值，是局部对象中的一种特殊情况</li>
<li>对象被返回时，调用拷贝构造函数
<ul>
<li>原因是对象返回时需要拷贝返回对象</li>
<li>新对象的生命周期开始则调用构造函数</li>
<li>调用时机是在函数返回时</li>
</ul>
</li>
</ul>
<h4>7.1.5 全局对象和静态对象</h4>
<ul>
<li>全局对象是定义在全局作用域中的对象</li>
<li>静态对象是使用 static 关键字定义的对象</li>
<li>二者的构造函数调用时机相同</li>
</ul>
<h3>7.2 默认构造函数</h3>
<p>并非每个对象都有默认的构造函数</p>
<p>条件：</p>
<ul>
<li>本类、本类中定义的成员对象或者父类中有虚函数存在
<ul>
<li>此时，虚表的初始化工作需要在构造函数中隐式完成</li>
</ul>
</li>
<li>父类或本类中定义的成员对象带有构造函数
<ul>
<li>此时，继承关系的构造过程是先构造父类，再构造子类，父类的构造函数在子类的构造函数中调用</li>
</ul>
</li>
</ul>
<h3>7.3 析构函数</h3>
<p>该函数的调用时某对象在作用域内的最后一次成员函数调用，通过 this 指针来分辨是那个对象的成员函数。使用 thiscal 调用方式，使用 ecx 寄存器来传递 this 指针。没有返回值。也没有参数。不支持重载，且形式上是一个无参函数</p>
<h4>7.3.1 局部对象</h4>
<ul>
<li>定义局部对象的函数执行结束后，由编译器实现析构函数的调用</li>
</ul>
<h4>7.3.2 堆对象</h4>
<ul>
<li>在释放对象的内存空间时调用其析构函数</li>
<li>C++代码中，释放对象需由程序员编写代码实现，若代码中未写释放对象的代码，则对象不会被析构</li>
<li>编译器产生析构代理函数实现 delete 函数的调用，完成对象释放</li>
</ul>
<h4>7.3.3 参数对象</h4>
<ul>
<li>函数代码执行结束后，调用参数对象的析构函数，释放内存空间</li>
<li>参数传递时拷贝参数对象，调用被拷贝参数对象的析构函数</li>
</ul>
<h4>7.3.4 返回对象</h4>
<ul>
<li>函数代码执行结束后，调用返回对象的析构函数，释放内存空间</li>
</ul>
<h4>7.3.5 全局对象和静态对象</h4>
<ul>
<li>全局对象是定义在全局作用域中的对象，静态对象是使用 static 关键字定义的对象，二者的析构函数调用时机相同</li>
<li>main 函数执行结束后，调用 exit-&gt; doexit，实现析构函数调用</li>
</ul>
<h2>8.虚函数</h2>
<ul>
<li>
<p>虚函数是面向对象程序设计的关键组成部分，是 C++ 的精髓；用于完成面向对象程序设计中对象的多态性；虚函数必须是类的成员函数</p>
</li>
<li>
<p>使用 virtual 声明虚函数</p>
</li>
<li>
<p>编译器在对象的首地址处预留一个隐式的数据成员，填入虚表的内存地址，即虚表指针</p>
</li>
<li>
<p>编译器将类的所有虚函数的首地址保存在一张地址表中，这张表被称为虚函数地址表，简称虚表，虚表中存放着具体实现代码的首地址</p>
</li>
</ul>
<p><img src="/0101/Re/assets/2.%E9%80%86%E5%90%91%E5%9F%BA%E6%9C%AC/image-20241011084237806.png" alt="image-20241011084237806"></p>
<p>虚函数的调用过程：</p>
<ul>
<li>对象指针通过虚表指针调用虚函数，使用 this 调用预定
<ul>
<li>通过 this 指针取出虚表指针</li>
<li>通过虚表指针定位到虚表，将虚表指针临时存入寄存器</li>
<li>将 this 指针传递到寄存器，this 调用约定，一般是 ecx 寄存器，通过 call [寄存器+偏移] 的指令格式调用虚函数，使用偏移值定位到虚表中的虚函数指针，偏移值在编译时确定</li>
</ul>
</li>
<li>对象直接调用自身的虚函数，无需虚表指针</li>
</ul>
<p>逆向分析是一个相互佐证的过程：</p>
<ul>
<li>使用虚表指针识别构造函数和析构函数</li>
<li>只有构造函数和析构函数中存在对虚表指针的操作，找到虚表后，使用 IDA 的引用参考可索引到所有对构造函数和析构函数，“交叉参考到”xrefs to VirTable 的快捷键是 x 键</li>
</ul>
<p>虚函数安全性问题：误用导致的 UAF 漏洞：</p>
<ul>
<li>Use After Free，是指一块内存被释放后再次被使用</li>
<li>分为以下几种情况：
<ul>
<li>内存被释放后，其对应的指针被置为 NULL，再次使用导致崩溃；</li>
<li>内存被释放后，其对应的指针未被置为 NULL，在下次使用前，没有代码修改这块内存，则程序的执行本身可能正常运行；</li>
<li>内存被释放后，其对应的指针未被置为 NULL，但在下次使用前，这块内存被修改，则可能会导致安全缺陷问题。</li>
</ul>
</li>
</ul>
<p><img src="/0101/Re/assets/2.%E9%80%86%E5%90%91%E5%9F%BA%E6%9C%AC/image-20241105203355973.png" alt="image-20241105203355973"></p>
<h2>9.继承关系</h2>
<p>继承关系中对象的构造与析构顺序:</p>
<ul>
<li>构造过程：父类 -&gt; 子类 … -&gt; 当前类</li>
<li>析构过程：当前类 -&gt; 子类 … -&gt; 父类</li>
</ul>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../assets/js/header.js"></script>
    <script src="../../assets/js/include-header.js"></script>
</body>
</html>