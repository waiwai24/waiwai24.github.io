<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 花指令,花指令</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>花指令</h1>
<blockquote>
<p>花指令通常用来抵御静态分析， 通过花指令混淆的程序， 会扰乱汇编代码的可读性</p>
</blockquote>
<ul>
<li>在静态分析下， 使反汇编器无法正常解析， 反编译器无法正常反编译。</li>
<li>在反汇编的过程中， 存在一个数据与代码的区分问题。</li>
</ul>
<h2>1.两类反汇编算法</h2>
<p>线性扫描算法(LinearSweep)</p>
<ul>
<li>从第一个字节开始， 以线性模式扫描整个代码段， 将一条指令的结束作为另一条指令的开始，逐条反汇编每条指令， 直到完成整个代码段的分析。</li>
<li>由于没有考虑代码中可能混有的数据， 容易出错</li>
</ul>
<p>递归行进算法(Recursivetraversal)</p>
<ul>
<li>对代码可能的执行路径进行扫描， 当解码出分支指令后， 就把这个分支指令的地址记录下来， 并反汇编各个分支中的指令。</li>
<li>这种算法可以避免将代码中的数据作为指令解析。</li>
</ul>
<h2>2.花指令原理</h2>
<p>在正常的程序中巧妙嵌入数据，使得反汇编器在解析的时候，误认为是代码一同解析， 从而在静态分析层面干扰了逆向分析者，这就是花指令。</p>
<p>花指令需要逆向分析者花时间将这些数据从程序中剔除掉， 还原原有正常程序， 从而正常地实现反汇 编和反编译</p>
<h2>3.常见花指令混淆手段</h2>
<p>Call, Jmp，Push 类指令形成的混淆：</p>
<table>
<thead>
<tr>
<th><a href="https://shell-storm.org/x86doc/CALL.html">CALL</a> rel16</th>
<th>E8 cw</th>
<th>Call near, relative, displacement relative to next instruction.</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://shell-storm.org/x86doc/CALL.html">CALL</a> rel32</td>
<td>E8 cd</td>
<td>Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/CALL.html">CALL</a> r/m16</td>
<td>FF /2</td>
<td>Call near, absolute indirect, address given in r/m16.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/CALL.html">CALL</a> r/m32</td>
<td>FF /2</td>
<td>Call near, absolute indirect, address given in r/m32.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/CALL.html">CALL</a> r/m64</td>
<td>FF /2</td>
<td>Call near, absolute indirect, address given in r/m64.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/CALL.html">CALL</a> ptr16:16</td>
<td>9A cd</td>
<td>Call far, absolute, address given in operand.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/CALL.html">CALL</a> ptr16:32</td>
<td>9A cp</td>
<td>Call far, absolute, address given in operand.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/CALL.html">CALL</a> m16:16</td>
<td>FF /3</td>
<td>Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero  extended displacement taken from gate; else RIP = zero extended 16-bit  offset from far pointer referenced in the instruction.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/CALL.html">CALL</a> m16:32</td>
<td>FF /3</td>
<td>In 64-bit mode: If selector points to a gate, then RIP =  64-bit displacement taken from gate; else RIP = zero extended 32-bit  offset from far pointer referenced in the instruction.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/CALL.html">CALL</a> m16:64</td>
<td>REX.W + FF /3</td>
<td>In 64-bit mode: If selector points to a gate, then RIP =  64-bit displacement taken from gate; else RIP = 64-bit offset from far  pointer referenced in the instruction.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> rel8</th>
<th>EB cb</th>
<th>Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> rel16</td>
<td>E9 cw</td>
<td>Jump near, relative, displacement relative to next instruction. Not supported in 64-bit mode.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> rel32</td>
<td>E9 cd</td>
<td>Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> r/m16</td>
<td>FF /4</td>
<td>Jump near, absolute indirect, address = zero-extended r/m16. Not supported in 64-bit mode.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> r/m32</td>
<td>FF /4</td>
<td>Jump near, absolute indirect, address given in r/m32. Not supported in 64-bit mode.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> r/m64</td>
<td>FF /4</td>
<td>Jump near, absolute indirect, RIP = 64-Bit offset from register or memory</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> ptr16:16</td>
<td>EA cd</td>
<td>Jump far, absolute, address given in operand</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> ptr16:32</td>
<td>EA cp</td>
<td>Jump far, absolute, address given in operand</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> m16:16</td>
<td>FF /5</td>
<td>Jump far, absolute indirect, address given in m16:16</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> m16:32</td>
<td>FF /5</td>
<td>Jump far, absolute indirect, address given in m16:32.</td>
</tr>
<tr>
<td><a href="https://shell-storm.org/x86doc/JMP.html">JMP</a> m16:64</td>
<td>REX.W + FF /5</td>
<td>Jump far, absolute indirect, address given in m16:64.</td>
</tr>
</tbody>
</table>
<p>Microsoft 专用 <strong><code>__asm</code></strong> 关键字用于调用内联汇编程序，并且可在 C 或 C++ 语句合法时出现。 它不能单独出现。 它必须后跟一个程序集指令、一组括在大括号中的指令或者至少一对空大括号。 此处的术语“<strong><code>__asm</code></strong> 块”指任何指令或指令组（无论是否在大括号中）。</p>
<p>实例：</p>
<h3>3.1 call 指令混淆</h3>
<pre><code class="language-asm">__asm{
	xor eax,eax
	jz __lable
	__emit 0xe8 //call 混合在代码段的数据，不会执行，dan因为ida采用的是递归扫描的办法所以能够正常识别
}

__lable:
</code></pre>
<pre><code class="language-asm">//下面内联汇编的作用，其实就是干扰ida解析，但是对程序执行无影响
//下面三条指令，相当将esp栈顶地址对应值更新为【:esp】+0xc，eax 不变
//实现 retn 后，栈顶【:esp】+0xc，即retn后不会跳出函数，而是继续执行
__asm
{
	call    $+5
	xchg    eax, ds:[esp]
	lea     eax, [eax+0Ch]
	xchg    eax, ds:[esp]
	retn
}
//注：$是intel汇编格式中的一个预定义符号，表示当前指令所在的地址偏移
</code></pre>
<pre><code class="language-asm">int addr = 0x00411BFB;
int tmp  = 0x12345678;
__asm
{
    mov     eax, addr
    xor		eax, tmp
    xor		eax, tmp
    jmp     eax        //这里换为call 也是相同的，eax = addr
}
（地址是随机的！这里需要关闭VS 的地址随机化，才能在找到正确跳转地址）
</code></pre>
<h3>3.2 jmp 指令混淆</h3>
<pre><code class="language-asm">__asm  
{
	xor eax,eax
	jz __lable
	// 这里 EB E9 EA 都是相同的
	__emit 0xeb  //jmp 定义混合在代码段的数据 ,不会执行但是能干扰ida反汇编
}
__lable:
</code></pre>
<pre><code class="language-asm">__asm
{
    xor eax, eax
    //jz直接跳转到 label, 不会执行下一个jnz指令
    //动态实际不否执行此语句， 只是在给静态分析增加迷惑性
    jz __lable1
    jnz __lable2

    __lable2 :
    // 这里 EB E9 EA 都是相同的
    __emit 0xEB  //jmp 定义混合在代码段的数据 ,不会执行但是能干扰ida反汇编
}
__lable1:
</code></pre>
<h3>3.3 push 指令混淆</h3>
<pre><code class="language-ASM">int addr1=0x00411C6F;
__asm
{
    push	esp
    push    addr1
    retn
    pop   	esp
}
</code></pre>
<h3>3.4 垃圾指令</h3>
<pre><code class="language-asm">__asm
{
    popf
    push    eax
    pop     eax
    push    edx
    pop     edx
    pushf
}

__asm
{
    pushf
    push    ecx
    xor     eax, ecx
    xor     ecx, eax
    xor     eax, ecx
    xchg    eax, ecx
    pop     ecx
    popf
}

__asm
{
    popf
    pushf
}

__asm
{
    push    eax
    push    ecx
    pop     eax
    pop     ecx
    push    eax
    push    ecx
    pop     eax
    pop     ecx
}
</code></pre>
<p>上面是几个简单例子，如何构建完全可以自行创造</p>
<pre><code class="language-asm">__asm {
    call TEST1
    add [esp+4-4],10
    TEST1:
        add [esp+4-4],11
        retn 
}
</code></pre>
<p>同时上述垃圾指令，最好配合其他花之恋使用，单独使用很可能会被编译器自动优化过滤，使用效果不佳</p>
<h2>4.花指令去除</h2>
<p>对于上述加花指令思路，有两种解决方案：</p>
<ul>
<li>对程序流不起作用或者干扰反汇编解析的指令直接 nop（change byte ，按 C 强制数据转换成指令代码 或者使用idc脚本）</li>
<li>对程序流起关联跳转作用的花指令，等效替换为工具可识别的指令</li>
</ul>

        </main>
    </div>
</body>
</html>