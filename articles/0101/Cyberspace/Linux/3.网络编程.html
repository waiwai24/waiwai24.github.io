<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 网络编程,网络编程</title>
    <link rel="stylesheet" href="../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>网络编程</h1>
<p><img src="/0101/Cyberspace/Linux/assets/3.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20251020081652081.png" alt="image-20251020081652081"></p>
<h2>1.基本函数及结构体</h2>
<p>socket 函数用于创建一个 socket 描述符来唯一表示一个 socket</p>
<ul>
<li>domain：协商域/协议族，决定了 socket 的地址类型，常用的有 AF_INET（使用 32 位 ipv4 地主之和 16 位端口号的组合）、AF_INET6、AF_LOCAL（或称 AF_UNIX，Unix 域 socket，使用一个绝对地址路径）、AF_ROUTE 等等</li>
<li>type：指定 socket 类型，常用的有 SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET 等等</li>
<li>protocol：协议，常用的有 IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC 等等，当 protocol 为 0 时，会自动选择 type 类型对应的默认协议</li>
</ul>
<pre><code class="language-c">int socket(int domain, int type, int protocol);
</code></pre>
<p>bind 函数用于把一个地址族中的特定地址赋值给 socket</p>
<ul>
<li>sockfd：即 socket 描述字，通过 socket 函数创建</li>
<li>addr：一个 const struct sockaddr* 指针，指向要绑定给 sockfd 的协议地址</li>
<li>addrlen：对应地址长度</li>
</ul>
<pre><code class="language-c">int bind(int sockfd, const struct sockaddr *addr, int addrlen);
</code></pre>
<p>listen 函数用于监听 socket</p>
<ul>
<li>sockfd：要监听的 socket 描述字</li>
<li>backlog：相应 socket 可以排队的最大连接个数</li>
</ul>
<pre><code class="language-c">int listen(int sockfd, int backlog);
</code></pre>
<p>accept 函数用于监听指定的 socket 地址</p>
<ul>
<li>sockfd：服务器的 socket 描述字</li>
<li>addr：用于返回客户端的协议地址</li>
<li>addrlen：协议地址的长度</li>
</ul>
<pre><code class="language-c">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre>
<p>connect 函数用于建立连接</p>
<ul>
<li>sockfd：客户端的 socke 描述字</li>
<li>addr：服务器的 socket 地址</li>
<li>addrlen：sizeof(addr)</li>
</ul>
<pre><code class="language-c">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
<p>close 函数用于关闭相应的 socket 描述字，注意：close 操作只是使相应 socket 描述字的引用计数-1，只有当引用计数为 0 时，才会触发终止连接</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
int close(int fd);
</code></pre>
<p>sockaddr 结构体的类型定义如下：</p>
<pre><code class="language-c">struct sockaddr {
  sa_family_t sa_family;
  char     sa_data[14];
}
</code></pre>
<p>sockaddr_in 结构体的类型定义如下：</p>
<pre><code class="language-c">struct sockaddr_in {
	sa_family_t     sin_family;     /* AF_INET */
	in_port_t       sin_port;       /* Port number */
	struct in_addr  sin_addr;       /* IPv4 address */
};
</code></pre>
<p>addrinfo 结构体的类型定义如下：</p>
<pre><code class="language-c">struct addrinfo {
	int              ai_flags;
	int              ai_family;
	int              ai_socktype;
	int              ai_protocol;
	socklen_t        ai_addrlen;
	struct sockaddr *ai_addr;
	char            *ai_canonname;
	struct addrinfo *ai_next;
};
</code></pre>
<p>getaddrinfo：</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *restrict node,
                const char *restrict service,
                const struct addrinfo *restrict hints,
                struct addrinfo **restrict res);

void freeaddrinfo(struct addrinfo *res);
</code></pre>
<h2>2.select 非阻塞 IO 多路复用</h2>
<p>Unix 下的 5 种 IO 模型：阻塞 IO 模型，非阻塞 IO 模型，IO 多路复用模型（一个线程可以监视多个描述符），信号驱动 IO 模型，异步 IO 模型</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>select</strong></th>
<th><strong>poll</strong></th>
<th><strong>epoll</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>时间复杂度</strong></td>
<td>$O(n)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><strong>工作原理</strong></td>
<td><strong>无差别轮询</strong>。内核只通知“有”事件，应用需遍历所有FD来查找。</td>
<td><strong>无差别轮询</strong>。与 <code>select</code> 基本相同，只是数据结构不同。</td>
<td><strong>事件驱动</strong>。内核直接通知应用哪些FD已就绪。</td>
</tr>
<tr>
<td><strong>数据拷贝</strong></td>
<td>每次调用都需要把整个FD集合从用户空间拷贝到内核空间。</td>
<td>每次调用都需要把整个FD集合从用户空间拷贝到内核空间。</td>
<td>首次注册时拷贝一次，之后通过共享内存，无需重复拷贝。</td>
</tr>
<tr>
<td><strong>核心缺点</strong></td>
<td>1. 性能随连接数增加而线性下降。 2. 有最大连接数限制（通常是1024）。 3. 内核/用户空间数据拷贝开销大。</td>
<td>1. 性能随连接数增加而线性下降。 2. 内核/用户空间数据拷贝开销大。</td>
<td>平台局限性，是 Linux 特有的实现。</td>
</tr>
<tr>
<td><strong>核心优点</strong></td>
<td>跨平台兼容性好。</td>
<td>解除了最大连接数的限制。</td>
<td><strong>效率极高</strong>，性能不随连接总数增加而下降，只与活跃连接数相关。</td>
</tr>
</tbody>
</table>
<p>select 函数用于 “阻塞等待” 多个 fd 中任意一个就绪（如可读、可写），或超时 / 出错后返回</p>
<ul>
<li>nfds：必须是监听所有 fd 中最大值+1</li>
<li>readfds，writefds，exceptfds：监听可读/可写/异常事件的 fd 集合，若为 NULL，则表示不监听</li>
<li>timeout：阻塞超时时间：NULL 则代表永久阻塞；0 代表非阻塞立即返回；非 0 值则代表阻塞指定时间</li>
<li>返回值为正数表示就绪的 fd 总数，0 表示都超时，-1 表示调用失败</li>
</ul>
<p>fd_set 是一个文件描述符（fd，通常最大是 1024）的集合，本质是内核维护的位图（或数组），用于标记 “需要监听的 fd”。该类型不透明（用户无需关心内部实现），只能通过下方 4 个专用宏操作，不能直接赋值或修改</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>功能说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td>FD_ZERO(fd_set *set)</td>
<td>清空 set 集合，将所有位设为 0。</td>
<td>必须在初始化 fd_set 时第一步调用，否则集合可能残留脏数据。</td>
</tr>
<tr>
<td>FD_SET(int fd, fd_set *set)</td>
<td>将 fd 加入 set 集合，标记为 “需要监听”。</td>
<td>fd 必须是合法的（已打开且未关闭），且不能超过 FD_SETSIZE。</td>
</tr>
<tr>
<td>FD_CLR(int fd, fd_set *set)</td>
<td>将 fd 从 set 集合中移除，不再监听。</td>
<td>常用于 fd 关闭后，避免监听无效描述符。</td>
</tr>
<tr>
<td>FD_ISSET(int fd, fd_set *set)</td>
<td>判断 fd 是否在 set 集合中（即是否就绪），返回非 0 表示就绪，0 表示未就绪。</td>
<td>仅在 select 返回后调用，用于遍历判断哪个 fd 触发了事件。</td>
</tr>
</tbody>
</table>
<pre><code class="language-c">#include &lt;sys/select.h&gt;

typedef /* ... */ fd_set;

int select(int nfds, fd_set *_Nullable restrict readfds,
           fd_set *_Nullable restrict writefds,
           fd_set *_Nullable restrict exceptfds,
           struct timeval *_Nullable restrict timeout);

void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);
</code></pre>
<h2>3.epoll 多路复用</h2>
<p>epoll 相较于 select 的优点是无需通过轮询就可以找到 IO 事件的连接，并且没有描述符个数限制，它在内核初始化的时候向内核注册了一个文件系统，用于存储上述被监控的 socket，所以无需轮询所有的 socket 连接，有点类似空间换时间</p>
<h2>4.粘包拆包问题</h2>
<p>socket 粘包 / 拆包问题仅存在于 TCP 协议中，核心原因是 TCP 是 “面向字节流” 的传输协议（无消息边界），会将数据按缓冲区大小拆分 / 合并；而 UDP 是 “面向数据报” 的协议（有天然消息边界），不存在此问题</p>
<p>粘包：发送端连续发送的多个小数据包，被 TCP 合并为一个数据包传输，接收端一次读取到多个消息的混合数据</p>
<p>拆包：送端发送的一个大数据包，超过 TCP 发送缓冲区或 MSS（最大分段大小），被 TCP 拆分为多个小数据包传输，接收端需多次读取才能获取完整消息</p>
<p>简单场景通常用 “定长包 / 分隔符” 的方法来解决此问题</p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../assets/js/header.js"></script>
    <script src="../../../assets/js/include-header.js"></script>
</body>
</html>