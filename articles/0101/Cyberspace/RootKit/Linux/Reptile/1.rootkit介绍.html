<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># rootkit 介绍,rootkit 介绍</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>rootkit 介绍</h1>
<h2>1.rootkit</h2>
<p>do：隐藏自身的文件、进程、网络连接、rootkit 模块本身</p>
<p>三种不同的 Linux rootkit 技术：动态链接库劫持（LD_PRELOAD）、Linux kernel module（LKM） rootkit 和 eBPF rootkit</p>
<ul>
<li>
<p>用户态：替换相关命令完成(通过替换 ps、top、ls、ss、netstat 等系统工具，截获 sys_execve()，无论何时系统尝试去执行 “ls” 程序的时候, 它都会被重定向到入侵者给定的其他程序)</p>
</li>
<li>
<p>内核态：可装载内核模块（LKM）实现</p>
<p>（当某个程序需要借助网络、文件系统或其他系统特定活动进行工作时，它就必须经过内核。也就是说，在此时它将使用系统调用）</p>
<ul>
<li>hook 技术，系统调用 hook，函数 api hook</li>
<li>直接内核对象操作系统，主要通过/dev/mem、/dev/kmem 设备直接操作内存，从而对内核进行修改</li>
</ul>
</li>
</ul>
<h2>2.LKM 实现 rootkit</h2>
<p>LKM 本质上是内核代码的独立单元，可以根据需要加载或卸载，而无需重新编译或重启整个内核</p>
<p><strong>思路</strong>：将自定义的模块加载到内核</p>
<h3>2.1 基础探索</h3>
<p>用户空间探索内核模块：</p>
<ul>
<li>insmod 安装内核模块</li>
<li>rmmod 卸载内核模块</li>
<li>lsmod 查看内核模块</li>
<li>modinfo 用于查询模块的相关信息 , 比如作者, 版权</li>
<li>modprobe 用于智能地向内核中加载模块或者从内核中移除模块</li>
</ul>
<p>三个相关文件和目录是：</p>
<ul>
<li><strong>/lib/modules/</strong> - 包含特定于系统上安装的不同内核版本的内核模块和相关文件。/lib/modules/ 中的每个子目录都对应于特定的内核版本，并包含相关组件。它允许操作系统将不同的内核版本及其相关模块分开，从而在需要时更轻松地在内核版本之间切换。</li>
<li><strong>/proc/modules</strong> - 此虚拟文件提供当前加载的内核模块列表。此文件中的每一行都表示一个已加载的模块，并包含有关该模块的信息，包括其名称、大小和使用计数。</li>
<li><strong>/sys/module/</strong> - 此虚拟目录提供有关当前加载的内核模块的信息。每个加载的模块在 /sys/modules/ 下都有自己的目录，在每个模块的目录中，都有包含有关模块信息的不同文件。此目录允许用户空间进程、工具和管理员在运行时访问有关已加载内核模块及其属性的信息。</li>
</ul>
<h3>2.2 hook 方法</h3>
<p>hook 内核函数的常用 <strong>方法</strong>：</p>
<ul>
<li>
<p>Syscall 表修改</p>
<p>通过对内核空间的完全控制，可以更改此表并操作处理程序指针值。攻击者可以通过保存旧的处理程序内容并将自己的处理程序添加到表中来 hook 任何系统调用</p>
<p>参考项目：Diamorphine</p>
</li>
<li>
<p>Kprobes（内核探针）</p>
<p>Kprobes 是 Linux 内核中的一项动态检测功能，允许开发人员在内核代码路径中的特定点插入自定义代码（探针），Kprobes 的工作原理是将探测处理函数附加到内核代码中的选定点。执行该特定代码路径时，将调用探测处理程序函数。通过在敏感的内核函数上放置 kprobe，攻击者可以在调用该函数时执行其代码</p>
<p>参考项目：Reptile（利用 khook）</p>
</li>
<li>
<p>Ftrace</p>
<p>Ftrace 是 Linux 内核中的内置跟踪框架，它提供了用于收集和分析有关内核行为和性能的不同类型的运行时信息的工具和基础设施。 Ftrace 允许用户跟踪特定的内核函数。攻击者可以利用此功能对内核函数的执行进行 hook 和拦截。</p>
<p>参考项目：Ftrace-hook</p>
</li>
<li>
<p>VFS（虚拟文件系统）操作</p>
<p>VFS 是类 Unix 操作系统的关键组件，它通过启用 open()、stat()、read()、write()和 chmod() 等系统调用为用户空间程序提供文件系统接口。VFS 抽象并统一了对不同文件系统的访问，允许各种文件系统实现共存。VFS 是表示通用文件模型的一系列数据结构。VFS 的四种主要对象类型是：</p>
<ul>
<li>Superblock 对象 - 表示一个特定的挂载文件系统。</li>
<li>Inode 对象 - 表示特定文件（例如常规文件、目录、FIFO 和套接字）。此对象包含 inode 操作（i_op）结构的字段。索引节点操作是操作系统中文件系统层提供的一组低级函数，用于操作文件和目录并与之交互。这包括 lookup（）、rename（）、mkdir（）、unlink（） 等（请注意，结构因内核版本而异）。</li>
<li>Dentry - 表示目录条目，路径的单个组件。</li>
<li>File 对象 - 表示与进程关联的打开文件。此对象包含文件操作（f_op）结构的字段。文件操作是定义在打开文件进行读取、写入或其他形式的访问时如何操作文件的函数。这包括 – read（）、write（）、mmap（）、fsync（） 等</li>
</ul>
<p>在用户层中，每个对象都包含指向下一个对象的指针，其节点结构如下：file 对象 -&gt; dentry 对象 -&gt; inode 对象 -&gt; superblock 对象。</p>
<p>攻击者可以 hook 到与特定文件系统关联的函数指针（如 root 和 proc），并用自己的函数指针替换它们。例如，替换 readdir 文件操作函数指针</p>
<p>利用此方法的开源 LKM rootkit 项目：adore-ng 和 suterusu</p>
</li>
</ul>
<blockquote>
<p>/kernel/load.c: init_module(): 加载到内存 : sys_init_module() (内核中的驱动加载函数)</p>
</blockquote>
<h3>2.3 kmatryoshka</h3>
<p>reptile 不是一个内核模块，而是一个用户模式应用程序。当加载程序被执行时，它会解密包含在数据段中的爬虫内核模块，然后使用 init_module()函数将其加载到内存中。此外，用于加密和解密的算法也将在解密 Magic Packet 时使用</p>
<p>加载的 Reptile 是一个内核模块，主要通过 kmatryoshka 开源工具进行打包, 负责解密以加密形式存在的原始内核模块</p>
<h3>2.4 用户层和内核层交互</h3>
<p>kernel/main.c , module.c: KHOOK_EX 内核钩子的实现 例如： 隐藏功能的实现，用户层发送 cmd.c, 把需要的变量传递给 ioctl()函数, ioctl（input/output control）是一个在 Unix/Linux 系统中广泛使用的系统调用，用于控制设备的输入输出操作。通过 ioctl 调用，程序可以读取或修改设备的特定属性。例如，程序可以通过 ioctl 获取一个硬件设备的状态，或者设置设备的参数，如波特率、数据位等。</p>
<p>通过 socket 套接字，肯定会调用 inet_ioctl()函数处理。所以在内核模块 hook 这个函数</p>
<p>hide: 内核模块本身的隐藏。当接收到“hide”命令时，当前模块将从模块列表中删除。因此，使用 lsmod 命令将不会显示当前安装的 Reptile 内核模块。</p>
<h3>2.5 khook</h3>
<p>使用 <code>khook_init(lookup)</code> 和 <code>khook_cleanup()</code> 初始化和销毁挂钩引擎</p>
<p>/engine.c:</p>
<ul>
<li>khook_init() 初始化钩子
<ul>
<li>khook_resolve()
<ul>
<li>根据 p-&gt; <a href="http://target.name">target.name</a> 调用 khook_lookup_name() 找到内核符号表地址 传给 p-&gt; target.addr</li>
</ul>
</li>
<li>khook_map()
<ul>
<li>根据 p-&gt; target.addr 调用 khook_map_writable 写入内核内存区域 并返回 addr 给 p-&gt; target.addr_map</li>
</ul>
</li>
<li>stop_machine()
<ul>
<li>khook_sm_init_hooks()
<ul>
<li>/hook.c: khook_arch_sm_init_one()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>CALLER
| ...
| CALL X -(1)---&gt; X
| ...  &lt;----.     | ...
` RET       |     ` RET -.
            `--------(2)-'
</code></pre>
<pre><code>CALLER
| ...
| CALL X -(1)---&gt; X
| ...  &lt;----.     | JUMP -(2)----&gt; khook_X_stub
` RET       |     | ???            | INCR use_count
            |     | ...  &lt;----.    | CALL handler   -(3)----&gt; khook_X
            |     | ...       |    | DECR use_count &lt;----.    | ...
            |     ` RET -.    |    ` RET -.              |    | CALL origin -(4)----&gt; khook_X_orig
            |            |    |           |              |    | ...  &lt;----.           | N bytes of X
            |            |    |           |              |    ` RET -.    |           ` JMP X + N -.
            `------------|----|-------(8)-'              '-------(7)-'    |                        |
                         |    `-------------------------------------------|--------------------(5)-'
                         `-(6)--------------------------------------------'
</code></pre>
<p>整体思路：替换掉需要钩掉的函数的前几个字节，替换成一个跳转指令，让 X 开始执行的时候跳转到框架自定义的 STUB 代码部分，STUB 再调用用户自定义的钩子函数。然后又会执行原先被跳转指令覆盖的指令，最后回到被钩掉的函数的正常执行逻辑</p>
<p>X 的第一条指令被替换成 JUMP 的跳转指令，另外，还可以知道多了 3 个部分 khook_X_stub、khook_X、khook_X_orig：</p>
<ul>
<li>khook_X_stub(存根)：框架自定义的钩子函数模板，有 4 部分，引用的维护，跳转到 HOOK.fn，一条返回</li>
<li>khook_X：这是使用者自定义的钩子函数。这里的 4 就是 KHOOK_ORIGIN，钩子替换下来的原函数地址，一般来说，自定义的钩子函数最后也会调用原函数，用来保证正常的执行流程不会出错</li>
<li>khook_X_orig：框架自定义的钩子函数模板，由于 X 的第一条指令被替换成 JUMP 的跳转指令，要正常执行 X，则需要先执行被替换的几个字节，然后回到 X，也就是图中的过程 5</li>
</ul>
<p>Hooking of generic kernel functions：</p>
<p>An example of hooking a kernel function with known prototype (function is defined in <code>linux/fs.h</code>):</p>
<pre><code>#include &lt;linux/fs.h&gt; // has inode_permission() proto
KHOOK(inode_permission);
static int khook_inode_permission(struct inode *inode, int mask)
{
        int ret = 0;
        ret = KHOOK_ORIGIN(inode_permission, inode, mask);
        printk(&quot;%s(%p, %08x) = %d\n&quot;, __func__, inode, mask, ret);
        return ret;
}
</code></pre>
<p>An example of hooking a kernel function with custom prototype (function is not defined in <code>linux/binfmts.h</code>):</p>
<pre><code>#include &lt;linux/binfmts.h&gt; // has no load_elf_binary() proto
KHOOK_EXT(int, load_elf_binary, struct linux_binprm *);
static int khook_load_elf_binary(struct linux_binprm *bprm)
{
        int ret = 0;
        ret = KHOOK_ORIGIN(load_elf_binary, bprm);
        printk(&quot;%s(%p) = %d (%s)\n&quot;, __func__, bprm, ret, bprm-&gt;filename);
        return ret;
}
</code></pre>
<h2>3.LKM 实现 rootkit 局限性</h2>
<p>LKM rootkit 存在某些限制，这些约束可以分为 <strong>权限</strong> 和 <strong>可移植性</strong></p>
<p>权限：</p>
<ul>
<li>
<p>容器：与用户模式 rootkit 不同，内核模块 rootkit 需要访问主机上的系统内核。如果满足以下任一条件，则进入容器的攻击者将能够加载内核模块：</p>
<ul>
<li>容器具有特权</li>
<li>容器具有 SYS_MODULE 能力</li>
<li>攻击者的受控线程具有 SYS_MODULE 能力</li>
</ul>
</li>
<li>
<p>虚拟机/主机：攻击者必须具有 root 权限或能够执行具有 SYS_MODULE 功能的进程</p>
</li>
</ul>
<p>可移植性：</p>
<p>内核模块必须使用与目标系统的内核版本兼容的特定内核头文件.ko 进行编译。此外，内核函数和对象因内核版本和体系结构而异。因此，对于每个唯一的内核版本，可能需要不同的模块编译</p>
<p>todo：</p>
<ul>
<li>内核版本适配</li>
<li>流量隐藏</li>
<li>文件遍历</li>
<li>内网扫描</li>
</ul>

        </main>
    </div>
</body>
</html>