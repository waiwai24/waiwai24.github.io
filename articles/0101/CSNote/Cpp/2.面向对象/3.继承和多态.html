<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 继承和多态,继承和多态</title>
    <link rel="stylesheet" href="../../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>继承和多态</h1>
<blockquote>
<p>为什么我们要使用继承？</p>
<p>使用继承是为了减少代码的冗余，增强代码的可扩展性，并且当两个类具有相同的特征（属性）和行为（方法）时，可以相同的部分抽取出来放到一个类中作为父类，其他两个类继承这个父类。</p>
</blockquote>
<p>​</p>
<p>[TOC]</p>
<h2>1.继承和派生基本概念</h2>
<h3>（1）继承</h3>
<ul>
<li>​	以现有的类为基础来构建新类</li>
<li>​	新类（<strong>派生类</strong>）（<strong>子类</strong>）继承现有类（<strong>基类</strong>）（<strong>父类</strong>）的属性和行为</li>
<li>​	派生类可以修改继承的行为</li>
<li>​	派生类可以增加新的属性和行为</li>
<li>​	派生类对象也是基类对象</li>
<li>​	派生类对象和基类对象可以被统一管理</li>
</ul>
<h3>（2）对于基类和派生类的理解</h3>
<ul>
<li>​	基类就是父类，派生类就是子类</li>
</ul>
<ul>
<li>
<p>​	你可以理解为生活中的父子关系，</p>
</li>
<li>
<p>​	也就是说儿子继承了所有的父亲的样貌特征，但是儿子也有父亲所没有的一些特点</p>
</li>
<li>
<p>​	专业点讲，就是子类可以继承并使用父类的属性和方法，也可以有自己的属性和方法！</p>
</li>
</ul>
<h3>（3）例子</h3>
<p>​	家具和柜子， 建筑和房子 ，道路和高速公路， 动物和猫 ，计算机和笔记本电脑</p>
<pre><code class="language-cpp">class Mammal {
public:
	Mammal();
	~Mammal();
	......
};
class Lion : public Mammal {
public:
	Lion();
	~Lion();
	......
}
</code></pre>
<hr>
<h2>2.继承的定义</h2>
<blockquote>
<p>在 C++ 中，当定义一个新的类 B 时，如果发现类 B 拥有某个已写好的类 A 的全部特点，此外还有类 A 没有的特点，那么就不必从头重写类 B，而是可以把类 A 作为一个“基类”（也称“父类”），把类 B 写为基类 A 的一个“派生类”（也称“子类”）。这样，就可以说从类 A “派生”出了类 B，也可以说类 B “继承”了类 A。</p>
</blockquote>
<h3>（1）继承的方式</h3>
<ul>
<li>
<p>公有继承（public）</p>
<ul>
<li>公有继承是访问性最高的一种继承，在子类中能完整延续父类成员的访问性，而且对外可见。如果要公有继承一个类，只需继承时在类名前面加上 public 关键字即可。</li>
<li>在公有继承中，==派生类成员可以访问继承的基类的 public 部分与 protected 部分，但是不能访问 private 部分==，只有基类成员以及基类的友元可以访问 private 部分。</li>
<li>基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, private</li>
</ul>
</li>
<li>
<p>受保护继承（protected）</p>
<ul>
<li>保护继承相对于公有继承，访问性有所降低，父类的<strong>公有成员</strong>在子类中变成了<strong>保护成员</strong>，也就无法在外部通过一个对象访问父类成员了，但是对于这个子类的子类仍然是可见的（因为可见性只是降到了 protected ）</li>
<li>基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, private</li>
</ul>
</li>
<li>
<p>私有继承（private）（也是类中默认的继承的方式）</p>
<ul>
<li>私有继承在保护继承的基础上更进一步，访问性进一步降低，==父类中的<strong>公有成员</strong>和<strong>保护成员</strong>的访问性均降到了<strong>私有</strong> private==，不仅对外不可见，对这个类的子类也不可见了。</li>
<li>基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, private</li>
</ul>
</li>
</ul>
<h3>（2）派生类（子类）中重定义基类的函数</h3>
<ul>
<li>派生类自动继承基类所有成员</li>
<li>若基类成员函数不满足需要，在派生类中重新定义函数</li>
<li>派生类对象可以直接访问自己定义的函数，也可以访问定义于基类被覆盖的函数</li>
<li>调用方式：==<em><strong>基类名</strong></em>   <em><strong>::</strong></em>   <em><strong>函数名</strong></em>==</li>
</ul>
<h3>（4）基类（父类）中的私有成员</h3>
<ul>
<li>能被派生类继承</li>
<li>==不能被派生类的成员函数直接访问==</li>
<li>可通过定义于基类的公有和受保护成员函数访问</li>
</ul>
<h3>（5）在 C++ 中，从一个类派生出另一个类的写法</h3>
<pre><code class="language-cpp">class  派生类名: 继承方式说明符  基类名{
   ...
};
</code></pre>
<p>继承方式说明符可以是 public（公有继承）、private（私有继承）或 protected（保护继承）。一般都使用 public。protected 或 private 方式很少用到。</p>
<pre><code class="language-cpp">class CBase
{
    int v1, v2;
};
class CDerived: public CBase
{
    int v3;
};
</code></pre>
<h3>（6）基类的构造函数和析构函数不被继承，但会被派生类的构造函数和析构函数自动调用</h3>
<ul>
<li>派生类的构造函数先调用基类的构造函数，再执行自己的函数体</li>
<li>派生类的析构函数先执行自己的函数体，再调用基类的析构函数</li>
</ul>
<h3>（7）调用方式的区别</h3>
<ul>
<li>调用基类函数：
<ul>
<li>基类名 ::  函数名</li>
</ul>
</li>
<li>调用派生类函数：
<ul>
<li>直接调用</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class CStudent
{
private:
    string name;
    string id;  //学号
    char gender;  //性别，F 代表女，M 代表男
    int age;
public:
    void PrintInfo();
    void SetInfo(const string &amp; name_, const string &amp; id_, int age_, char gender_);
    string GetName() { return name; }
};
class CUndergraduateStudent : public CStudent  //本科生类，继承了 CStudent 类
{
private:
    string department;  //学生所属的系的名称
public:
    void QulifiedForBaoyan() {  //给予保研资格
        cout &lt;&lt; &quot;qulified for baoyan&quot; &lt;&lt; endl;
    }
    void PrintInfo() {
        CStudent::PrintInfo();  //调用基类的 PrintInfo 函数
        cout &lt;&lt; &quot;Department: &quot; &lt;&lt; department &lt;&lt; endl;
    }
    void SetInfo(const string &amp; name_, const string &amp; id_, int age_,char gender_, const string &amp; department_) 
    {
        CStudent::SetInfo(name_, id_, age_, gender_);  //调用基类的 SetInfo 函数
        department = department_;
    }
};
void CStudent::PrintInfo()
{
    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; endl;
    cout &lt;&lt; &quot;ID: &quot; &lt;&lt; id &lt;&lt; endl;
    cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; endl;
    cout &lt;&lt; &quot;Gender: &quot; &lt;&lt; gender &lt;&lt; endl;
}
void CStudent::SetInfo(const string &amp;name_, const string &amp; id_, int age_, char gender_)
{
    name = name_;
    id = id_;
    age = age_;
    gender = gender_;
}
int main()
{
    CStudent s1;
    CUndergraduateStudent s2;
    s2.SetInfo(&quot;Harry Potter&quot;, &quot;118829212&quot;, 19, 'M', &quot;Computer Science&quot;);
    cout &lt;&lt; s2.GetName() &lt;&lt; &quot; &quot;;
    s2.QulifiedForBaoyan();
    s2.PrintInfo();
    cout &lt;&lt; &quot;sizeof(string) = &quot; &lt;&lt; sizeof(string) &lt;&lt; endl;
    cout &lt;&lt; &quot;sizeof(CStudent) = &quot; &lt;&lt; sizeof(CStudent) &lt;&lt; endl;
    cout &lt;&lt; &quot;sizeof(CUndergraduateStudent) = &quot; &lt;&lt; sizeof(CUndergraduateStudent) &lt;&lt; endl;
    return 0;
}
运行结果：
Harry Potter qulified for baoyan
Name: Harry Potter
ID: 118829212
Age: 19
Gender: M
Department: Computer Science
sizeof(string) = 4
sizeof(CStudent) = 16
sizeof(CUndergraduateStudent) = 20
</code></pre>
<hr>
<h2>3.继承关系中类指针的使用</h2>
<ul>
<li>类名可以用来声明变量（类的对象）、数组、指针等</li>
<li>类的指针可以操作类的对象，也可以操作派生类的对象 （派生类对象也是基类对象）</li>
<li>派生类对象和基类对象可以通过指针统一操作和管理</li>
<li>类指针操作类对象的几种可能 ：
<ul>
<li>基类指针操作基类对象(自然)</li>
<li>派生类指针操作派生类对象(自然)</li>
<li>基类指针操作派生类对象——把派生类对象作为基类对象看(安全)</li>
<li>派生类指针操作基类对象——把基类对象作为派生类对象看(危险)</li>
</ul>
</li>
</ul>
<hr>
<h2>4.构建继承关系的线性表</h2>
<h3>（1）用链表实现可变长（整型）数组</h3>
<pre><code class="language-cpp">// 文件VLArray.h: 类VLArray的定义
#pragma once
class Node {
	friend class VLArray;
private:
	int data;
	Node* next;
};
class VLArray {
public:
	VLArray();
	~VLArray();
	void set(int i, int m); //修改数组元素的值
	int getLength(); //获取数组的长度
	int get(int i); //获取数组第i个元素的值
	void del(int i); //删除数组的第i个元素
private:
	Node* head;
	int len;
};
</code></pre>
<pre><code class="language-cpp">// VLArray.cpp: 类VLArray的实现
#include &lt;stdlib.h&gt;
#include &quot;VLArray.h&quot;
VLArray::VLArray() {
	head = NULL;
	len = 0;
}
VLArray::~VLArray() {
	Node* p = head;
	while (p) {
		head = head-&gt;next;
		delete p;
		p = head;
	}
}
int VLArray::getLength() {
	return len;
}
int VLArray::get(int i) {
	if (i &gt;= 0 &amp;&amp; i &lt; len) {
		Node* p = head;
		for (int k = 0; k &lt; i; k++)
			p = p-&gt;next;
		return p-&gt;data;
	}
	return 0;
}
void VLArray::set(int i, int m) {
	if (len == 0) {
		//在空数组中插入第一个元素
		head = new Node;
		head-&gt;data = m;
		head-&gt;next = NULL;
		len++;
	}
	else if (i &gt;= 0 &amp;&amp; i &lt; len) {
		//修改数组第i个元素
		Node* p = head;
		for (int k = 0; k &lt; i; k++)
			p = p-&gt;next;
		p-&gt;data = m;
	}
	else if (i &lt; 0) { //在数组首部插入元素
		Node* p = new Node;
		p-&gt;data = m;
		p-&gt;next = head;
		head = p;
		len++;
	}
	else { //在数组尾部插入元素
		Node* q = new Node;
		q-&gt;data = m;
		q-&gt;next = NULL;
		Node* p = head;
		for (int k = 0; k &lt; len - 1; k++)
			p = p-&gt;next;
		p-&gt;next = q;
		len++;
	}
}
void VLArray::del(int i) {
	if (len == 0)
		return;
	if (i == 0) {
		Node* p = head;
		head = head-&gt;next;
		delete p;
		len--;
	}
	else if (i &gt; 0 &amp;&amp; i &lt; len) {
		Node* p = head;
		for (int k = 0; k &lt; i - 1; k++)
			p = p-&gt;next;
		Node* q = p-&gt;next;
		p-&gt;next = q-&gt;next;
		delete q;
		len--;
	}
}
</code></pre>
<pre><code class="language-cpp">// 文件ex.cpp: 使用类VLArray
#include &quot;VLArray.h&quot;
#include &lt;iostream&gt;
using namespace std;
int main() {
	int m, i;
	VLArray a;
	for (i = 0; i &lt; 10; i++) {
		cin &gt;&gt; m;
		a.set(a.getLength(), m);
	}
	for (i = 0; i &lt; a.getLength(); i++) {
		m = a.get(i);
		cout &lt;&lt; m &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
	a.del(4);
	for (i = 0; i &lt; a.getLength(); i++)
	{
		m = a.get(i);
		cout &lt;&lt; m &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
	return 0;
}
</code></pre>
<pre><code class="language-cpp">运行结果：
1 2 3 4 5 6 7 8 9 0
1 2 3 4 5 6 7 8 9 0
1 2 3 4 6 7 8 9 0
</code></pre>
<h3>（2）使用可变长数组构建栈类Stack</h3>
<ul>
<li>push(k)：将整数k压栈</li>
<li>isEmpty()：判断是否栈空</li>
<li>pop()：弹出栈顶元素并返回，栈空则返回0</li>
</ul>
<pre><code class="language-cpp">// 文件Stack.h: 类Stack的定义
#pragma once
#include &quot;..\8_2\VLArray.h&quot;
class Stack :protected
	VLArray {
public:
	Stack() {};
	~Stack() {};
	void push(int k);
	bool isEmpty();
	int pop();
};
</code></pre>
<pre><code class="language-cpp">// 文件Stack.cpp: 类Stack的实现
#include &quot;Stack.h&quot;
void Stack::push(int k) {
	set(-1, k);
}
bool Stack::isEmpty() {
	if (getLength() == 0)
		return true;
	return false;
}
int Stack::pop() {
	if (getLength() == 0)
		return 0;
	int m = get(0);
	del(0);
	return m;
}

</code></pre>
<pre><code class="language-cpp">// 文件8_3.cpp: 使用类Stack
#include &quot;Stack.h &quot;
#include &lt;iostream&gt;
using namespace std;
int main() {
	Stack s;
	int i, m;
	for (i = 0; i &lt; 10; i++) {
		cin &gt;&gt; m;
		s.push(m);
	}
	for (i = 0; i &lt; 10; i++) {
		m = s.pop();
		cout &lt;&lt; m &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
	return 0;
}
</code></pre>
<pre><code class="language-cpp">程序运行结果
1 2 3 4 5 6 7 8 9 0
0 9 8 7 6 5 4 3 2 1
</code></pre>
<hr>
<h2>5.多继承</h2>
<h3>（1）多继承的概念</h3>
<p>​			C++ 语言支持一个子类同时继承多个父类，就像单继承时一样，继承多个父类也就相当于同时有了多个父类的公有成员和保护成员，而且可以单独为每一个父类指定继承的方式。</p>
<h3>（2）优缺点</h3>
<p>​			因此多继承的优点说可以使一个类实现多个接口，而缺点使容易造成混淆。</p>
<h3>（3）声明方式</h3>
<p>​			如果要继承多个类，只需将父类的类名依次写在子类类名的冒号（<code>:</code>）后面，基类名之间用逗号（<code>,</code>）隔开，每一个基类名前面带上它的访问性关键字。即多继承声明语法如下：</p>
<pre><code class="language-cpp">class 派生类名 : 访问控制 基类名1, 访问控制 基类名2, ...
{
    成员变量和成员函数的声明
};
</code></pre>
<h3>（4）访问方式</h3>
<p>​			多继承访问基类成员大体与单继承一致，但当继承的多个父类中有同名的成员时，要访问其中一个成员就不能简单的只写成员名了，必须使用作用域运算符（<code>::</code>）来指定是哪一个类的成员。</p>
<pre><code class="language-cpp">/* 继承关系：BaseA-&gt;D，BaseB-&gt;D */
class BaseA
{
    public:
        int A;
};
class BaseB
{
    public:
        int A;     // 与 BaseA 的 A 成员同名了
};
class D : public BaseA , public BaseB     / /公有继承 BaseA 和 BaseB
{
    /* 其他成员 */
};
int main()
{
    D d;
    d.BaseA::A = 10;     // 使用作用域运算符，给来自 BaseA 类的成员 A 赋值
    d.BaseB::A = 10;     // 使用作用域运算符，给来自 BaseB 类的成员 A 赋值
}
</code></pre>
<hr>
<h2>6.多态性</h2>
<blockquote>
<p>多态性：</p>
<p>具有继承关系的类，其对象对同一个函数调用可以作出不同的响应</p>
<p>指向不同对象发送同一个消息，不同对象在接收时会产生不同的行为（方法）</p>
<p>多态在 C++ 中的实现可以是函数的重载、运算符的重载和虚函数</p>
</blockquote>
<ul>
<li>静态类型与动态类型
<ul>
<li>对象的静态类型:
<ul>
<li>对象在声明时候的类型，是在编译时期确定的</li>
</ul>
</li>
<li>对象的动态类型：
<ul>
<li>目标所指向的对象，是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</li>
</ul>
</li>
</ul>
</li>
<li>静态绑定与动态绑定
<ul>
<li>静态绑定：
<ul>
<li>绑定的是静态类型，比如函数依赖于对象的静态类型，发生在编译期</li>
<li>在编译时确定函数或方法的调用方式。</li>
<li>适用于静态方法和非虚函数</li>
<li>编译器会根据函数或方法的名称和参数类型来确定调用方式</li>
</ul>
</li>
<li>动态绑定：
<ul>
<li>绑定的是动态类型，比如函数依赖于对象的动态类型，发生在运行期</li>
<li>在运行时确定函数或方法的调用方式。</li>
<li>适用于虚函数和多态。</li>
<li>根据对象的类型来确定调用哪个函数或方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//基类People
class People{
public:
    People(char *name, int age);
    void display();
protected:
    char *m_name;
    int m_age;
};
People::People(char *name, int age): m_name(name), m_age(age){}
void People::display(){
    cout&lt;&lt;m_name&lt;&lt;&quot;今年&quot;&lt;&lt;m_age&lt;&lt;&quot;岁了，是个无业游民。&quot;&lt;&lt;endl;
}

//派生类Teacher
class Teacher: public People{
public:
    Teacher(char *name, int age, int salary);
    void display();
private:
    int m_salary;
};
Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary){}
void Teacher::display(){
    cout&lt;&lt;m_name&lt;&lt;&quot;今年&quot;&lt;&lt;m_age&lt;&lt;&quot;岁了，是一名教师，每月有&quot;&lt;&lt;m_salary&lt;&lt;&quot;元的收入。&quot;&lt;&lt;endl;
}

int main(){
    People *p = new People(&quot;王志刚&quot;, 23);
    p -&gt; display();

    p = new Teacher(&quot;赵宏佳&quot;, 45, 8200);
    p -&gt; display();

    return 0;
}
</code></pre>
<pre><code class="language-cpp">运行结果：
王志刚今年23岁了，是个无业游民。
赵宏佳今年45岁了，是个无业游民。
</code></pre>
<p>我们直观上认为，如果指针指向了派生类对象，那么就应该使用派生类的成员变量和成员函数，这符合人们的思维习惯。但是本例的运行结果却告诉我们，当基类指针 p 指向派生类 Teacher 的对象时，虽然使用了 Teacher 的成员变量，但是却没有使用它的成员函数，导致输出结果不伦不类（赵宏佳本来是一名老师，输出结果却显示人家是个无业游民），不符合我们的预期。</p>
<p>换句话说，==通过基类指针只能访问派生类的<strong>成员变量</strong>，但是不能访问派生类的<strong>成员函数</strong>==</p>
<hr>
<h2>7.虚函数</h2>
<blockquote>
<p>虚函数是一种动态的重载方式。虚函数的作用是允许在派生类中重新定义与基类同名的函数，并可以通过基类指针或引用来访问基类和派生类中同名函数</p>
<p>为了上面代码的这种尴尬，让基类指针能够访问派生类的成员函数，<a href="http://c.biancheng.net/cplus/">C++</a> 增加了<strong>虚函数（Virtual Function）</strong>。使用虚函数非常简单，只需要在函数声明前面增加 virtual 关键字。</p>
</blockquote>
<ul>
<li>
<p>虚函数的定义：</p>
<ul>
<li>函数原型前加上关键字**==virtual==**</li>
<li>如果一个函数在基类中被声明为虚函数，则他在所有派生类中都是虚函数（包括重定义函数） virtual void show();</li>
</ul>
</li>
<li>
<p>只有通过基类指针或引用调用虚函数才能引发动态绑定</p>
</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//基类People
class People{
public:
    People(char *name, int age);
    virtual void display();  //声明为虚函数
protected:
    char *m_name;
    int m_age;
};
People::People(char *name, int age): m_name(name), m_age(age){}
void People::display(){
    cout&lt;&lt;m_name&lt;&lt;&quot;今年&quot;&lt;&lt;m_age&lt;&lt;&quot;岁了，是个无业游民。&quot;&lt;&lt;endl;
}

//派生类Teacher
class Teacher: public People{
public:
    Teacher(char *name, int age, int salary);
    virtual void display();  //声明为虚函数
private:
    int m_salary;
};
Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary){}
void Teacher::display(){
    cout&lt;&lt;m_name&lt;&lt;&quot;今年&quot;&lt;&lt;m_age&lt;&lt;&quot;岁了，是一名教师，每月有&quot;&lt;&lt;m_salary&lt;&lt;&quot;元的收入。&quot;&lt;&lt;endl;
}

int main(){
    People *p = new People(&quot;王志刚&quot;, 23);
    p -&gt; display();

    p = new Teacher(&quot;赵宏佳&quot;, 45, 8200);
    p -&gt; display();

    return 0;
}
</code></pre>
<pre><code class="language-cpp">运行结果：
王志刚今年23岁了，是个无业游民。
赵宏佳今年45岁了，是一名教师，每月有8200元的收入。
</code></pre>
<p>有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为<strong>多态（Polymorphism）</strong>。</p>
<hr>
<h2>8.纯虚函数和抽象基类</h2>
<h3>（1）纯虚函数</h3>
<p>有时在类中将某一成员声明为虚函数，并不是因为基类本身的要求，而是因为派生类的需求，在基类中预留一个函数名，具体功能留给派生类区定义。这种情况下就可以将这个纯虚函数声明为纯虚函数。即纯虚函数的作用是在基类中为其派生类保留一个函数的名字，以便派生类对它进行定义。</p>
<p>纯虚函数就是在声明虚函数时被初始化为0的函数，但它只有名字，不具备函数功能，不能被调用，其一般形式是：</p>
<pre><code class="language-cpp">virtual 函数类型 函数名（参数列表） = 0
</code></pre>
<p>纯虚函数没有函数体。最后的“=0”只是一种形式，告诉编译系统，它是一个纯虚函数，留在派生类中定义，并没有实际意义。</p>
<p>纯虚函数只有在派生类中定义了之后才能被调用。如果在一个类中声明了纯虚函数，而在派生类中没有对该函数定义，则该虚函数在派生类中仍然为纯虚函数。</p>
<h3>（2）抽象基类</h3>
<p>含有纯虚函数的类就成为抽象类。抽象类只是一种基本的数据类型，用户需要在这个基础上根据自己的需要定义处各种功能的派生类。</p>
<p>抽象类的作用就是为一个类族提供一个公共接口。抽象类不能定义对象，但是可以定义指向抽象类的指针变量，通过这个指针变量可以实现多态。</p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../../assets/js/header.js"></script>
    <script src="../../../../assets/js/include-header.js"></script>
</body>
</html>