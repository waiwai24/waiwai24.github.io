<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 与命令有关的操作符,与命令有关的操作符</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>与命令有关的操作符</h1>
<h2>1.多命令执行符</h2>
<ol>
<li><code>;</code> 顺序执行多条命令，不管命令是否执行成功</li>
<li><code>&amp;&amp; </code> 逻辑与，如果前面的命令执行错误则不执行后面的命令</li>
<li><code>||</code> 逻辑或，顺序执行多条命令，碰到执行正确的命令后则不执行后面的命令, 即当左侧指令报错时，右侧指令才会执行</li>
</ol>
<h2>2.管道符</h2>
<p>管道符 <code>|</code> 将前一个命令的输出作为后一个命令的操作对象</p>
<h2>3.重定向符</h2>
<blockquote>
<p>标准输入（stdin）、标准输出（stdout）和标准错误（stderr）</p>
<p>这三个默认流具有以下文件描述符编号 File Descriptor (FD)：stdin = 0、stdout = 1 和 stderr = 2</p>
</blockquote>
<p><img src="/0101/CSNote/命令行/assets/%E6%93%8D%E4%BD%9C%E7%AC%A6/pipe11-640x129.png" alt="pipe11-640x129"></p>
<ol>
<li><code>&gt;</code> 输出重定向</li>
<li><code>&gt;&gt;</code> 追加重定向</li>
<li><code>&lt;</code> 输入重定向</li>
<li><code>2&gt;&amp;1 </code> 让 2 重定向到 1，也就是让 <code>stderr</code> 标准错误重定向到 <code>stdout</code> 标准输出，然后两个并在一起再重定向</li>
</ol>
<p><code>tee</code> 命令：从标准输入读取数据并重定向到标准输出和文件</p>
<pre><code>tee [OPTION]... [FILE]...
    -a：追加到文件而不是覆盖。使用该选项，可以将输出内容追加到指定文件的末尾。
    -i：交互式地提示覆盖已存在文件。当指定的输出文件已存在时，使用该选项会询问用户是否覆盖文件。
    -p：保持管道的性能，不输出到终端。在某些情况下，使用该选项可以提高性能。

echo &quot;Hello, Linux!&quot; | tee output.txt
</code></pre>
<p>注意：<code>&gt;</code> 和 <code>&gt;&gt;</code> 如果文件不存在，会自动创建新文件，而不需要提前 touch，且他会覆盖文件原本的内容</p>
<pre><code>hacker@dojo:~$ echo hi &gt; asdf
hacker@dojo:~$ echo hi 1&gt; asdf
上面两者等价

hacker@dojo:~$ /challenge/run 2&gt; errors.log
重定向错误

hacker@dojo:~$ some_command &gt; output.log 2&gt; errors.log
将输出重定向到output.log，错误重定向到errors.log
</code></pre>
<h2>4.通配符</h2>
<ol>
<li><code>*</code> 用于匹配 0 个或多个字符</li>
<li><code>?</code> 匹配一个任意字符</li>
<li><code>[]</code> 匹配括号中任意一个字符</li>
<li><code>[^]，[!]</code> 逻辑非，中的第一个字符是^或！，匹配不是括号中的字符</li>
<li><code>[0-9]</code> 匹配 0-9 之间的单个数字字符，<code>[^0-9]</code> 匹配一个不是数字的字符</li>
<li><code>[abc]</code> 匹配 a, b, c 三个字符中的任意一个字符</li>
</ol>
<h2>5.转义符</h2>
<ol>
<li>
<p><code>\</code> 反斜杠转义符，去除紧跟其后的元字符的特殊意义</p>
</li>
<li>
<p><code>''</code> 单引号，强引用，转义其中的所有变量为单纯的字符串</p>
</li>
<li>
<p><code>&quot;&quot;</code> 双引号，弱引用，只保留 $ 、 ` 和 \ 三种元字符的特殊含义</p>
</li>
</ol>
<h2>7.其他</h2>
<ol>
<li>
<p><code>$</code> 标识变量，用 <code>=</code> 写入变量（写入变量的时候不用带$,$只用于访问），等号周围不能有空格</p>
</li>
<li>
<p><code>$</code> 表示当前程序的进程 ID 号</p>
</li>
<li>
<p><code>!</code> 非操作符</p>
</li>
<li>
<p><code>#</code> 注释</p>
</li>
<li>
<p><code>read</code> 命令：从键盘读取变量的值，通常用在 shell 脚本中与用户进行交互的场合</p>
<pre><code class="language-shell">-p：指定读取值时的提示符；
-t：指定读取值时等待的时间（秒）
</code></pre>
</li>
<li>
<p><code>#</code> 注释符</p>
</li>
<li>
<p>输入命令时在后边加入 <code>&amp;</code> 符号会把命令程序直接放到后台执行，此时可以用 jobs 命令查看后台执行程序的列表, 等同于 ctrl+z</p>
</li>
<li>
<p>通过将一条命令封装在 ` 中，可以将它嵌入另一条命令;</p>
</li>
<li>
<p>命令替换还有另外一种格式，即将命令放入 <code>$()</code> 中</p>
</li>
</ol>

        </main>
    </div>
</body>
</html>