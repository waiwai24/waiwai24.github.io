<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 列表,列表</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>列表</h1>
<blockquote>
<p>数组长度不可变导致实用性降低，在实际中，我们可能无法确定需要存储多少数据，这会使数组长度的选择变得困难</p>
<p>为解决此问题，出现了一种被称为动态数组dynamic array的数据结构，即长度可变的数组，也常被比成为列表list</p>
<p>列表基于数组实现，继承了数组的优点，并且可以在程序运行过程中动态扩容，我们可以在列表中自由地添加元素，而无需担心超过容量限制</p>
</blockquote>
<h2>1.列表常用操作</h2>
<h3>（1）初始化列表</h3>
<pre><code class="language-cpp">// 需注意，C++ 中 vector 即是本文描述的 nums
// 无初始值
vector&lt;int&gt; nums1;
// 有初始值
vector&lt;int&gt; nums = { 1, 3, 2, 5, 4 };
</code></pre>
<pre><code class="language-py"># 无初始值
nums1: nums[int] = []
# 有初始值
nums: nums[int] = [1, 3, 2, 5, 4]
</code></pre>
<p>Python中变量名后加冒号“:”以及函数后面的箭头“-＞”含义</p>
<p>这两种都是Python 中的<strong>类型注解</strong></p>
<h4>（a）变量名后加冒号“:”</h4>
<pre><code class="language-py">var: type = value
</code></pre>
<p>这是 Python 3.5 中引入的 Type Annotation，是一种注解，用来提示变量的类型。其中</p>
<ul>
<li>var 为要定义的变量；</li>
<li>type 为该变量期待的类型；</li>
<li>value 为赋给该变量的值。</li>
</ul>
<p>这种用法本质上和 var = value 相同，只是加上了 var 的类型说明。
此外，类型注解也经常用在函数参数中，可以向函数的调用者提示参数类型</p>
<pre><code class="language-py">def func(arg: int)
</code></pre>
<p>那么调用者调用函数 <code>func</code> 时就知道参数 <code>arg</code> 应该是一个 <code>int</code> 类型。</p>
<p>需要注意的是，类型注解只是一种提示，并非强制的，Python 解释器不会去校验 <code>value</code> 的类型是否真的是 <code>type</code>，它只是在提示调用者该参数的类型。例如：</p>
<pre><code class="language-py">a: str = 10
</code></pre>
<p>这样是没有错的，python 解释器在执行时会把 <code>a</code> 当作 <code>int</code> 来操作。</p>
<h4>（b）函数后面的箭头“-＞”</h4>
<p>“-&gt;”为函数标注，通常用于类型提示，是python3中引入的用法。</p>
<p>例如以下函数接受Tensor、str类型的参数，并返回一个 int 类型的值:</p>
<pre><code class="language-py">def myfunc(a: Tensor, b: str) -&gt; int :
	# 函数体
	return 返回值
</code></pre>
<h3>（2）访问元素</h3>
<p>列表的本质是数组，因此可以在O(1)时间内访问和更新元素，效率很高</p>
<h3>（3）插入和删除元素</h3>
<p>在列表尾部添加元素的时间复杂度为 O(1) （不一定,某些情况下列表正好需要先扩容再添加，这时候时间复杂度就会是O(N))，但插入和删除元素的效率仍与数组相同，时间复杂度为 O(n)</p>
<pre><code class="language-cpp">/* 清空列表 */
nums.clear();

/* 尾部添加元素 */
nums.push_back(1);
nums.push_back(3);
nums.push_back(2);
nums.push_back(5);
nums.push_back(4);

/* 中间插入元素 */
nums.insert(nums.begin() + 3, 6);  // 在索引 3 处插入数字 6

/* 删除元素 */
nums.erase(nums.begin() + 3);      // 删除索引 3 处的元素
</code></pre>
<pre><code class="language-py"># 清空列表
nums.clear()

# 尾部添加元素
nums.append(1)
nums.append(3)
nums.append(2)
nums.append(5)
nums.append(4)

# 中间插入元素
nums.insert(3, 6)  # 在索引 3 处插入数字 6

# 删除元素
nums.pop(3)        # 删除索引 3 处的元素

</code></pre>
<h3>（4）遍历列表</h3>
<pre><code class="language-cpp">/* 通过索引遍历列表 */
int count = 0;
for (int i = 0; i &lt; nums.size(); i++) {
    count++;
}

/* 直接遍历列表元素 */
count = 0;
for (int num : nums) {
    count++;
}
</code></pre>
<pre><code class="language-py"># 通过索引遍历列表
count = 0
for i in range(len(nums)):
    count += 1

# 直接遍历列表元素
count = 0
for num in nums:
    count += 1
</code></pre>
<h3>（5）拼接列表</h3>
<pre><code class="language-cpp">vector&lt;int&gt; nums1 = { 6, 8, 7, 10, 9 };
// 将列表 nums1 拼接到 nums 之后
nums.insert(nums.end(), nums1.begin(), nums1.end());
</code></pre>
<pre><code class="language-py">nums1: nums[int] = [6, 8, 7, 10, 9]
nums += nums1  # 将列表 nums1 拼接到 nums 之后
</code></pre>
<h3>（6）排序列表</h3>
<pre><code class="language-cpp">sort(nums.begin(), nums.end());  // 排序后，列表元素从小到大排列
</code></pre>
<pre><code class="language-py">nums.sort()  # 排序后，列表元素从小到大排列
</code></pre>
<h2>2.列表缺点</h2>
<p>列表的出现大大提升了数组的实用性，但副作用是会造成部分内存空间浪费</p>
<ul>
<li>
<p>一方面，列表都会设定一个初始长度，我们不一定需要用这么多</p>
</li>
<li>
<p>另一方面，为了防止频繁扩容，扩容一般都会乘以一个系数，比如 ×1.5 。这样一来，也会出现很多空位，我们通常不能完全填满它们</p>
</li>
</ul>

        </main>
    </div>
</body>
</html>