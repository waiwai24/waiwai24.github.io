<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 哈希冲突,哈希冲突</title>
    <link rel="stylesheet" href="../../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>哈希冲突</h1>
<blockquote>
<p>尽管我们可以每遇到哈希冲突时就进行哈希表扩容，直到冲突消失为止，虽然该方法简单粗暴有效，但是效率太低，我们可以改良哈希表数据结构，使得哈希表可以在存在哈希冲突时正常工作</p>
</blockquote>
<h2>1.链式地址</h2>
<p><img src="/0101/CSNote/Algorithm/7.Hashing/assets/2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/hash_table_chaining.png" alt="hash_table_chaining.png"></p>
<p>在原始哈希表中，每个桶仅能存储一个键值对。「链式地址 separate chaining」将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中</p>
<p>故操作方法也发生了以下变化（都是先访问链表头节点）：</p>
<ul>
<li>查询元素：输入key，通过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表对比key查找</li>
<li>添加元素</li>
<li>删除元素</li>
</ul>
<p>局限性：</p>
<ul>
<li>占用空间增大：链表包含节点指针，比数组更加耗费内存空间</li>
<li>查找效率降低：要线性遍历链表来查找对应元素</li>
</ul>
<h2>2.开放寻址</h2>
<p>开放寻址 open addressing 不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测、多次哈希等</p>
<h3>（1）线性探测</h3>
<p>线性探测采用固定步长的线性搜索来进行探测</p>
<ul>
<li>插入元素：哈希函数计算索引，若发现桶内有元素，则从冲突位置向后线性遍历，直至找到空桶，将元素插入其中</li>
<li>查找元素：若发现哈希冲突，则使用相同步长（通常为1）向后线性遍历，直到找到对应元素</li>
</ul>
<p>然而，线性探测容易产生聚集现象，导致恶性循环</p>
<h3>（2）平方探测</h3>
<p>与线性探测类似，只是发生冲突时，平方探测不是简单的跳过一个固定的步数，而是跳过探测次数的平方的步数，即1，4，9…</p>
<h3>（3）多次哈希</h3>
<p>多次哈希使用多个哈希函数进行探测</p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../../assets/js/header.js"></script>
    <script src="../../../../assets/js/include-header.js"></script>
</body>
</html>