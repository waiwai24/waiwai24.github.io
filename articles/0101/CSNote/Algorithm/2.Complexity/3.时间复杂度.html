<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 时间复杂度,时间复杂度</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>时间复杂度</h1>
<h2>1.统计时间增长趋势</h2>
<p>时间复杂度分析并不是算法的运行时间，而是==算法运行时间随数据量变大时的增长趋势，他应该是算法中各个语句执行时间之和==</p>
<ul>
<li>时间复杂度能有效评估算法效率</li>
<li>时间复杂度推算方法更简便</li>
<li>同时也存在一定的局限性</li>
</ul>
<h2>2.函数渐进上界</h2>
<blockquote>
<p>定义：若存在正实数$ c $和实数$ n0$ ，使得对于所有的$ n&gt;n0$ ，均有 $T(n)≤c⋅f(n)$ ，则可认为$ f(n) $给出了$ T(n)$ 的一个渐近上界，记为 $T(n)=O(f(n)) $</p>
</blockquote>
<p>给定一个输入大小为n的函数</p>
<pre><code class="language-cpp">void algorithm(int n) {
    int a = 1;  // +1
    a = a + 1;  // +1
    a = a * 2;  // +1
    // 循环 n 次
    for (int i = 0; i &lt; n; i++) { // +1（每轮都执行 i ++）
        cout &lt;&lt; 0 &lt;&lt; endl;    // +1
    }
}
</code></pre>
<p>算法的操作数量是一个关于输入数据大小 n 的函数，记为 T(n) ，则以上函数的的操作数量为：$T(n)=3+2n$</p>
<p>可以看出$T(n$)是一次函数，说明运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶</p>
<h2>3.推算方法</h2>
<h3>（1）统计操作数量</h3>
<ul>
<li>
<p>忽略T(n)的常数项</p>
</li>
<li>
<p>省略所有系数</p>
</li>
<li>
<p>循环嵌套使用乘法</p>
<pre><code class="language-cpp">void algorithm(int n) {
    int a = 1;  // +0（技巧 1）
    a = a + n;  // +0（技巧 1）
    // +n（技巧 2）
    for (int i = 0; i &lt; 5 * n + 1; i++) {
        cout &lt;&lt; 0 &lt;&lt; endl;
    }
    // +n*n（技巧 3）
    for (int i = 0; i &lt; 2 * n; i++) {
        for (int j = 0; j &lt; n + 1; j++) {
            cout &lt;&lt; 0 &lt;&lt; endl;
        }
    }
}
完整统计：T(n)=2n*(n+1)+(5n+1)+2=2*n**2+7n+3
偷懒统计：T(n)=n**2+n
</code></pre>
</li>
</ul>
<h3>（2）判断渐近上界</h3>
<p><strong>时间复杂度由多项式 T(n)中最高阶的项来决定</strong>。这是因为在 n 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以被忽略</p>
<h2>4.常见类型</h2>
<p><code>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶 &lt; O(n!)阶乘阶</code></p>
<p><img src="/0101/CSNote/Algorithm/2.Complexity/assets/3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/time_complexity_common_types.png" alt=""></p>
<h3>（1）常数阶</h3>
<p>操作数量与输入数据大小无关，即不随着n的变化而变化</p>
<pre><code class="language-cpp">/* 常数阶 */
int constant(int n) {
    int count = 0;
    int size = 100000;
    for (int i = 0; i &lt; size; i++)//size是固定大小
        count++;
    return count;
}
尽管操作数量 size 可能很大，但由于其与输入数据大小n无关，因此时间复杂度仍为 O(1)
</code></pre>
<h3>（2）线性阶</h3>
<p>线性阶的操作数量相对于输入数据大小 n 以线性级别增长。线性阶通常出现在单层循环中，遍历数组或列表等操作时间复杂度均为O(n),n为长度</p>
<h3>（3）平方阶</h3>
<p>平方阶通常出现在嵌套循环中</p>
<h3>（4）指数阶</h3>
<p>以典型的生物学的细胞分裂为例，常出现在递归函数（递归一分为二）中</p>
<pre><code class="language-cpp">/* 指数阶（递归实现） */
int expRecur(int n) {
    if (n == 1)
        return 1;
    return expRecur(n - 1) + expRecur(n - 1) + 1;
}
</code></pre>
<h3>（5）对数阶</h3>
<p>与指数阶相反，对数阶反映了“每轮缩减到一半”的情况</p>
<pre><code class="language-cpp">/* 对数阶（循环实现） */
int logarithmic(float n) {
    int count = 0;
    while (n &gt; 1) {
        n = n / 2;
        count++;
    }
    return count;
}
</code></pre>
<p>也常出现于递归函数中</p>
<pre><code class="language-cpp">/* 对数阶（递归实现） */
int logRecur(float n) {
    if (n &lt;= 1)
        return 0;
    return logRecur(n / 2) + 1;
}
</code></pre>
<p>对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是仅次于常数阶的理想的时间复杂度</p>
<h3>（6）线性对数阶</h3>
<p>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为O(logn)和O(n)</p>
<pre><code class="language-cpp">/* 线性对数阶 */
int linearLogRecur(float n) {
    if (n &lt;= 1)
        return 1;
    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);
    for (int i = 0; i &lt; n; i++) {
        count++;
    }
    return count;
}
</code></pre>
<h3>（7）阶乘阶</h3>
<p>对应数学的全排列问题</p>
<h2>5.针对递归方程的计算方法</h2>
<h3>（1）递归方程求解/迭代法</h3>
<ul>
<li>迭代之前还可以采取换元（常用：$n=2^k$)</li>
</ul>
<h3>（2）递归树法</h3>
<ul>
<li>
<p>将带$T(n)$的递归项进行拆分（或者是已经拆分好的，把自由项当作整个树的根）,如下例：</p>
<pre><code>T(n)=2T(0.5n)+n^2
T(n)=T(n/3 + 2n/3)+n
</code></pre>
</li>
<li>
<p>每一棵递归树所有结点的值之和都等于$T(n)$：</p>
<ul>
<li>先横向求出每层结点值之和</li>
<li>再根到叶逐层相加即得时间复杂度</li>
</ul>
</li>
</ul>
<h3>（3）特征方程法</h3>
<p>$k$阶常系数线性递归方程可定义为：</p>
<p>$\begin{cases}f(n)=a_1 f(n-1)+a_2 f(n-2)+…+a_k f(n-k)\ f(i)=b_i \end{cases}$</p>
<p>利用$x^n$代替$f(n)$,即可得到递归方程的递归方程：</p>
<p>$x^n=a_1 x^{n-1}+a_2 x^{n-2}+…+a_k x^{n-k}$</p>
<p>最后得到的通解：</p>
<p>$k$个不同的根时</p>
<p>$f(n)=c_1 q^n_1+c_2 q^n_2+…+c_k q^n_k$</p>
<p>重根：</p>
<p>$f(n)=(c_1 +c_2 n)q^n$</p>
<ul>
<li>先求出特征方程的根，得到递归方程的通解，再利用递归方程的初始条件确定同届的待定系数，从而得到递归方程的解</li>
</ul>

        </main>
    </div>
</body>
</html>