<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># Section Header Table,Section Header Table</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>Section Header Table</h1>
<h2>1.概述</h2>
<p>该结构用于定位 ELF 文件中的每个节区的具体位置，用于链接的目标文件必须拥有此结构</p>
<p>首先，ELF 头中的 <code>e_shoff</code> 项给出了从文件开头到节头表位置的字节偏移。<code>e_shnum</code> 告诉了我们节头表包含的项数；<code>e_shentsize</code> 给出了每一项的字节大小。</p>
<p>其次，节头表是一个数组，每个数组的元素的类型是 <code>ELF32_Shdr</code>或<code>ELF64_Shdr</code>，每一个元素都描述了一个节区的概要内容</p>
<h2>2.源码</h2>
<p>所有的数据都存储在ELF文件的节(sections)中。 我们通过节头表中的索引(index)来确认节(sections)。 节头表表项包含以下字段：</p>
<ul>
<li>节的名字；</li>
<li>节的类型；</li>
<li>节的属性；</li>
<li>内存地址；</li>
<li>文件中的偏移；</li>
<li>节的大小；</li>
<li>到其他节的链接；</li>
<li>各种各样的信息；</li>
<li>地址对齐；</li>
<li>这个表项的大小，如果有的话；</li>
</ul>
<pre><code class="language-c">/* Section header.  */
typedef struct
{
  Elf32_Word	sh_name;		/* Section name (string tbl index) */
  Elf32_Word	sh_type;		/* Section type */
  Elf32_Word	sh_flags;		/* Section flags */
  Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
  Elf32_Off	sh_offset;		/* Section file offset */
  Elf32_Word	sh_size;		/* Section size in bytes */
  Elf32_Word	sh_link;		/* Link to another section */
  Elf32_Word	sh_info;		/* Additional section information */
  Elf32_Word	sh_addralign;		/* Section alignment */
  Elf32_Word	sh_entsize;		/* Entry size if section holds table */
} Elf32_Shdr;
</code></pre>
<pre><code class="language-c">typedef struct
{
  Elf64_Word	sh_name;		/* Section name (string tbl index) */
  Elf64_Word	sh_type;		/* Section type */
  Elf64_Xword	sh_flags;		/* Section flags */
  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
  Elf64_Off	sh_offset;		/* Section file offset */
  Elf64_Xword	sh_size;		/* Section size in bytes */
  Elf64_Word	sh_link;		/* Link to another section */
  Elf64_Word	sh_info;		/* Additional section information */
  Elf64_Xword	sh_addralign;		/* Section alignment */
  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
} Elf64_Shdr;
</code></pre>
<h2>3.字段含义</h2>
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sh_name</td>
<td>节名称，是节区头字符串表节区中（Section Header String Table Section）的索引，因此该字段实际是一个数值。在字符串表中的具体内容是以 NULL 结尾的字符串。</td>
</tr>
<tr>
<td style="text-align:left">sh_type</td>
<td>根据节的内容和语义进行分类，具体的类型下面会介绍。</td>
</tr>
<tr>
<td style="text-align:left">sh_flags</td>
<td>每一比特代表不同的标志，描述节是否可写，可执行，需要分配内存等属性。</td>
</tr>
<tr>
<td style="text-align:left">sh_addr</td>
<td>如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。</td>
</tr>
<tr>
<td style="text-align:left">sh_offset</td>
<td>给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset 成员给出的是概念性的偏移。</td>
</tr>
<tr>
<td style="text-align:left">sh_size</td>
<td>此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size 字节。类型为 SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。</td>
</tr>
<tr>
<td style="text-align:left">sh_link</td>
<td>此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。</td>
</tr>
<tr>
<td style="text-align:left">sh_info</td>
<td>此成员给出附加信息，其解释依赖于节区类型。</td>
</tr>
<tr>
<td style="text-align:left">sh_addralign</td>
<td>某些节区的地址需要对齐。例如，如果一个节区有一个 doubleword 类型的变量，那么系统必须保证整个节区按双字对齐。也就是说，sh_addr%sh_addralign=0。目前它仅允许为 0，以及 2 的正整数幂数。 0 和 1 表示没有对齐约束。</td>
</tr>
<tr>
<td style="text-align:left">sh_entsize</td>
<td>某些节区中存在具有固定大小的表项的表，如符号表。对于这类节区，该成员给出每个表项的字节大小。反之，此成员取值为 0。</td>
</tr>
</tbody>
</table>
<p>索引为零（SHN_UNDEF）的节区头也存在，此索引标记的是未定义的节区引用。这一项的信息如下</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sh_name</td>
<td>0</td>
<td>无名称</td>
</tr>
<tr>
<td>sh_type</td>
<td>SHT_NULL</td>
<td>限制</td>
</tr>
<tr>
<td>sh_flags</td>
<td>0</td>
<td>无标志</td>
</tr>
<tr>
<td>sh_addr</td>
<td>0</td>
<td>无地址</td>
</tr>
<tr>
<td>sh_offset</td>
<td>0</td>
<td>无文件偏移</td>
</tr>
<tr>
<td>sh_size</td>
<td>0</td>
<td>无大小</td>
</tr>
<tr>
<td>sh_link</td>
<td>SHN_UNDEF</td>
<td>无链接信息</td>
</tr>
<tr>
<td>sh_info</td>
<td>0</td>
<td>无辅助信息</td>
</tr>
<tr>
<td>sh_addralign</td>
<td>0</td>
<td>无对齐要求</td>
</tr>
<tr>
<td>sh_entsize</td>
<td>0</td>
<td>无表项</td>
</tr>
</tbody>
</table>
<h3>3.1 sh_type</h3>
<p>节类型目前有下列可选范围，其中 SHT 是 <strong>Section Header Table</strong> 的简写。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHT_NULL</td>
<td>0</td>
<td>该类型节区是非活动的，这种类型的节头中的其它成员取值无意义。</td>
</tr>
<tr>
<td>SHT_PROGBITS</td>
<td>1</td>
<td>该类型节区包含程序定义的信息，它的格式和含义都由程序来决定。</td>
</tr>
<tr>
<td>SHT_SYMTAB</td>
<td>2</td>
<td>该类型节区包含一个符号表（<strong>SYMbol TABle</strong>）。目前目标文件对每种类型的节区都只 能包含一个，不过这个限制将来可能发生变化。 一般，SHT_SYMTAB 节区提供用于链接编辑（指 ld 而言） 的符号，尽管也可用来实现动态链接。</td>
</tr>
<tr>
<td>SHT_STRTAB</td>
<td>3</td>
<td>该类型节区包含字符串表（ <strong>STRing TABle</strong> ）。</td>
</tr>
<tr>
<td>SHT_RELA</td>
<td>4</td>
<td>该类型节区包含显式指定位数的重定位项（ <strong>RELocation entry with Addends</strong> ），例如，32 位目标文件中的 Elf32_Rela 类型。此外，目标文件可能拥有多个重定位节区。</td>
</tr>
<tr>
<td>SHT_HASH</td>
<td>5</td>
<td>该类型节区包含符号哈希表（ <strong>HASH table</strong> ）。</td>
</tr>
<tr>
<td>SHT_DYNAMIC</td>
<td>6</td>
<td>该类型节区包含动态链接的信息（ <strong>DYNAMIC linking</strong> ）。</td>
</tr>
<tr>
<td>SHT_NOTE</td>
<td>7</td>
<td>该类型节区包含以某种方式标记文件的信息（<strong>NOTE</strong>）。</td>
</tr>
<tr>
<td>SHT_NOBITS</td>
<td>8</td>
<td>该类型节区不占用文件的空间，其它方面和 SHT_PROGBITS 相似。尽管该类型节区不包含任何字节，其对应的节头成员 sh_offset 中还是会包含概念性的文件偏移。</td>
</tr>
<tr>
<td>SHT_REL</td>
<td>9</td>
<td>该类型节区包含重定位表项（<strong>RELocation entry without Addends</strong>），不过并没有指定位数。例如，32 位目标文件中的 Elf32_rel 类型。目标文件中可以拥有多个重定位节区。</td>
</tr>
<tr>
<td>SHT_SHLIB</td>
<td>10</td>
<td>该类型此节区被保留，不过其语义尚未被定义。</td>
</tr>
<tr>
<td>SHT_DYNSYM</td>
<td>11</td>
<td>作为一个完整的符号表，它可能包含很多对动态链接而言不必 要的符号。因此，目标文件也可以包含一个 SHT_DYNSYM 节区，其中保存动态链接符号的一个最小集合，以节省空间。</td>
</tr>
<tr>
<td>SHT_LOPROC</td>
<td>0X70000000</td>
<td>此值指定保留给处理器专用语义的下界（ <strong>LOw PROCessor-specific semantics</strong> ）。</td>
</tr>
<tr>
<td>SHT_HIPROC</td>
<td>OX7FFFFFFF</td>
<td>此值指定保留给处理器专用语义的上界（ <strong>HIgh PROCessor-specific semantics</strong> ）。</td>
</tr>
<tr>
<td>SHT_LOUSER</td>
<td>0X80000000</td>
<td>此值指定保留给应用程序的索引下界。</td>
</tr>
<tr>
<td>SHT_HIUSER</td>
<td>0X8FFFFFFF</td>
<td>此值指定保留给应用程序的索引上界。</td>
</tr>
</tbody>
</table>
<h3>3.2 sh_flags</h3>
<p>节头中 <code>sh_flags</code> 字段的每一个比特位都可以给出其相应的标记信息，其定义了对应的节区的内容是否可以被修改、被执行等信息。如果一个标志位被设置，则该位取值为 1，未定义的位都为 0。目前已定义值如下，其他值保留。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHF_WRITE</td>
<td>0x1</td>
<td>这种节包含了进程运行过程中可以被写的数据。</td>
</tr>
<tr>
<td>SHF_ALLOC</td>
<td>0x2</td>
<td>这种节在进程运行时占用内存。对于不占用目标文件的内存镜像空间的某些控制节，该属性处于关闭状态 (off)。</td>
</tr>
<tr>
<td>SHF_EXECINSTR</td>
<td>0x4</td>
<td>这种节包含可执行的机器指令（<strong>EXECutable INSTRuction</strong>）。</td>
</tr>
<tr>
<td>SHF_MASKPROC</td>
<td>0xf0000000</td>
<td>所有在这个掩码中的比特位用于特定处理器语义。</td>
</tr>
</tbody>
</table>
<h3>3.3 sh_link &amp; sh_info</h3>
<p>当节区类型的不同的时候，sh_link 和 sh_info 也会具有不同的含义。</p>
<table>
<thead>
<tr>
<th>sh_type</th>
<th>sh_link</th>
<th>sh_info</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHT_DYNAMIC</td>
<td>节区中使用的字符串表的节头索引</td>
<td>0</td>
</tr>
<tr>
<td>SHT_HASH</td>
<td>此哈希表所使用的符号表的节头索引</td>
<td>0</td>
</tr>
<tr>
<td>SHT_REL/SHT_RELA</td>
<td>与符号表相关的节头索引</td>
<td>重定位应用到的节的节头索引</td>
</tr>
<tr>
<td>SHT_SYMTAB/SHT_DYNSYM</td>
<td>操作系统特定信息，Linux 中的 ELF 文件中该项指向符号表中符号所对应的字符串节区在 Section Header Table 中的偏移。</td>
<td>操作系统特定信息</td>
</tr>
<tr>
<td>other</td>
<td><code>SHN_UNDEF</code></td>
<td>0</td>
</tr>
</tbody>
</table>

        </main>
    </div>
</body>
</html>