<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 典型序列密码,典型序列密码</title>
    <link rel="stylesheet" href="../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>典型序列密码</h1>
<h2>1.A5密码算法</h2>
<p>用于二代加密手机终端基站之间的传输的语音和数据，保护移动台和基站子系统之间的通信，目前已被攻破</p>
<p>移存器描述：</p>
<p><img src="/0101/CSNote/密码学/assets/4.%E5%85%B8%E5%9E%8B%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20240831144004534.png" alt="image-20240831144004534"></p>
<p>算法流程：</p>
<ul>
<li>
<p>初始化：</p>
<ul>
<li>规定密钥长度64bits，密钥用于三个线性反馈移位寄存器的初始填充</li>
<li>利用会话密钥k设定三个移存器的起点，即初始状态</li>
<li>(帧序号参与)三个LFSR都规则动作22次，每次动作1步。在第i步动作时，三个LFSR的反馈内容都首先与帧序号的第比特模2加，并将模2加的结果作为LFSR反馈的内容；帧序号比特的序号是从最低位编到最高位</li>
<li>帧序号参与方式：与密钥参与方式相同，不同的明文数据帧按顺序编号，每个编号为22比特</li>
</ul>
</li>
<li>
<p>乱数生成与加解密：</p>
<p><img src="/0101/CSNote/密码学/assets/4.%E5%85%B8%E5%9E%8B%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20240831150751060.png" alt="image-20240831150751060"></p>
<ul>
<li>LFSR的动作采用钟控方式，钟控信号x1 x2 x3的采取：x1取自LFSR-1第9级；x2取自LFSR-2第11级； x3取自LFSR-3第11级。控制方式：择多原则</li>
<li>三个LFSR以钟控方式连续动作100次，但不输出乱数</li>
<li>三个LFSR以钟控方式连续动作114次，在每次动作后，三个LFSR都将最高级寄存器中的值输出，这三个比特的模2和就是当前时刻输出的1比特乱数，</li>
<li>连续动作114步，共输出114比特乱数，用于对用户手机到基站传送的114比特数据的加密</li>
<li>解密与加密流程一样</li>
</ul>
</li>
</ul>
<h2>2.RC4密码算法</h2>
<p>RC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ron Rivest在1987年设计的密钥长度可变的流加密算法簇，属于对称加密。RC4已经成为一些常用的协议和标准的一部分，如1997年的WEP和2003/2004年无线卡的WPA; 和1995年的SSL，以及后来1999年的TLS。让它如此广泛分布和使用的主要因素是它不可思议的简单和速度，不管是软件还是硬件，实现起来都十分容易</p>
<ul>
<li>
<p>状态：256bytes=State[0,…,255]</p>
</li>
<li>
<p>密钥：40-2048bytes可变</p>
</li>
<li>
<p>算法：</p>
<ul>
<li>通过算法生成一个256字节的S-box</li>
<li>再通过算法每次取出S-box中的某一字节K</li>
<li>将K与明文做异或得到密文</li>
</ul>
</li>
<li>
<p>具体实现：</p>
<ul>
<li>
<p>初始化S，T数组</p>
<pre><code>for i = 0 to 255 do
    S[i] = i
    T[i] = K[i mod keylen]
</code></pre>
</li>
<li>
<p>置换S</p>
<pre><code>j = 0
for i = 0 to 255 do 
    j = (j + S[i] + T[i]) (mod 256) 
    swap (S[i], S[j])
</code></pre>
</li>
<li>
<p>生成流密钥，伪随机算法，取出S-box中的一位K</p>
<pre><code>i = j = 0 
for each message byte b
    i = (i + 1) (mod 256)
    j = (j + S[i]) (mod 256)
    swap(S[i], S[j])
    t = (S[i] + S[j]) (mod 256) 
    print S[t]
</code></pre>
</li>
<li>
<p>加密，将上一步取出的S[t]与明文当前字节做异或得到密文</p>
</li>
</ul>
</li>
<li>
<p>应用：认证（共享密钥）+加密（共享密钥），不安全，已被弃用</p>
</li>
</ul>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../assets/js/header.js"></script>
    <script src="../../../assets/js/include-header.js"></script>
</body>
</html>