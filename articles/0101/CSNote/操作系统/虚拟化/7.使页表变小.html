<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 使页表变小,使页表变小</title>
    <link rel="stylesheet" href="../../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>使页表变小</h1>
<p>问题：</p>
<ul>
<li>页表太大了</li>
<li>大量的页表项是无效的</li>
</ul>
<h2>1.方案1：采用更大的页</h2>
<p>使页的大小变大，这样页表项就更少了，页表的总大小也就会随之变小</p>
<h2>2.方案2：段页式地址转换</h2>
<p>为每个段分配一个页表</p>
<p>例：4GB地址空间，4KB的页面大小</p>
<pre><code class="language-c">SN = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SN_SHIFT
VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; VPN_SHIFT
AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
</code></pre>
<p><img src="/0101/CSNote/操作系统/虚拟化/assets/7.%E4%BD%BF%E9%A1%B5%E8%A1%A8%E5%8F%98%E5%B0%8F/image-20241128202201248.png" alt="image-20241128202201248"></p>
<p>仍存在的问题：</p>
<ul>
<li>分段本质上不够灵活，假定地址空间有使用模式</li>
<li>如果有一个大而稀疏的堆，仍然导致页表的浪费</li>
<li>人可能导致外部碎片的出现</li>
</ul>
<h2>3.方案3：多级页表</h2>
<ul>
<li>以树的形式组织页表</li>
<li>引入页目录（page directory）</li>
<li>每个页目录项（PDE）描述一个二级页表</li>
</ul>
<p><img src="/0101/CSNote/操作系统/虚拟化/assets/7.%E4%BD%BF%E9%A1%B5%E8%A1%A8%E5%8F%98%E5%B0%8F/image-20241128202839969.png" alt="image-20241128202839969"></p>
<h2>4.其他方案：反向页表</h2>
<p>从物理页帧出发，反向记录。所有进程公用</p>
<h2>5.内核地址空间</h2>
<ul>
<li>内核有单独的页表（kernel/memlayout.h声明了内存布局的常量）</li>
<li>内核使用“直接映射”，在虚拟地址和物理内存都位于KERNBASE=0X80000000</li>
</ul>
<h2>6.进程地址空间</h2>
<ul>
<li>每个进程有单独的页表</li>
</ul>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../../assets/js/header.js"></script>
    <script src="../../../../assets/js/include-header.js"></script>
</body>
</html>