<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 设备管理,设备管理</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>设备管理</h1>
<h2>1.持久存储设备</h2>
<ul>
<li>内存是易失性存储器，一次简单的非正常关机就可能丢失所有数据</li>
<li>磁盘是非易失性存储器，只要数据被写入磁盘，一般就不会轻易丢失</li>
</ul>
<h2>2.IO设备</h2>
<h3>2.1 系统架构</h3>
<p><img src="/0101/CSNote/操作系统/持久性/assets/1.%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20241022144226607.png" alt=""></p>
<h3>2.2 标准设备与协议</h3>
<p>标准设备有两个主要部分：</p>
<ul>
<li>硬件接口（让系统来控制他的操作）</li>
<li>内部结构（包含设备的特定实现）</li>
</ul>
<p>OS与IO设备交互：</p>
<ul>
<li>status寄存器：记录当前设备的状态</li>
<li>command寄存器：让设备执行特定的任务</li>
<li>data寄存器：传递数据给设备，或者从设备读取数据</li>
</ul>
<pre><code class="language-c">while (STATUS =BUSY)
	;//wait until device is not busy
write data to data register
write command to command register
	Doing so starts the device and executes the command
while (STATUS =BUSY)
	;//wait until device is done with your request
</code></pre>
<h3>2.3 状态检查：轮询/中断</h3>
<ul>
<li>轮询设备（polling）：OS通过反复读取状态寄存器，直到等到设备进入就绪状态</li>
<li>中断（interrupt）：向设备发出请求，对于进程睡眠，CPU可以切换执行其他任务当设备/执行完成，抛出硬件中断唤醒进程</li>
<li>如果设备本身非常快或者短时间可能出现大量中断，则轮询更好，如果慢设备，则中断更好</li>
</ul>
<h3>2.4 数据传输与设备交互</h3>
<p>CPU参与数据传输时，存在速度瓶颈，所以使用DMA（direct memory access）</p>
<ul>
<li><strong>利用CPU来传输控制请求（给DMA controller),而不是传输数据。请求中包含请求数据在内存的位置和拷贝大小以及设备</strong></li>
<li>避免了占用大量CPU实践来进行传输，绕过了CPU使数据直接在IO和内存上进行传输</li>
</ul>
<p>访问设备寄存器的具体方法：</p>
<ul>
<li>
<p>端口映射IO</p>
<ul>
<li>利用明确的I/O指令（通常使特权指令）</li>
<li>调用者指定一个存入数据的特定寄存器及一个代表设备的特定端口</li>
</ul>
</li>
<li>
<p>内存映射IO</p>
<ul>
<li>硬件将设备寄存器作为内存地址提供</li>
<li>OS使用load或者store到该内存地址，硬件会将其转移到设备，而不是物理内存</li>
</ul>
</li>
</ul>
<h3>2.5 设备驱动程序</h3>
<blockquote>
<p>Linux内核代码中超过70%的代码是各种驱动程序,驱动程序代码缺陷是内核崩溃的主要来源之一</p>
</blockquote>
<p>驱动程序的常见协议:</p>
<ul>
<li>等待驱动就绪（读取状态寄存器）</li>
<li>向命令块寄存器写入参数
<ul>
<li>扇区数</li>
<li>待访问扇区对应的逻辑块地址(Logical Block Address,LBA)</li>
<li>驱动编号</li>
</ul>
</li>
<li>开启IO
<ul>
<li>发送读写命令到命令寄存器</li>
<li>对于写命令，进行数据传输</li>
</ul>
</li>
<li>中断处理</li>
<li>错误处理：每次操作后读取状态寄存器，如果ERROR置位，则读取错误寄存器</li>
</ul>
<h2>3.磁盘驱动器</h2>
<h3>3.1 基本构成</h3>
<ul>
<li>盘片：有两个表面，表面有磁性层，数据通过改变磁性图案持久存储</li>
<li>磁道：扇区的同心圆</li>
<li>磁头：通过磁头进行读写</li>
</ul>
<h3>3.2 IO时间</h3>
<p>T~IO~ = T~寻道~ + T~旋转~ +T~传输~</p>
<ul>
<li>寻道时最耗时的磁盘操作之一，要经历加速-&gt;惯性滑动-&gt;减速-&gt;在正确磁道停止</li>
<li>平均旋转延迟 = 转一圈用时/2</li>
</ul>
<p>$R_{\mathrm{IO}}=\frac{\text{大小}<em>\text{传输}}{T</em>{\mathrm{IO}}}$</p>
<h2>4.磁盘调度算法</h2>
<p>针对磁盘上内外圈的扇区</p>
<h3>4.1 FCFS</h3>
<p>（first come first served）</p>
<ul>
<li>优势：易于实现，公平</li>
<li>劣势：无法利用请求的局部性，增加平均延迟，降低吞吐量</li>
<li><img src="/0101/CSNote/操作系统/持久性/assets/1.%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20241022160515746.png" alt="image-20241022160515746"></li>
</ul>
<h3>4.2 SSTF</h3>
<p>（shortest seek time first）</p>
<ul>
<li>按照IO请求队列，选择当前最近磁道上的请求先完成</li>
<li>优势：利用了请求的局部性，降低了平均延迟，增加了吞吐量</li>
<li>劣势：可能出现饥饿</li>
<li>未考虑公平性</li>
<li><img src="/0101/CSNote/操作系统/持久性/assets/1.%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20241022160504058.png" alt="image-20241022160504058"></li>
</ul>
<h3>4.3 SCAN</h3>
<ul>
<li>又称Elevator</li>
<li>扫描磁盘，以跨越磁道的顺序服务磁盘请求</li>
<li>下一次寻道必须是相同方向</li>
<li>优势：
<ul>
<li>利用了请求的局部性</li>
<li>保证了等待时间是有限的</li>
</ul>
</li>
<li>劣势：中间的柱面会被更好的服务，外圈等待时间较长</li>
<li><img src="/0101/CSNote/操作系统/持久性/assets/1.%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20241022160440212.png" alt="image-20241022160440212"></li>
</ul>
<h3>4.4 CSCAN</h3>
<ul>
<li>
<p>只在一个方向“扫描”磁盘并且服务请求，到达一端后会跳回到另一端重新开始“扫描”</p>
</li>
<li>
<p>优势：</p>
<ul>
<li>提供了稳定的等待时间</li>
<li>相较于SCAN，提供了更好的响应时间</li>
</ul>
</li>
<li>
<p>劣势：相较于SCAN，平均寻道时间更长</p>
</li>
<li>
<p><img src="/0101/CSNote/操作系统/持久性/assets/1.%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20241022160350160.png" alt="image-20241022160350160"></p>
</li>
</ul>
<h3>4.5 CLOOK（CSCAN变体）</h3>
<ul>
<li>不会到达边界</li>
<li><img src="/0101/CSNote/操作系统/持久性/assets/1.%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20241022160400226.png" alt="image-20241022160400226"></li>
</ul>

        </main>
    </div>
</body>
</html>