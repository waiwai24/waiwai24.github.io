<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 条件变量,条件变量</title>
    <link rel="stylesheet" href="../../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>条件变量</h1>
<h2>1.低效的实现</h2>
<p>多线程程序中，我们经常希望一个线程等待某些条件</p>
<p>简单的方案是自旋直到条件满足，这是极其低效的，某些情况下甚至是错误的</p>
<h2>2.定义</h2>
<p>线程可以使用条件变量（condition variable），来等待一个条件变成真。条件变量是一个显式队列，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等待（waiting）该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行</p>
<ul>
<li>是一个显示队列，根据某些特定条件(condition)决定线程行为</li>
<li>等待条件：当条件不满足时，线程加入队列（休眠）</li>
<li>发出信号：对于其他线程，当改变状态（使条件满足时），可以在队列中唤醒线程</li>
<li>条件变量可以处理线程的等待和唤醒</li>
<li>在条件变量上等待的线程，会在休眠前解锁，被唤醒后立刻加锁</li>
<li>通过条件变量可以实现事件类型，描述事件发生与否</li>
</ul>
<p>声明：</p>
<pre><code class="language-c">pthread_cond_t c;
</code></pre>
<p>条件变量有两种相关操作：wait()和 signal()</p>
<ul>
<li>线程要睡眠的时候，调用 wait()，同时会释放锁</li>
<li>当线程想唤醒等待在某个条件变量上的睡眠线程时，调用 signal()</li>
<li>调用 signal 和 wait 时要持有锁</li>
</ul>
<h2>3.生产者消费者问题</h2>
<p>假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费</p>
<p>例如 grep foo file.txt | wc -l</p>
<p>这个例子并发执行了两个进程，grep 进程从 file.txt 中查找包括“foo”的行，写到标准输出；UNIX shell 把输出重定向到管道（通过 pipe 系统调用创建）。管道的另一端是 wc 进程的标准输入，wc 统计完行数后打印出结果。因此，grep 进程是生产者，wc 是进程是消费者，它们之间是内核中的有界缓冲区</p>
<ul>
<li>简单实现：在检查缓冲区时使用的是if，如果缓冲区不满足消费者（生产者）的条件，调用生产者（消费者），但是当存在许多消费者的时候，就有可能在customer1消费时，buf为0，回到producer，然后生产完后customer2消费了buf，回到customer1，消费就会出出现错误</li>
<li>改进：一个简单规则，在使用条件变量时记得用while，这样会再检查一遍buf</li>
<li>加强：当存在多个生产者和多个消费者的时候，消费者不应该唤醒消费者，而应该只唤醒生产者；生产者不能唤醒其他产者，而应该只唤醒消费者。解决：生产者在empty队列中等待，发送信号唤醒fill中线程(消费者相反)</li>
</ul>
<h2>4.覆盖条件</h2>
<p>不该被唤醒的线程会在检查条件后继续休眠代价：唤醒太多线程，引入开销</p>
<p>实例：分配内存的问题</p>
<p>thread1要allocate(100)，thread2要allocate(10)，此时thread3 free(50)，当他发信号唤醒等待线程时，可能不会唤醒thread2，而thread1又由于内存不够，会继续等待。因为不知道唤醒哪些线程，所以没法工作了。</p>
<p>可以通过一个广播信号唤醒所有的等待线程，但是这样就会严重的影响性能，因为不必要地唤醒了其他许多等待的线程，它们本来（还）不应该被唤醒。这些线程被唤醒后，重新检查条件，马上再次睡眠</p>
<p>这种条件变量叫作覆盖条件（covering condition），因为它能覆盖所有需要唤醒线程的场景（保守策略）</p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../../assets/js/header.js"></script>
    <script src="../../../../assets/js/include-header.js"></script>
</body>
</html>