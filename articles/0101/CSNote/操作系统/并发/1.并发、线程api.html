<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 并发、线程api,并发、线程api</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>并发、线程api</h1>
<h2>1.并发基本概念</h2>
<p><img src="/0101/CSNote/操作系统/并发/assets/1.%E5%B9%B6%E5%8F%91%E3%80%81%E7%BA%BF%E7%A8%8Bapi/image-20240926143724490.png" alt="image-20240926143724490"></p>
<ul>
<li>多个计算任务在同一个<strong>时间段</strong>内发生（交替执行）</li>
<li>编写多线程程序在单CPU上运行的目的是：使IO部件与CPU并行运行，系统使用时间片轮转调度算法，将CPU的时间片分配给不同的线程，使它们在不同的时间段内执行。当一个线程需要等待IO操作完成时，操作系统会将CPU的时间片分配给其他线程，从而避免CPU的浪费。这样，多个线程可以在单CPU上共享CPU资源，达到并行执行的效果</li>
<li>线程（thread）：进程的最小执行单元（OS调度的基本单元）</li>
<li>不同进程有独立的内存地址空间，通信共享复杂，同一进程不同线程共享同一地址空间（全局变量共享）</li>
<li>临界段/区：访问共享变量（临界资源）的程序段，访问相同临界区的代码应该互斥执行（数据竞争：多线程同时进入临界区）</li>
<li>竞争条件：多个线程同时进入临界区，也称数据竞争</li>
<li>利用锁lock来保证临界区的原子性</li>
</ul>
<h2>2.线程</h2>
<ul>
<li>linux在进程中实现了线程————轻量级进程（light weight process，LWP），LWP与进程一起参与调度，在LWP基础上实现了线程库pthread</li>
</ul>
<pre><code class="language-c">int pthread_create(pthread_t *thread,
                   const pthread_attr_t *attr,
                   void *(*start_routine) (void *),
                   void *arg);
</code></pre>
<ul>
<li>创建线程</li>
<li>参数：
<ul>
<li>thread：线程结构体指针</li>
<li>attr：属性，如调度优先级，栈大小</li>
<li>start_routine：线程运行的主函数</li>
<li>arg：主函数要用到的参数</li>
</ul>
</li>
</ul>
<pre><code class="language-c">int pthread_join(pthread_t thread, void ** retval);
</code></pre>
<ul>
<li>等待进程结束</li>
<li>参数：
<ul>
<li>thread：线程结构体对象</li>
<li>retval：返回值指针，可通过类型转换变成其他类型</li>
</ul>
</li>
</ul>
<p>注意：函数的局部变量在函数返回时被释放，之后不能再使用</p>
<h2>3.锁</h2>
<p>互斥锁指代相互排斥，它是最基本的同步方式。互斥锁用于保护临界区，以保证任何时刻只有一个线程在执行其中的代码（假设互斥锁由多个线程共享），或者任何时刻只有一个进程在执行其中的代码</p>
<pre><code>pthread_mutex_lock(&amp;lock); //加锁，若锁被占用，则等待
pthread_mutex_unlock(&amp;lock); //解锁，只有已获得锁的线程才能解锁
int_pthread_mutex_trylock(pthread_mutex_t *mutex); //加锁，若已被锁住，则立即返回
int pthread_mutex_timelock(pthread_mutex_t *mutex,struct timespec *abs timeout); //若超时，则放弃、返回
</code></pre>

        </main>
    </div>
</body>
</html>