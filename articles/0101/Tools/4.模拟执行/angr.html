<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># angr,angr</title>
    <link rel="stylesheet" href="../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>angr</h1>
<blockquote>
<p><a href="https://github.com/angr/angr">angr</a> 是一个使用 Python 编写的跨平台开源二进制混合执行引擎，实现了程序插桩、符号执行等二进制分析技术</p>
<p>程序插桩是在在不改变程序原有逻辑的前提下，向程序代码中添加额外的代码片段，这些额外的代码的主要目的是收集程序运行时的详细信息，以便于分析、测试、调试或性能监控，辅助分析代码覆盖率、热点代码片段，甚至发现内存泄漏等安全漏洞</p>
<p>符号执行就是在运行程序时，用符号来替代真实值。符号执行相较于真实值执行的优点在于，当使用真实值执行程序时，我们能够遍历的程序路径只有一条，而使用符号进行执行时，由于符号是可变的，我们就可以利用这一特性，尽可能的将程序的每一条路径遍历，这样的话，必定存在至少一条能够输出正确结果的分支，每一条分支的结果都可以表示为一个离散关系式，使用约束求解引擎即可分析出正确结果。</p>
</blockquote>
<h2>1.angr概述</h2>
<ul>
<li>angr功能：
<ul>
<li>控制流图恢复</li>
<li>符号执行</li>
<li>使用angrop自动构建ROP链</li>
<li>使用patcherex自动进行二进制强化</li>
<li>使用rex自动生成漏洞利用程序（用于DECREE和简单的Linux二进制程序）</li>
<li>使用angr-management（一个angr的GUI）来分析二进制程序</li>
</ul>
</li>
<li>angr构成（模块）
<ul>
<li>可执行文件和库的加载器：CLE(CLE Load Everything) 负责装载二进制对象以及它所依赖的库，将自身无法执行的操作转移给angr的其它组件，最后生成地址空间，表示该程序已加载并可以准备运行。</li>
<li>描述各种架构的库：archinfo</li>
<li>关于二进制代码转换VEX的python包装器 ：PyVEX（angr需要处理不同的架构，所以它选择一种中间语言来进行它的分析，angr使用Valgrind的中间语言——VEX来完成这方面的内容。VEX中间语言抽象了几种不同架构间的区别，允许在他们之上进行统一的分析）</li>
<li>中间语言VEX执行的模拟器：SimuVEX，它允许你控制符号执行</li>
<li>抽象的约束求解包装器：Claripy（大部分用法和Z3类似）这个模块主要专注于将变量符号化，生成约束式并求解约束式，这也是符号执行的核心所在。</li>
<li>程序分析套件：angr（上层封装好的接口）</li>
</ul>
</li>
</ul>
<p><img src="/0101/Tools/4.模拟执行/assets/angr/830671_V3ZBZVDYVEBVSTM-1.png" alt="830671_V3ZBZVDYVEBVSTM-1"></p>
<h2>2.顶层接口</h2>
<p>Project类是angr的主类，也是angr的开始，通过初始化该类的对象，可以将你想要分析的二进制文件加载进来</p>
<pre><code class="language-python">import angr
proj = angr.Project('./test')
</code></pre>
<p>使用angr时最重要的就是效率问题，少加载一些无关结果的库能够提升angr的效率，如下：</p>
<pre><code class="language-python">proj = angr.Project('/bin/true', auto_load_libs=False)
</code></pre>
<p>Project的基本属性：</p>
<ul>
<li>arch：程序指令架构</li>
<li>entry：入口点</li>
<li>filename：程序绝对路径</li>
</ul>
<h2>3.加载器</h2>
<p>CLE的结果叫做加载器（loader），在Project类的属性<code>.loader</code> 中可用</p>
<pre><code class="language-python">In [7]: proj.loader
Out[7]: &lt;Loaded 0_angr_find, maps [0x8048000:0x8607fff]&gt;
 
In [8]: proj.loader.shared_objects
Out[8]:
OrderedDict([('00_angr_find',
              &lt;ELF Object 0_angr_find, maps [0x8048000:0x804a03f]&gt;),
             ('libc.so.6',
              &lt;ELF Object libc-2.31.so, maps [0x8100000:0x82edf0b]&gt;),
             ('ld-linux.so.2',
              &lt;ELF Object ld-2.31.so, maps [0x8300000:0x832c987]&gt;),
             ('extern-address space',
              &lt;ExternObject Object cle##externs, maps [0x8400000:0x8407fff]&gt;),
             ('cle##tls',
              &lt;ELFTLSObjectV2 Object cle##tls, maps [0x8500000:0x8514807]&gt;)])
 
In [9]: proj.loader.min_addr
Out[9]: 0x8048000
 
In [10]: proj.loader.max_addr
Out[10]: 0x8607fff
 
In [11]: proj.loader.main_object # 加载了多个二进制程序，这是主对象
Out[11]: &lt;ELF Object 0_angr_find, maps [0x8048000:0x804a03f]&gt;
 
In [12]: proj.loader.main_object.execstack # 查询主对象是否开启了NX
Out[12]: False
 
In [13]: proj.loader.main_object.pic # 查询主对象是否开启了PIC
Out[13]: False
</code></pre>
<p><code>project.factory</code> 为我们提供了一些实用的类的构造器，angr 以<strong>基本块为单位分析代码</strong>，可以通过 <code>project.factory.block(address)</code> 获取给定地址所在的基本块，一个 Block 类实例</p>
<pre><code class="language-python">In [14]: block = proj.factory.block(proj.entry) # 从程序的入口处提取一个代码块
 
In [15]: block.pp() # 打印反汇编代码
0x8048450:    xor    ebp, ebp
0x8048452:    pop    esi
0x8048453:    mov    ecx, esp
0x8048455:    and    esp, 0xfffffff0
0x8048458:    push    eax
0x8048459:    push    esp
0x804845a:    push    edx
0x804845b:    push    0x8048710
0x8048460:    push    0x80486b0
0x8048465:    push    ecx
0x8048466:    push    esi
0x8048467:    push    0x80485c7
0x804846c:    call    0x8048420
 
In [16]: block  # 查看block对象
Out[16]: &lt;Block for 0x8048450, 33 bytes&gt;
 
In [17]: block.instructions # 块里有多少条指令
Out[17]: 0xd
 
In [18]: block.instruction_addrs # 块里所有指令对应的地址
Out[18]:
[0x8048450,
 0x8048452,
 0x8048453,
 0x8048455,
 0x8048458,
 0x8048459,
 0x804845a,
 0x804845b,
 0x8048460,
 0x8048465,
 0x8048466,
 0x8048467,
 0x804846c]
</code></pre>
<h2>3.模拟执行</h2>
<p>Project实际上只是将二进制文件加载进来了，要执行它，实际上是对SimState对象进行操作，它是程序的状态</p>
<p>创建状态：</p>
<pre><code class="language-python">state = proj.factory.entry_state() #初始化状态为程序运行到程序入口点处的状态
state = proj.factory.blank_state(0xdeadbeef) #大多数数据都没有初始化，状态中下一条指令为addr处的指令
</code></pre>
<ul>
<li><code>state.regs</code>：寄存器状态组，其中每个寄存器都为一个 <em>位向量</em> （BitVector），可以通过寄存器名称来访问对应的寄存器（例如 <code>state.regs.esp -= 12</code> ）。</li>
<li><code>state.mem</code>：该状态的内存访问接口，我们可以直接通过 <code>state.mem[addr].type</code> 完成内存访问（例如 <code>state.mem[0x1000].long = 4</code> ，对于读而言还需指定 <code>.resolved</code> 或 <code>.concrete</code> 表示位向量或是实际值，例如 <code>state.mem[0x1000].long.concrete</code>）。</li>
<li><code>state.memory</code>：另一种形式的内存访问接口：</li>
<li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量。</li>
<li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址。</li>
<li><code>state.posix</code>：POSIX 相关的环境接口，例如 <code>state.posix.dumps(fileno)</code> 获取对应文件描述符上的流。</li>
</ul>
<p>上述state方式只是预设了程序开始分析时的状态，要分析程序就必须要让它到达下一个状态，这就需要模拟管理器</p>
<pre><code class="language-python">simgr = p.factory.simgr(state)
</code></pre>
<p>SM常用技术：</p>
<ul>
<li><code>simgr.step()</code>：<strong>以基本块为单位</strong>的单步执行。</li>
<li><code>simgr.explore()</code>：进行路径探索找到满足相应条件的状态，explore有如下参数：
<ul>
<li>find：传入目标指令的地址或地址列表，或者一个用于判断的函数，函数以state为形参，返回布尔值</li>
<li>avoid：传入要避免的指令的地址或地址列表，或者一个用于判断的函数，用于减少路径</li>
<li>explorer找到的符合find的状态会被保存在simgr.found这个列表当中，可以遍历其中元素获取状态，若无法找到则该列表为空。</li>
</ul>
</li>
</ul>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../assets/js/header.js"></script>
    <script src="../../../assets/js/include-header.js"></script>
</body>
</html>