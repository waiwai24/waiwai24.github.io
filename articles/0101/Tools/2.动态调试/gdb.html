<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># gdb,gdb</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>gdb</h1>
<h2>1.启动调试</h2>
<blockquote>
<p>对于C程序而言，需要在编译时加上<code>-g</code>参数，保留调试信息，否则不能使用gdb进行调试，使用enter键可重复执行上一条指令命令</p>
</blockquote>
<p>例如：</p>
<pre><code class="language-text">$ gdb helloworld
Reading symbols from helloWorld...(no debugging symbols found)...done.
</code></pre>
<p>如果没有调试信息，会提示no debugging symbols found。
如果有则是下面的提示：</p>
<pre><code class="language-text">Reading symbols from helloWorld...done.
</code></pre>
<p>则可以进行调试。</p>
<p>同样使用<code>file</code>命令也可以看出有无debug信息，并且如果最后是stripped则说明该文件的符号表信息和调试信息被去除，不能使用gdb调试，但是not stripped的情况并不能说明能够被调试</p>
<pre><code class="language-shell">┌──(waiwai㉿kali)-[/home/ctf/pwn/int_overflow]
└─$ file a.out 
a.out： ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=612336f334e5e5d4b5775e89a8c1716c5eac0ee0, for GNU/Linux 3.2.0, with debug_info, not stripped
                                                                                                                                        
┌──(waiwai㉿kali)-[/home/ctf/pwn/int_overflow]
└─$ file b.out
b.out： ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=e401563630cf931a9f85530f828e98030b01b317, for GNU/Linux 3.2.0, not stripped
</code></pre>
<ul>
<li>
<p>调试无参数程序：</p>
<pre><code class="language-bash">gdb file.o
(gdb) run
</code></pre>
</li>
<li>
<p>调试带参程序：</p>
<pre><code class="language-bash">gdb file.o
(gdb) run arg
</code></pre>
</li>
<li>
<p>调试已运行程序：先找到进程id再attach</p>
<pre><code class="language-shell">ps -ef|grep 进程名
gdb
(gdb) attach pid
</code></pre>
</li>
<li>
<p>run 指令会一直执行程序，直到执行结束</p>
</li>
<li>
<p>start 指令会执行程序至 main() 主函数的起始位置，即在 main() 函数的第一行语句处停止执行（该行代码尚未执行）</p>
</li>
<li>
<p>starti 开始执行程序，在第一条指令处会停下来</p>
</li>
<li>
<p>程序执行过程中使用 run 或者 start 指令，表示的是重新启动程序</p>
</li>
</ul>
<p>日志记录：</p>
<pre><code class="language-shell">set logging file gdb_log.txt  
set logging on  
</code></pre>
<h2>2.断点设置</h2>
<ul>
<li>
<p>根据行号设置：b num</p>
</li>
<li>
<p>根据函数名设置：b func</p>
</li>
<li>
<p>根据地址设置：b *0x12345678</p>
</li>
<li>
<p>根据条件设置： break test.c：23 if b==0 (当b为0时会在23行断住)</p>
</li>
<li>
<p>设置临时断点：tbreak test.c：23</p>
</li>
<li>
<p>跳过多次设置断点：ignore 1 30 (1是忽略的断点号，30是要跳过的次数)</p>
</li>
<li>
<p>内存监控：</p>
<ul>
<li>根据表达式值变化产生断点：watch a (观察a值是否变化，前提是程序必须运行起来)</li>
<li>watch *(void/int/char… *)(内存地址)/全局变量名，为表达式（变量）expr设置一个观察点。一量表达式值有变化时，立马停住</li>
<li>rwatch <expr>，当表达式（变量）expr被读时，停住程序</li>
<li>awatch <expr>，当表达式（变量）的值被读或被写时，停住程序</li>
<li>info watchpoints，列出当前所设置了的所有观察点</li>
</ul>
</li>
<li>
<p>禁用/启用断点：</p>
<ul>
<li>disable：禁用所有</li>
<li>disable num：禁用标号num的断点</li>
<li>enable：启用所有断点</li>
<li>enable num：启用标号num断点</li>
<li>enable delete num：启动标号num的断点，并且在此之后删除该断点</li>
</ul>
</li>
<li>
<p>断点清除：</p>
<ul>
<li>clear：删除所有b</li>
<li>clear func：删除函数func断点</li>
<li>delete：删除所有breakpoints，watchpoints，catchpoints</li>
<li>delete num：删除num号断点</li>
</ul>
</li>
</ul>
<h2>3.变量查看</h2>
<ul>
<li>打印print基本类型变量，数组，字符：p a(变量名)，p ‘main’：：a</li>
<li>打印指针指向内容：
<ul>
<li>p *d  (如果不加*则打印出指针地址)（打印出第一个值）</li>
<li>p *d@10  (解引用打印多个值@后跟上要打印的长度或变量值)</li>
</ul>
</li>
<li>按照特定格式打印变量：
<ul>
<li>x 十六进制格式</li>
<li>d 十进制格式</li>
<li>u 十六进制格式显示无符号整型</li>
<li>c 按字符格式</li>
<li>f 按浮点数格式</li>
<li>t 按二进制格式</li>
</ul>
</li>
</ul>
<pre><code>(gdb) p c
$18 = &quot;hello,shouwang&quot;
(gdb) p/x c
$19 = {0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x73, 0x68, 0x6f, 0x75, 0x77, 0x61, 0x6e, 0x67, 0x0}

</code></pre>
<ul>
<li>
<p>查看内存内容：</p>
<ul>
<li>
<p>语法：<code>x/[n][f][u] addr</code>,x：examine检查内存</p>
</li>
<li>
<p>n：要显示的内存单元数，默认为1</p>
</li>
<li>
<p>f：表示要打印的格式</p>
<pre><code>  x 按十六进制格式显示变量。
  d 按十进制格式显示变量。
  u 按十进制格式显示无符号整型。
  o 按八进制格式显示变量。
  t 按二进制格式显示变量。
  a 按十六进制格式显示变量。
  i 指令地址格式
  c 按字符格式显示变量。
  f 按浮点数格式显示变量。
</code></pre>
</li>
<li>
<p>u：要打印的一个地址的单元长度</p>
<pre><code>b表示单字节，
h表示双字节，
w表示四字节，
g表示八字节
</code></pre>
</li>
<li>
<p>addr：内存地址</p>
<pre><code>  (gdb) x/4tb &amp;e
  0x7fffffffdbd4：    00000000    00000000    00001000    01000001
  变量e的四个字节都以二进制的方式打印出来了
</code></pre>
</li>
</ul>
</li>
<li>
<p>info registers：打印普通寄存器</p>
</li>
<li>
<p>info all-registers：打印所有寄存器</p>
</li>
<li>
<p>查看函数：info functions</p>
</li>
<li>
<p>直接调用函数执行：call function 或 print function</p>
</li>
<li>
<p>set 修改运行时变量内容，也可以直接set地址指定的值</p>
<pre><code>set var variable=value
</code></pre>
</li>
<li>
<p>设定程序运行时的参数</p>
<pre><code>set args arg1 arg2 ...
</code></pre>
</li>
<li>
<p>set一般只能修改4字节，如果要修改8字节，就要强制类型转换</p>
<p>例子：<code>set *(long long*)0x7fffffffdf18=0x1234567812345678</code> 的意思是：将内存地址 <code>0x7fffffffdf18</code> 强制解释为一个 <code>long long</code> 类型的指针，然后通过间接引用操作符 <code>*</code> 来访问或修改这个地址处的 <code>long long</code> 值</p>
</li>
</ul>
<h2>4.单步调试</h2>
<ul>
<li>
<p>单步执行next，简写n，用于程序断住后，继续执行下一条语句，后面跟上数字num，表示执行该命令num次,当你执行到某个函数时，不会进入该函数内部，而是直接执行完该函数，然后继续执行下一行代码。</p>
</li>
<li>
<p>单步进入step，简写s，可以单步跟踪到函数内部</p>
</li>
<li>
<p>继续执行到下一个断点continue，简写c，他会执行程序直到再次遇到断点处</p>
</li>
<li>
<p>until（简写u）：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体
until+行号： 运行至某行，不仅仅用来跳出循环</p>
</li>
<li>
<p>finish 继续执行直到当前选定栈帧上的函数返回</p>
</li>
<li>
<p>return 取消函数调用的执行</p>
<p>return expression 如果指定一个 expression 表达式参数，其值将是此函数的返回值</p>
</li>
</ul>
<pre><code>next   单步到程序源代码的下一行，不进入函数。
nexti （ni）单步一条机器指令，不进入函数。
step   单步到下一个不同的源代码行（包括进入函数）。
stepi （si）单步一条机器指令。
</code></pre>
<ul>
<li>reverse-调试方法，可以反向调试（但是要在此之前开启record full）</li>
</ul>
<h2>5.源码查看</h2>
<ul>
<li>list：将源码列出来，简写l
<ul>
<li>后面可以跟行号，表示要列出附近的源码</li>
<li>后面跟函数名，列出指定函数附近的源码</li>
<li>设置源码一次列出行数，set listsize num</li>
<li>列出指定行之间的源码，list first，last</li>
</ul>
</li>
</ul>
<h2>6.反汇编</h2>
<p>反汇编只能在运行过程中使用</p>
<ul>
<li>
<p>反汇编main函数</p>
<pre><code>disassemble main
disass main
</code></pre>
</li>
</ul>
<h2>7.堆相关</h2>
<ul>
<li>
<p><code>vis_heap_chunks [count] [address]</code>：简写vis，在指定的地址上可视化堆块</p>
</li>
<li>
<p><code>arena</code>：显示arena的详细信息,过于详细</p>
</li>
<li>
<p><code>p main_arena</code>:主线程</p>
</li>
<li>
<p><code>arenas</code>：显示所有arena的基本信息</p>
</li>
<li>
<p><code>arenainfo</code>：好看的显示所有arena的信息</p>
</li>
</ul>
<ul>
<li><code>bins</code>：查看所有种类的堆块的链表情况</li>
<li><code>fastbins</code>：单独查看fastbins的链表情况</li>
<li><code>largebins</code>：同上，单独查看largebins的链表情况</li>
<li><code>smallbins</code>：同上，单独查看smallbins的链表情况</li>
<li><code>unsortedbin</code>：同上，单独查看unsortedbin链表情况</li>
<li><code>tcachebins</code>：同上，单独查看tcachebins的链表情况</li>
<li><code>tcache</code>：查看tcache详细信息</li>
<li><code>heap</code>：数据结构的形式显示所有堆块，会显示一大堆</li>
<li><code>heap -v</code>：查看完整数据结构</li>
<li><code>parseheap</code>，<code>par</code>：显示堆结构，很好用，与heap大同小异</li>
<li><code>mp</code>：查看堆相关结构体信息</li>
<li><code>heapbase</code>：查看堆起始地址</li>
<li><code>heapinfo、heapinfoall</code>：显示堆的信息，和bins的挺像的，没bins好用</li>
<li><code>tracemalloc</code>：好用，会跟提示所有操作堆的地方</li>
<li><code>try_free</code>：检查堆管理器是否能释放gai</li>
</ul>
<h2>8.多线程调试</h2>
<ul>
<li><code>info threads</code>: 查看当前所有的线程</li>
<li><code>thread n</code>: 切换到 id 为n的线程中</li>
<li>对于进程也有类似的命令<code>info inferiors</code>/<code>inferior n</code></li>
<li><code>set detach-on-fork on</code>：设置gdb是否分离fork的子进程，默认on</li>
<li><code>set follow-fork-mode child</code>：设置调试器响应到fork或vfork的程序调用,默认跟踪parent进程</li>
<li><code>catch exec</code>：捕获对 exec 的调用</li>
<li><code>catch fork</code>：捕获对 fork 的调用</li>
<li><code>catch vfork</code>：捕获对 vfork 的调用</li>
<li><code>catch syscall</code>：捕获系统调用</li>
</ul>
<h2>9.插件及其他</h2>
<ul>
<li>代码分屏快捷键：ctrl x + a</li>
<li>show debug-file-directory</li>
<li>set debug-file-directory directories：指定带调试信息共享库所在目录，也就是对应glibc版本的.debug目录，方法只是该次有效，当重新gdb调试时需要再次设置</li>
<li>查看源码搜索路径：show directories</li>
<li>directory path：指定源文件目录(源码调试时)（通常指定glibc源码路径），也可以在开始gdb时使用 gdb -d path 指定源文件路径</li>
<li>layout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：</li>
<li>layout src：显示源代码窗口</li>
<li>layout asm：显示汇编窗口</li>
<li>layout regs：显示源代码/汇编和寄存器窗口</li>
<li>layout split：显示源代码和汇编窗口</li>
<li>layout next：显示下一个layout</li>
<li>layout prev：显示上一个layoutCtrl + L：刷新窗口</li>
<li>Ctrl + x，再按1：单窗口模式，显示一个窗口</li>
<li>Ctrl + x，再按2：双窗口模式，显示两个窗口</li>
<li>Ctrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口</li>
<li>Ctrl + r，指令反向搜索</li>
<li>backtrace：(简写bt)可以查看程序的调用栈。-full 参数可完整打印</li>
<li>!shell：执行shell命令</li>
<li>search -t {type} value</li>
<li>find start_addr,end_addr,value</li>
<li>source file，运行file里面的脚本</li>
<li>u：在指定地址附近反汇编</li>
<li>hex：查看地址处的数据</li>
<li>leakfind addr --page_name=heap --max_offset=0x3000 --max_depth=3：尝试根据起始地址查找泄漏链，默认在栈中扫描，offset指定范围，depth指定深度</li>
</ul>
<h3>9.1 pwndbg</h3>
<ul>
<li>
<p><code>b *$rebase(偏移)</code>：PIE开启情况下下断点</p>
</li>
<li>
<p><code>codebase</code>：打印PIE偏移</p>
</li>
<li>
<p><code>telescope -addr count</code>：从指定地址开始递归地解引用指针（默认为$esp），计数值默认为8</p>
</li>
<li>
<p><code>vmmap</code>：查看程序各种段的地址和范围</p>
</li>
<li>
<p><code>cyclic n</code>：生成的字符串每四个字符为一组，以aaaa开始，最长到zzzz</p>
<pre><code>$ cyclic 128    
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaab
</code></pre>
<pre><code>可计算出栈溢出的长度
pwndbg&gt; cyclic -l 'gaaa'
24
</code></pre>
</li>
<li>
<p><code>fmtarg addr</code>:在进入<code>printf</code>函数时断下，调用<code>fmtarg</code>后可以自动计算格式化参数与<code>addr</code>的偏移</p>
</li>
<li>
<p>程序运行时对参数的输入/控制：</p>
<ul>
<li>run后面直接跟参数</li>
<li><code>set args</code></li>
<li>标准输入：<code>run &lt; file</code>,<code>$ python -c 'print &quot;A&quot;*100' | ./demo</code>,<code>run &lt; &lt;(python -c 'print &quot;A&quot;*100')</code></li>
</ul>
</li>
</ul>

        </main>
    </div>
</body>
</html>