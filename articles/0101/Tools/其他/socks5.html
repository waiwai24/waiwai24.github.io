<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># socks5,socks5</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>socks5</h1>
<h2>1.工作原理</h2>
<p>socks5 协议工作原理：</p>
<ul>
<li>首先客户端向代理服务器发出请求信息，用以协商版本和认证方法。随后代理服务器应答，将选择的方法发送给客户端</li>
<li>客户端和代理服务器进入由选定认证方法所决定的子协商过程，子协商过程结束后，客户端发送请求信息，其中包含目标服务器的 IP 地址和端口。代理服务器验证客户端身份，通过后会与目标服务器连接，目标服务器经过代理服务器向客户端返回状态响应</li>
<li>连接完成后，代理服务器开始作为中转站中转数据</li>
</ul>
<h2>2.具体流程</h2>
<p>客户端发起请求：</p>
<ul>
<li>VER：协议版本，socks5 为 0x05</li>
<li>NMETHODS：支持认证的方法数量</li>
<li>METHODS：对应 NMETHODS，NMETHODS 的值为多少，METHODS 就有多少个字节</li>
</ul>
<pre><code>+----+----------+----------+
|VER | NMETHODS | METHODS  |
+----+----------+----------+
| 1  |    1     | 1 to 255 |
+----+----------+----------+
</code></pre>
<p>socks5 服务器选中一个 METHOD 返回给客户端：定义的 METHOD 为 0x00 表示无需认证，0x02 表示用户名/密码认证</p>
<pre><code>+----+--------+
|VER | METHOD |
+----+--------+
| 1  |   1    |
+----+--------+
</code></pre>
<p>接下来是认证协商（属于可选项），客户端向 socks5 服务器发起认证请求：</p>
<ul>
<li>VER: 版本，通常为 0x01</li>
<li>ULEN: 用户名长度</li>
<li>UNAME: 对应用户名的字节数据</li>
<li>PLEN: 密码长度</li>
<li>PASSWD: 密码对应的数据</li>
</ul>
<pre><code>+----+------+----------+------+----------+
|VER | ULEN |  UNAME   | PLEN |  PASSWD  |
+----+------+----------+------+----------+
| 1  |  1   | 1 to 255 |  1   | 1 to 255 |
+----+------+----------+------+----------+
</code></pre>
<p>socks5 服务器收到客户端的认证请求后，解析内容，验证信息是否合法，然后给客户端响应结果：STATUS 字段如果为 0x00 表示认证成功，其他的值为认证失败</p>
<pre><code>+----+--------+
|VER | STATUS |
+----+--------+
| 1  |   1    |
+----+--------+
</code></pre>
<p>顺利通过协商阶段后，客户端向 socks5 服务器发起请求:</p>
<ul>
<li>VER 版本号，socks5 的值为 0x05</li>
<li>CMD
<ul>
<li>0x01 表示 CONNECT 请求</li>
<li>0x02 表示 BIND 请求</li>
<li>0x03 表示 UDP 转发</li>
</ul>
</li>
<li>RSV 保留字段，值为 0x00</li>
<li>ATYP 目标地址类型，DST.ADDR 的数据对应这个字段的类型。
<ul>
<li>0x01 表示 IPv4 地址，DST.ADDR 为 4 个字节</li>
<li>0x03 表示域名，DST.ADDR 是一个可变长度的域名，这种情况下 DST.ADDR 的第一个字节表示域名长度，剩下部分是域名内容</li>
<li>0x04 表示 IPv6 地址，DST.ADDR 为 16 个字节长度</li>
</ul>
</li>
<li>DST.ADDR 一个可变长度的值</li>
<li>DST.PORT 目标端口，固定 2 个字节</li>
</ul>
<pre><code>+----+-----+-------+------+----------+----------+
|VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
+----+-----+-------+------+----------+----------+
| 1  |  1  | X'00' |  1   | Variable |    2     |
+----+-----+-------+------+----------+----------+
</code></pre>
<p>socks5 服务器收到客户端的请求后，需要返回一个响应：</p>
<ul>
<li>VER socks 版本，这里为 0x05</li>
<li>REP Relay field, 内容取值如下
<ul>
<li>X’00’ succeeded</li>
<li>X’01’ general SOCKS server failure</li>
<li>X’02’ connection not allowed by ruleset</li>
<li>X’03’ Network unreachable</li>
<li>X’04’ Host unreachable</li>
<li>X’05’ Connection refused</li>
<li>X’06’ TTL expired</li>
<li>X’07’ Command not supported</li>
<li>X’08’ Address type not supported</li>
<li>X’09’ to X’FF’ unassigned</li>
</ul>
</li>
<li>RSV 保留字段</li>
<li>ATYPE 同请求的 ATYPE</li>
<li>BND.ADDR 服务绑定的地址</li>
<li>BND.PORT 服务绑定的端口 DST.PORT</li>
</ul>
<pre><code>+----+-----+-------+------+----------+----------+
|VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
+----+-----+-------+------+----------+----------+
| 1  |  1  | X'00' |  1   | Variable |    2     |
+----+-----+-------+------+----------+----------+
</code></pre>
<p>完整流程：</p>
<pre><code>客户端                         代理服务器
   |---------------------------------&gt;|   TCP 连接建立 (三次握手)
   |  支持的认证方法列表                 |
   |  VER=0x05, NMETHODS=1, [0x02]    |   (0x02 = 用户名/密码)
   |---------------------------------&gt;|
   |                                  |
   |                选择认证方式        |
   |&lt;---------------------------------|
   |           VER=0x05, METHOD=0x02  |
   |                                  |
   |  发送用户名密码认证请求           	  |
   |  VER=0x01, ULEN, UNAME, PLEN,    |
   |  PASS                            |
   |---------------------------------&gt;|
   |                                  |
   |           验证成功/失败            |
   |&lt;---------------------------------|
   |        VER=0x01, STATUS=0x00     | (0x00 = 成功)
   |                                  |
   |  发送代理请求 (CONNECT 命令)		  |
   |  VER=0x05, CMD=0x01, ATYP, ADDR, |
   |  PORT                            |
   |---------------------------------&gt;|
   |                                  |
   |        返回请求结果 (成功/失败) 	  |
   |&lt;---------------------------------|
   |  VER=0x05, REP=0x00 (成功)   	  |
   |                                  |
   |========= 建立隧道，传输数据 ========|
   | &lt;------ 客户端与目标主机通信 ------&gt;|
   |      (代理只转发数据，不再认证)      |
</code></pre>
<p><img src="/0101/Tools/其他/assets/socks5/image-20251019203111832.png" alt="image-20251019203111832"></p>
<h3>3.C 实现</h3>
<pre><code class="language-c">// gcc -o socks5 socks5.c -lpthread
// curl --proxy &quot;socks5://user: pass@your.proxy.host: 1080&quot; https://ifconfig.me
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;fcntl.h&gt;

#define SOCKS5_VERSION 0x05
#define METHOD_NO_AUTH 0x00
#define METHOD_PASSWORD 0x02
#define METHOD_NOT_ACCEPTABLE 0xFF

#define CMD_CONNECT 0x01
#define CMD_BIND 0x02
#define CMD_UDP_ASSOCIATE 0x03

#define ATYP_IPV4 0x01
#define ATYP_DOMAINNAME 0x03
#define ATYP_IPV6 0x04

#define REP_SUCCESS 0x00
#define REP_GENERAL_FAILURE 0x01
#define REP_CONNECTION_NOT_ALLOWED 0x02
#define REP_NETWORK_UNREACHABLE 0x03
#define REP_HOST_UNREACHABLE 0x04
#define REP_CONNECTION_REFUSED 0x05
#define REP_TTL_EXPIRED 0x06
#define REP_COMMAND_NOT_SUPPORTED 0x07
#define REP_ADDRESS_TYPE_NOT_SUPPORTED 0x08

#define AUTH_VERSION 0x01
#define AUTH_SUCCESS 0x00
#define AUTH_FAILURE 0x01

#define BUFFER_SIZE 4096
#define MAX_ALLOWED_SUBNETS 256
#define MAX_USERNAME_LEN 32
#define MAX_PASSWORD_LEN 32
#define MAX_CLIENTS 1000
#define MAX_DOMAIN_LEN 255
#define CONNECT_TIMEOUT 10
#define TRANSFER_TIMEOUT 300
#define RECV_TIMEOUT 30

static volatile sig_atomic_t server_running = 1;
static int server_fd = -1;

typedef struct {
    const char *username;
    const char *password;
} User;

User allowed_users[] = {
    {&quot;admin&quot;, &quot;admin@password123&quot;},
    {NULL, NULL}
};

typedef struct {
    int active_connections;
    pthread_mutex_t mutex;
} ConnectionPool;

static ConnectionPool conn_pool = {0, PTHREAD_MUTEX_INITIALIZER};

typedef struct {
    int port;
    int require_auth;
    int max_connections;
    int connect_timeout;
    int transfer_timeout;
    char *log_file;
} ServerConfig;

static ServerConfig g_config = {
    .port = 1080,
    .require_auth = 1,
    .max_connections = MAX_CLIENTS,
    .connect_timeout = CONNECT_TIMEOUT,
    .transfer_timeout = TRANSFER_TIMEOUT,
    .log_file = NULL
};

char *allowed_subnets[MAX_ALLOWED_SUBNETS] = {
    NULL
};

int set_socket_timeout(int fd, int timeout_sec) {
    struct timeval timeout;
    timeout.tv_sec = timeout_sec;
    timeout.tv_usec = 0;
    
    if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, sizeof(timeout)) &lt; 0) {
        return -1;
    }
    if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, sizeof(timeout)) &lt; 0) {
        return -1;
    }
    return 0;
}

ssize_t safe_recv(int fd, void *buf, size_t len, int timeout_sec) {
    struct timeval tv;
    tv.tv_sec = timeout_sec;
    tv.tv_usec = 0;
    
    fd_set readfds;
    FD_ZERO(&amp;readfds);
    FD_SET(fd, &amp;readfds);
    
    int ret = select(fd + 1, &amp;readfds, NULL, NULL, &amp;tv);
    if (ret &lt;= 0) {
        return -1;
    }
    
    size_t total = 0;
    while (total &lt; len) {
        ssize_t n = recv(fd, (char*)buf + total, len - total, 0);
        if (n &lt;= 0) {
            return n;
        }
        total += n;
    }
    return total;
}

ssize_t send_all(int fd, const void *buf, size_t len, int flags) {
    size_t total_sent = 0;
    const char *ptr = (const char *)buf;

    while (total_sent &lt; len) {
        ssize_t sent = send(fd, ptr + total_sent, len - total_sent, flags);

        if (sent &lt; 0) {
            if (errno == EINTR) {
                continue;
            }
            return -1;
        }

        if (sent == 0) {
            return -1;
        }

        total_sent += sent;
    }

    return (ssize_t)total_sent;
}

int verify_credentials(const char *username, const char *password) {
    for (int i = 0; allowed_users[i].username != NULL; i++) {
        if (strcmp(username, allowed_users[i].username) == 0 &amp;&amp;
            strcmp(password, allowed_users[i].password) == 0) {
            return 1;
        }
    }
    return 0;
}

int handle_authentication(int client_fd) {
    uint8_t buffer[BUFFER_SIZE];
    ssize_t n;

    // 读取版本和用户名长度
    n = safe_recv(client_fd, buffer, 2, RECV_TIMEOUT);
    if (n != 2 || buffer[0] != AUTH_VERSION) {
        return -1;
    }

    uint8_t username_len = buffer[1];
    if (username_len == 0 || username_len &gt; MAX_USERNAME_LEN) {
        return -1;
    }

    // 读取用户名
    n = safe_recv(client_fd, buffer, username_len, RECV_TIMEOUT);
    if (n != username_len) {
        return -1;
    }
    char username[MAX_USERNAME_LEN + 1];
    memcpy(username, buffer, username_len);
    username[username_len] = '\0';

    // 读取密码长度
    n = safe_recv(client_fd, buffer, 1, RECV_TIMEOUT);
    if (n != 1) {
        return -1;
    }
    uint8_t password_len = buffer[0];
    if (password_len == 0 || password_len &gt; MAX_PASSWORD_LEN) {
        return -1;
    }

    // 读取密码
    n = safe_recv(client_fd, buffer, password_len, RECV_TIMEOUT);
    if (n != password_len) {
        return -1;
    }
    char password[MAX_PASSWORD_LEN + 1];
    memcpy(password, buffer, password_len);
    password[password_len] = '\0';

    printf(&quot;Auth attempt: username=%s\n&quot;, username);

    // 验证并发送结果
    uint8_t auth_response[] = {AUTH_VERSION, AUTH_FAILURE};
    if (verify_credentials(username, password)) {
        auth_response[1] = AUTH_SUCCESS;
        printf(&quot;User %s auth succeeded\n&quot;, username);
    } else {
        printf(&quot;User %s auth failed\n&quot;, username);
    }

    if (send_all(client_fd, auth_response, 2, MSG_NOSIGNAL) != 2) {
        return -1;
    }

    return auth_response[1] == AUTH_SUCCESS ? 0 : -1;
}

uint32_t ip_to_int(const char *ip) {
    struct in_addr addr;
    if (inet_pton(AF_INET, ip, &amp;addr) &lt;= 0) {
        return 0;
    }
    return ntohl(addr.s_addr);
}

int is_ip_in_subnet(uint32_t ip, const char *subnet) {
    char network[16];
    int mask_bits;
    
    if (sscanf(subnet, &quot;%15[^/]/%d&quot;, network, &amp;mask_bits) != 2) {
        return 0;
    }
    
    if (mask_bits &lt; 0 || mask_bits &gt; 32) {
        return 0;
    }
    
    uint32_t network_ip = ip_to_int(network);
    if (network_ip == 0) {
        return 0;
    }
    
    uint32_t mask = (0xFFFFFFFF &lt;&lt; (32 - mask_bits)) &amp; 0xFFFFFFFF;
    return (ip &amp; mask) == (network_ip &amp; mask);
}

int is_allowed(const char *target_ip) {
    uint32_t ip = ip_to_int(target_ip);
    if (ip == 0) {
        return 0;
    }
    
    if (allowed_subnets[0] == NULL) {
        return 1;
    }
    
    for (int i = 0; allowed_subnets[i] != NULL; i++) {
        if (is_ip_in_subnet(ip, allowed_subnets[i])) {
            return 1;
        }
    }
    
    return 0;
}

int send_response(int client_fd, uint8_t rep, const char *bind_addr, uint16_t bind_port) {
    uint8_t response[10];
    struct in_addr addr;
    
    response[0] = SOCKS5_VERSION;
    response[1] = rep;
    response[2] = 0x00;
    response[3] = ATYP_IPV4;
    
    inet_pton(AF_INET, bind_addr, &amp;addr);
    memcpy(&amp;response[4], &amp;addr.s_addr, 4);
    
    uint16_t port = htons(bind_port);
    memcpy(&amp;response[8], &amp;port, 2);

    return send_all(client_fd, response, 10, MSG_NOSIGNAL);
}

int handle_handshake(int client_fd, int *selected_method) {
    uint8_t buffer[256];
    ssize_t n;

    // 读取版本和方法数量
    n = safe_recv(client_fd, buffer, 2, RECV_TIMEOUT);
    if (n != 2 || buffer[0] != SOCKS5_VERSION) {
        return -1;
    }

    uint8_t nmethods = buffer[1];
    if (nmethods == 0) {
        return -1;
    }

    // 读取方法列表
    n = safe_recv(client_fd, buffer, nmethods, RECV_TIMEOUT);
    if (n != nmethods) {
        return -1;
    }

    *selected_method = METHOD_NOT_ACCEPTABLE;

    if (g_config.require_auth) {
        for (int i = 0; i &lt; nmethods; i++) {
            if (buffer[i] == METHOD_PASSWORD) {
                *selected_method = METHOD_PASSWORD;
                break;
            }
        }
    } else {
        for (int i = 0; i &lt; nmethods; i++) {
            if (buffer[i] == METHOD_NO_AUTH) {
                *selected_method = METHOD_NO_AUTH;
                break;
            }
        }
    }

    uint8_t response[2] = {SOCKS5_VERSION, *selected_method};
    if (send_all(client_fd, response, 2, MSG_NOSIGNAL) != 2) {
        return -1;
    }

    return *selected_method != METHOD_NOT_ACCEPTABLE ? 0 : -1;
}

int handle_domain_request(int client_fd, char *target_addr, uint16_t *target_port) {
    uint8_t buffer[MAX_DOMAIN_LEN + 10];
    ssize_t n;

    // 读取域名长度
    n = safe_recv(client_fd, buffer, 1, RECV_TIMEOUT);
    if (n != 1) {
        send_response(client_fd, REP_GENERAL_FAILURE, &quot;0.0.0.0&quot;, 0);
        return -1;
    }

    uint8_t domain_len = buffer[0];
    if (domain_len == 0) {
        send_response(client_fd, REP_GENERAL_FAILURE, &quot;0.0.0.0&quot;, 0);
        return -1;
    }

    // 读取域名和端口
    n = safe_recv(client_fd, buffer, domain_len + 2, RECV_TIMEOUT);
    if (n != domain_len + 2) {
        send_response(client_fd, REP_GENERAL_FAILURE, &quot;0.0.0.0&quot;, 0);
        return -1;
    }

    char domain[MAX_DOMAIN_LEN + 1];
    memcpy(domain, buffer, domain_len);
    domain[domain_len] = '\0';

    *target_port = ntohs(*(uint16_t *)&amp;buffer[domain_len]);

    struct addrinfo hints, *result;
    memset(&amp;hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    int ret = getaddrinfo(domain, NULL, &amp;hints, &amp;result);
    if (ret != 0) {
        send_response(client_fd, REP_HOST_UNREACHABLE, &quot;0.0.0.0&quot;, 0);
        return -1;
    }

    struct sockaddr_in *addr_in = (struct sockaddr_in *)result-&gt;ai_addr;
    inet_ntop(AF_INET, &amp;addr_in-&gt;sin_addr, target_addr, INET_ADDRSTRLEN);

    freeaddrinfo(result);
    return 0;
}

void forward_data(int client_fd, int target_fd) {
    fd_set read_fds;
    char buffer[BUFFER_SIZE];
    ssize_t n;
    struct timeval timeout;
    time_t last_activity = time(NULL);

    while (server_running) {
        FD_ZERO(&amp;read_fds);
        FD_SET(client_fd, &amp;read_fds);
        FD_SET(target_fd, &amp;read_fds);

        int max_fd = (client_fd &gt; target_fd) ? client_fd : target_fd;

        timeout.tv_sec = 1;
        timeout.tv_usec = 0;

        int activity = select(max_fd + 1, &amp;read_fds, NULL, NULL, &amp;timeout);

        if (activity &lt; 0) {
            if (errno == EINTR) continue;
            break;
        }

        if (activity == 0) {
            if (time(NULL) - last_activity &gt; g_config.transfer_timeout) {
                printf(&quot;Connection timeout, closing...\n&quot;);
                break;
            }
            continue;
        }

        last_activity = time(NULL);

        if (FD_ISSET(client_fd, &amp;read_fds)) {
            n = recv(client_fd, buffer, BUFFER_SIZE, 0);
            if (n &lt;= 0) break;
            if (send_all(target_fd, buffer, n, MSG_NOSIGNAL) != n) break;
        }

        if (FD_ISSET(target_fd, &amp;read_fds)) {
            n = recv(target_fd, buffer, BUFFER_SIZE, 0);
            if (n &lt;= 0) break;
            if (send_all(client_fd, buffer, n, MSG_NOSIGNAL) != n) break;
        }
    }
}

int connect_with_timeout(int sockfd, const struct sockaddr *addr, socklen_t addrlen, int timeout_sec) {
    int flags = fcntl(sockfd, F_GETFL, 0);
    fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);

    int ret = connect(sockfd, addr, addrlen);
    if (ret &lt; 0 &amp;&amp; errno != EINPROGRESS) {
        return -1;
    }

    if (ret == 0) {
        fcntl(sockfd, F_SETFL, flags);
        return 0;
    }

    fd_set writefds;
    FD_ZERO(&amp;writefds);
    FD_SET(sockfd, &amp;writefds);

    struct timeval tv;
    tv.tv_sec = timeout_sec;
    tv.tv_usec = 0;

    ret = select(sockfd + 1, NULL, &amp;writefds, NULL, &amp;tv);
    if (ret &lt;= 0) {
        return -1;
    }

    int error = 0;
    socklen_t len = sizeof(error);
    if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; 0 || error != 0) {
        return -1;
    }

    fcntl(sockfd, F_SETFL, flags);
    return 0;
}

void *handle_client(void *arg) {
    int client_fd = *(int *)arg;
    free(arg);

    char target_addr[INET_ADDRSTRLEN];
    uint16_t target_port;
    int target_fd = -1;
    int selected_method;
    int connection_counted = 0;

    // 设置客户端 socket 超时
    set_socket_timeout(client_fd, RECV_TIMEOUT);

    pthread_mutex_lock(&amp;conn_pool.mutex);
    if (conn_pool.active_connections &gt;= g_config.max_connections) {
        pthread_mutex_unlock(&amp;conn_pool.mutex);
        fprintf(stderr, &quot;Maximum connection limit reached\n&quot;);
        close(client_fd);
        return NULL;
    }
    conn_pool.active_connections++;
    pthread_mutex_unlock(&amp;conn_pool.mutex);
    connection_counted = 1;

    do {
        // 1. 握手
        if (handle_handshake(client_fd, &amp;selected_method) != 0) {
            printf(&quot;Handshake failed\n&quot;);
            break;
        }

        // 2. 认证
        if (selected_method == METHOD_PASSWORD) {
            if (handle_authentication(client_fd) != 0) {
                printf(&quot;Authentication failed\n&quot;);
                break;
            }
        }

        // 3. 处理请求
        uint8_t buffer[4];
        ssize_t n = safe_recv(client_fd, buffer, 4, RECV_TIMEOUT);
        if (n != 4 || buffer[0] != SOCKS5_VERSION) {
            send_response(client_fd, REP_GENERAL_FAILURE, &quot;0.0.0.0&quot;, 0);
            break;
        }

        if (buffer[1] != CMD_CONNECT) {
            send_response(client_fd, REP_COMMAND_NOT_SUPPORTED, &quot;0.0.0.0&quot;, 0);
            break;
        }

        // 根据地址类型处理
        if (buffer[3] == ATYP_IPV4) {
            uint8_t addr_port[6];
            n = safe_recv(client_fd, addr_port, 6, RECV_TIMEOUT);
            if (n != 6) {
                send_response(client_fd, REP_GENERAL_FAILURE, &quot;0.0.0.0&quot;, 0);
                break;
            }
            struct in_addr addr;
            memcpy(&amp;addr.s_addr, addr_port, 4);
            inet_ntop(AF_INET, &amp;addr, target_addr, INET_ADDRSTRLEN);
            target_port = ntohs(*(uint16_t *)&amp;addr_port[4]);

        } else if (buffer[3] == ATYP_DOMAINNAME) {
            if (handle_domain_request(client_fd, target_addr, &amp;target_port) != 0) {
                break;
            }
        } else {
            send_response(client_fd, REP_ADDRESS_TYPE_NOT_SUPPORTED, &quot;0.0.0.0&quot;, 0);
            break;
        }

        printf(&quot;Request: %s:%d\n&quot;, target_addr, target_port);

        // 4. 检查访问权限
        if (!is_allowed(target_addr)) {
            send_response(client_fd, REP_CONNECTION_NOT_ALLOWED, &quot;0.0.0.0&quot;, 0);
            break;
        }

        // 5. 连接目标
        target_fd = socket(AF_INET, SOCK_STREAM, 0);
        if (target_fd &lt; 0) {
            send_response(client_fd, REP_GENERAL_FAILURE, &quot;0.0.0.0&quot;, 0);
            break;
        }

        struct sockaddr_in target_addr_in;
        memset(&amp;target_addr_in, 0, sizeof(target_addr_in));
        target_addr_in.sin_family = AF_INET;
        target_addr_in.sin_port = htons(target_port);
        inet_pton(AF_INET, target_addr, &amp;target_addr_in.sin_addr);

        if (connect_with_timeout(target_fd, (struct sockaddr *)&amp;target_addr_in, 
                                sizeof(target_addr_in), g_config.connect_timeout) &lt; 0) {
            printf(&quot;Connect to %s:%d failed\n&quot;, target_addr, target_port);
            send_response(client_fd, REP_CONNECTION_REFUSED, &quot;0.0.0.0&quot;, 0);
            break;
        }

        // 设置目标 socket 超时
        set_socket_timeout(target_fd, g_config.transfer_timeout);

        // 6. 发送成功响应并转发数据
        send_response(client_fd, REP_SUCCESS, &quot;0.0.0.0&quot;, 0);
        printf(&quot;Connection established: %s:%d\n&quot;, target_addr, target_port);
        forward_data(client_fd, target_fd);

    } while(0);

    // 清理资源
    if (target_fd &gt;= 0) close(target_fd);
    close(client_fd);

    if (connection_counted) {
        pthread_mutex_lock(&amp;conn_pool.mutex);
        conn_pool.active_connections--;
        pthread_mutex_unlock(&amp;conn_pool.mutex);
    }

    return NULL;
}

void signal_handler(int sig) {
    if (sig == SIGINT || sig == SIGTERM) {
        server_running = 0;
        if (server_fd != -1) {
            shutdown(server_fd, SHUT_RDWR);
        }
    }
}

int main(int argc, char *argv[]) {
    signal(SIGPIPE, SIG_IGN);
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    if (argc &gt; 1) {
        g_config.port = atoi(argv[1]);
        if (g_config.port &lt;= 0 || g_config.port &gt; 65535) {
            fprintf(stderr, &quot;Invalid port: %s\n&quot;, argv[1]);
            return 1;
        }
    }

    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd &lt; 0) {
        fprintf(stderr, &quot;Create socket failed: %s\n&quot;, strerror(errno));
        return 1;
    }

    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));
    setsockopt(server_fd, SOL_SOCKET, SO_KEEPALIVE, &amp;opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&amp;server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(g_config.port);

    if (bind(server_fd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) &lt; 0) {
        fprintf(stderr, &quot;Bind failed: %s\n&quot;, strerror(errno));
        close(server_fd);
        return 1;
    }

    if (listen(server_fd, 128) &lt; 0) {
        fprintf(stderr, &quot;Listen failed: %s\n&quot;, strerror(errno));
        close(server_fd);
        return 1;
    }

    printf(&quot;[*] SOCKS5 proxy started\n&quot;);
    printf(&quot;[*] Port: %d\n&quot;, g_config.port);
    printf(&quot;[*] Auth: %s\n&quot;, g_config.require_auth ? &quot;required&quot; : &quot;optional&quot;);
    printf(&quot;[*] Max connections: %d\n&quot;, g_config.max_connections);
    printf(&quot;[*] Credentials: admin/admin@password123\n&quot;);
    printf(&quot;[*] Press Ctrl+C to stop\n\n&quot;);

    while (server_running) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);

        int client_fd = accept(server_fd, (struct sockaddr *)&amp;client_addr, &amp;client_len);
        if (client_fd &lt; 0) {
            if (errno == EINTR || errno == EBADF) {
                continue;
            }
            if (!server_running) break;
            fprintf(stderr, &quot;Accept failed: %s\n&quot;, strerror(errno));
            continue;
        }

        char client_ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &amp;client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        printf(&quot;[+] New connection: %s:%d\n&quot;, client_ip, ntohs(client_addr.sin_port));

        int *client_fd_ptr = malloc(sizeof(int));
        if (!client_fd_ptr) {
            close(client_fd);
            continue;
        }
        *client_fd_ptr = client_fd;

        pthread_t thread_id;
        pthread_attr_t attr;
        pthread_attr_init(&amp;attr);
        pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
        
        if (pthread_create(&amp;thread_id, &amp;attr, handle_client, client_fd_ptr) != 0) {
            close(client_fd);
            free(client_fd_ptr);
        }
        
        pthread_attr_destroy(&amp;attr);
    }

    printf(&quot;\n[*] Shutting down gracefully...\n&quot;);
    
    if (server_fd != -1) {
        close(server_fd);
        server_fd = -1;
    }

    printf(&quot;[*] Waiting for connections to close...\n&quot;);
    sleep(2);

    printf(&quot;[*] Server stopped.\n&quot;);
    return 0;
}
</code></pre>

        </main>
    </div>
</body>
</html>