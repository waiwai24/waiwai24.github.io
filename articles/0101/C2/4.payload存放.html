<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># payload 存放,payload 存放</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>payload 存放</h1>
<h2>1.存放位置</h2>
<p>有效载荷可以存储在以下 PE 部分之一中：</p>
<ul>
<li>
<p>.data：数据段，PE 文件的 .data 段是 PE 文件的可执行部分中包含已初始化全局变量和静态变量的部分。此节可读写，适合需要在运行时解密的加密有效负载。有效负载如果是全局或局部变量，将存储在 .data 节中，具体取决于编译器设置</p>
</li>
<li>
<p>.rdata：只读数据段，使用 const 限定符指定的变量被写为常量。这类变量被认为是“只读”数据。.rdata 中的字母 “r” 表示此含义，任何尝试更改这些变量的行为都会导致访问冲突。此外，根据编译器及其设置，.data 和 .rdata 可能会被合并，甚至被合并到 .text 节中</p>
</li>
<li>
<p>.text：代码段，告诉编译器将 Text_rawData 变量放在 .text 中，而不是 .rdata 中。.text 是特殊的，因为它存储具有可执行内存权限的变量，允许它们直接执行，而无需编辑内存区域权限。这对于大约小于 10 个字节的小型负载很有用：</p>
<pre><code class="language-c">#pragma section(&quot;.text&quot;)
__declspec(allocate(&quot;.text&quot;)) const unsigned char Text_RawData[] = {}
</code></pre>
</li>
<li>
<p>.rsrc：包含了模块的资源信息，只读内存，将有效负载保存在 .rsrc 段是一种更简洁的方法，因为较大的有效负载无法存储在 .data 或 .rdata 段中，因为存在大小限制，从而导致编译期间 Visual Studio 报错，但有效负载无法直接从资源部分编辑，因此必须将其移动到一个临时缓冲区</p>
<ul>
<li>Visual Studio 中，右键单击“资源文件”，然后单击添加 &gt; 新建项</li>
<li>资源文件中选 rc，Resource.rc</li>
<li>然后添加资源，选择导入，将原始 shellcode 文件命名为 .ico 扩展名有效负载</li>
<li>资源类型输入 RCDATA</li>
</ul>
<pre><code class="language-c">#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include &quot;resource.h&quot;

int main() {

    HRSRC       hRsrc = NULL;
    HGLOBAL     hGlobal = NULL;
    PVOID       pPayloadAddress = NULL;
    SIZE_T      sPayloadSize = NULL;

    // 根据其 ID *IDR_RCDATA1* 获取存储在 .rsrc 中的数据的位置，RT_RCDATA 是资源类型
    hRsrc = FindResourceW(NULL, MAKEINTRESOURCEW(IDR_RCDATA1), RT_RCDATA);
    if (hRsrc == NULL) {
        // 函数发生错误
        printf(&quot;[!] FindResourceW 失败，错误信息：%d \n&quot;, GetLastError());
        return -1;
    }

    // 后续调用 LockResource，因此需要获取 HGLOBAL 或指定资源数据的句柄
    hGlobal = LoadResource(NULL, hRsrc);
    if (hGlobal == NULL) {
        // 函数发生错误
        printf(&quot;[!] LoadResource 失败，错误信息：%d \n&quot;, GetLastError());
        return -1;
    }

    // 获取 .rsrc 部分中有效负载的地址
    pPayloadAddress = LockResource(hGlobal);
    if (pPayloadAddress == NULL) {
        // 函数发生错误
        printf(&quot;[!] LockResource 失败，错误信息：%d \n&quot;, GetLastError());
        return -1;
    }

    // 获取 .rsrc 部分中有效负载的尺寸
    sPayloadSize = SizeofResource(NULL, hRsrc);
    if (sPayloadSize == NULL) {
        // 函数发生错误
        printf(&quot;[!] SizeofResource 失败，错误信息：%d \n&quot;, GetLastError());
        return -1;
    }

    // 在屏幕上打印指针和尺寸
    printf(&quot;[i] pPayloadAddress 变量：0x%p \n&quot;, pPayloadAddress);
    printf(&quot;[i] sPayloadSize 变量：%ld \n&quot;, sPayloadSize);
    printf(&quot;[#] 按下 &lt;Enter&gt; 退出...&quot;);

	PVOID pTmpBuffer = HeapAlloc(GetProcessHeap(), 0, sPayloadSize);
	if (pTmpBuffer != NULL) {
    	// 将有效负载从资源部分复制到新缓冲区
    	memcpy(pTmpBuffer, pPayloadAddress, sPayloadSize);
	}

	// 打印缓冲区 (pTmpBuffer) 的基址
	printf(&quot;[i] pTmpBuffer var : 0x%p \n&quot;, pTmpBuffer);
    getchar();
    return 0;
}
</code></pre>
</li>
</ul>

        </main>
    </div>
</body>
</html>