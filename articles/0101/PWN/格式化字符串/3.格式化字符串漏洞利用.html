<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># 格式化字符串漏洞利用,格式化字符串漏洞利用</title>
    <link rel="stylesheet" href="../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>格式化字符串漏洞利用</h1>
<blockquote>
<p>格式化字符串漏洞的形成原因在于 printf/fprintf/vsprintf 等 <strong>格式化字符串打印函数在接受可变参数</strong> 时，因码农自己偷懒写，编写的形式不正确而形成的漏洞</p>
<pre><code>char true[0x100]
规范写法：printf(&quot;%s&quot;,true)
懒人：printf(true)
</code></pre>
<p>栈上的格式化字符串漏洞利用步骤是先泄露地址，包括 ELF 程序地址和 libc 地址；然后将需要改写的 GOT 表地址直接传到栈上，同时利用 <code>%k$n</code> 的方法改写入 <code>system或one_gadget</code> 地址，最后就是劫持流程</p>
</blockquote>
<h2>1.程序崩溃</h2>
<pre><code>%s%s%s%s%s%s%s%s%s%s%s%s%s%s
</code></pre>
<p>利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们只需要输入若干个 %s 即可，因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃</p>
<h2>2.泄露内存</h2>
<h3>2.1 泄露栈内存</h3>
<h4>2.1.1 获取栈变量数值</h4>
<ul>
<li>示例代码：</li>
</ul>
<pre><code>char content[0x20];
read(0, content, 0x20);
printf(content);
</code></pre>
<ul>
<li>
<p>输入：%p%p</p>
</li>
<li>
<p>输出：0xffffd02c0x20</p>
</li>
<li>
<p>产生原因：<strong><code>printf</code> 仍然把我们传入的数据当作字符串，并将栈上后面的数据以字符串中 <code>%</code> 开头的方式进行解析</strong>。输入的数据为 <code>%p%p</code> 时，它将会把栈上后面的数据当作传入函数的参数，并以 <code>%p</code> 的方式解析。例如，<code>printf</code> 将栈上的 <code>0xffffd014</code> 处内容进行解析，并以十六进制格式输出存放在该栈处的值 <code>0xffffd02c</code>，接下来再以同样的方式将 <code>0xffffd018</code> 处的值以 <code>%p</code> 的方式进行解析，输出 <code>0x20</code></p>
</li>
</ul>
<pre><code>stack
00:0000│ esp     0xffffd010 —▸ 0xffffd02c ◂— 0x70243225 ('%2$p')  // 这是第0个参数
01:0004│         0xffffd014 —▸ 0xffffd02c ◂— 0x70243225 ('%2$p')  // 这是第1个参数
02:0008│         0xffffd018 ◂— 0x20 /* ' ' */                     // 这是第2个参数
03:000c│         0xffffd01c —▸ 0x56556228 (main+27) ◂— add ebx, 0x2da8        // 这是第3个参数
04:0010│         0xffffd020 —▸ 0xf7fb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1e9d6c // 这是第4个参数
05:0014│         0xffffd024 —▸ 0xf7fe22f0 ◂— endbr32                          // 这是第5个参数
06:0018│         0xffffd028 ◂— 0x0                                            // 这是第6个参数
07:001c│ eax ecx 0xffffd02c ◂— 0x70243225 ('%2$p')    
</code></pre>
<ul>
<li><strong>进阶</strong>：使用 <code>%n$p</code> 的方式来泄露栈上指定位置的内容的解析值。其中，<code>n</code> 是要泄露的第几个位置。也可以 <code>%n$x</code>, 直接泄露栈上内容而不解析</li>
</ul>
<h4>2.1.2 获取栈变量对应字符串</h4>
<p>使用 %s 即可，对应用法同上（<code>%k$s</code>），但是，如果 <strong>对应的地址不能够被解析为字符串地址，那么，程序就会直接崩溃。</strong></p>
<h3>2.2 泄露任意地址内存</h3>
<ul>
<li>利用 GOT 表得到 libc 函数地址，进而获取 libc，进而获取其它 libc 函数地址</li>
<li>盲打，dump 整个程序，获取有用信息</li>
</ul>
<h2>3.覆盖内存</h2>
<p><code>printf</code> 函数可以完成写操作，利用 <code>%k$n</code> 特性（不输出字符，但是把已经成功输出的字符个数覆盖第 k 个参数指向的地址）</p>
<p>同时，也可以覆盖任意内存，在第 k 个位置写入 target addr，那么再利用 n 特性写入的时候就会把输出字符个数写入 target addr</p>
<p><strong>注意：覆盖内存只能覆盖栈上某地址指向的内存，而不是直接覆盖栈上某地址</strong></p>
<pre><code class="language-python">payload = p64() + b'%nc' + b'%k$n' # 向k处的地址写入n的大小
</code></pre>
<p>对于小于机器字长的数字，如果把地址放在格式化字符串前面会使得已输出字符个数大于数字大小，因此要将地址放在后面</p>
<p>以数字 2 为例：<code>aa%k$n[padding][addr]</code></p>
<p>覆盖大数字, 以 hhn 写入 32bit 数为例： <code>[addr][addr+1][addr+2][addr+3] [pad1]%k$hhn [pad2]%(k+1)$hhn [pad3]%(k+2)$hhn [pad4]%(k+3)$hhn</code></p>
<p>pwntools 提供的工具：</p>
<pre><code class="language-python">fmtstr_payload(offset, {address:data}, numbwritten=0, write_size='byte')
</code></pre>
<ul>
<li>offset 表示格式化字符串的偏移</li>
<li>{address: data} 表示在 address 写入 data</li>
<li>numbwritten 表示已经输出的字符个数</li>
<li>write_size 表示写入方式，是按字节（byte）、按双字节（short）还是按四字节（int），对应着 hhn、hn 和 n，默认值是 byte，即按 hhn 写</li>
<li>部分题目会限制时间，导致 pwntools 生成的 payload 失效</li>
</ul>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../assets/js/header.js"></script>
    <script src="../../../assets/js/include-header.js"></script>
</body>
</html>