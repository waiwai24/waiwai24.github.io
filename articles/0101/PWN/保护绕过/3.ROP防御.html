<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># ROP防御,ROP防御</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>ROP防御</h1>
<h2>1.背景</h2>
<p>知道正常程序的指令流执行和 ROP 的指令流执行有很大不同，至少有下面两点：</p>
<ul>
<li>ROP 执行流会包含了很多 return 指令，而且之间只间隔了几条其他指令</li>
<li>ROP 利用 return 指令来 unwind 堆栈，却没有对应的 call 指令</li>
</ul>
<p>以上面两点差异作为基础，研究人员提出了很多 ROP 检测和防御技术：</p>
<ul>
<li>针对第一点差异，可以检测程序执行中是否有频繁 return 的指令流，作为报警的依据</li>
<li>针对第二点差异，可以通过 call 和 return 指令来查找正常程序中通常都存在的后进先出栈里维护的不变量，判断其是否异常</li>
<li>还有更极端的，在编译器层面重写二进制文件，消除里面的 return 指令</li>
</ul>
<p>所以其实这些早期的防御技术都默认了一个前提，即 ROP 中必定存在 return 指令。</p>
<p>另外对于重写二进制文件消除 return 指令的技术，根据二进制偏移也可能会得到攻击者需要的非预期指令，比如下面这段指令：</p>
<pre><code class="language-asm">b8 13 00 00 00  mov $0x13, %eax
e9 c3 f8 ff ff  jmp 3aae9
</code></pre>
<p>偏移两个十六进制得到下面这样：</p>
<pre><code class="language-asm">00 00   add %al, (%eax)
00 e9   add %ch, %cl
c3      ret
</code></pre>
<p>最终还是出现了 return 指令。</p>
<h2>2.没有 return 的 ROP</h2>
<p>return 指令的作用主要有两个：第一通过间接跳转改变执行流，第二是更新寄存器状态。在 x86 和 ARM 中都存在一些指令序列，也能够完成这些工作，它们首先更新全局状态（如栈指针），然后根据更新后的状态加载下一条指令序列的地址，最后跳转过去执行（把它叫做 update-load-branch 指令序列）。这样就避免的 return 指令的使用</p>
<p>就像下面这样，<code>x</code> 代表任意的通用寄存器：</p>
<pre><code>pop x
jmp *x
</code></pre>

        </main>
    </div>
</body>
</html>