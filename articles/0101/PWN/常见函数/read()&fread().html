<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title># read() & fread(),read() & fread()</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <h1>read() &amp; fread()</h1>
<blockquote>
<p>ssize_t：有符号整型，与long类似。typedef long size_t</p>
<p>size_t：无符号的ssize_t,：typedef unsigned long size_t</p>
</blockquote>
<h2>1.read()</h2>
<pre><code class="language-c">ssize_t read(int fd, void *buf, size_t count)
</code></pre>
<ul>
<li>读取打开文件的count字节保存到buf缓冲区，返回实际读取的字节数</li>
<li>头文件：#include &lt;unistd.h&gt;</li>
<li>fd=0，代表标准输入流；File Descriptor (FD)：stdin = 0、stdout = 1、stderr = 2</li>
<li>文件描述符（file descriptor）。文件描述符只是一个整数，是每个进程私有的，在 UNIX 系统中用于访问文件。因此，一旦文件被打开，就可以使用文件描述符来读取或写入文件</li>
<li>在orw中，read第一个打开文件的文件描述符必定是3，后面打开的文件以此类推4，5…</li>
<li>每个正在运行的进程已经打开了 3 个文件：标准输入（进程可以读取以接收输入），标准输出（进程可以写入以便将信息显示到屏幕），以及标准错误（进程可以写入错误消息）。这些分别由文件描述符 0、1 和 2 表示。因此，当你第一次打开另一个文件时（如上例所示），它几乎肯定是文件描述符 3</li>
</ul>
<h2>2.fread()</h2>
<pre><code class="language-c">size_t fread(void *ptr, size_t size, size_t count, FILE *stream);
</code></pre>
<ul>
<li>fread() 函数可以从文件中读取二进制数据。它在读取数据时，会从文件流中读取 count 个数据项，每个数据项占用 size 个字节。它会将这些数据项存储到由 ptr 指向的缓冲区中，并返回成功读取的数据项数目</li>
<li>头文件 ：#include&lt;stdio.h&gt;</li>
<li>ptr：指向要读取数据的缓冲区</li>
<li>size：每个数据项的字节数</li>
<li>count：要读取的数据项数目</li>
<li>stream：指向文件流的指针</li>
</ul>

        </main>
    </div>
</body>
</html>