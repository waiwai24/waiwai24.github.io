<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lambda规范&模板</title>
    <link rel="stylesheet" href="/assets/css/notes.min.css">
</head>
<body>
    <div class="main-content-wrapper">
        <main class="content">
            <p>lambda:</p>
<pre><code class="language-python">#-----------------------------------------------------------------------------------------
it      = lambda                    : p.interactive()
sd      = lambda data               : p.send((data))
sa     	= lambda delim,data         : p.sendafter((delim), (data))
sl      = lambda data               : p.sendline((data))
sla     = lambda delim,data         : p.sendlineafter((delim), (data))
r       = lambda numb=4096          : p.recv(numb)
ru      = lambda delims, drop=False : p.recvuntil(delims, drop)
rl      = lambda                    : p.recvline()
l       = lambda str1               : log.success(str1)
li      = lambda str1,data1         : log.success(str1+' ========&gt; '+hex(data1))
uu32    = lambda data               : u32(data.ljust(4, b&quot;\x00&quot;))
uu64    = lambda data               : u64(data.ljust(8, b&quot;\x00&quot;))
n64     = lambda x                  : (x + 0x10000000000000000) &amp; 0xFFFFFFFFFFFFFFFF
dbg     = lambda                    : gdb.attach(p) / pause()
u32Leakbase = lambda offset         : u32(ru(b&quot;\xf7&quot;)[-4:]) - offset
u64Leakbase = lambda offset         : u64(ru(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;)) - offset
#-----------------------------------------------------------------------------------------
</code></pre>
<p>other:</p>
<pre><code>gdb.attach(proc.pidof(p)[0])
pause()
</code></pre>
<p>exp：</p>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
# patchelf --set-interpreter new_ld_address file_path
# patchelf --replace-needed old_libc.so.6 new_libc.so.6 file_path
# pycharm # ctrl+/

elf_path = './pwn'
libc_path = './libc.so.6'
elf = ELF(elf_path, checksec=False)
libc = ELF(libc_path)
context(arch=elf.arch, os=elf.os, log_level=&quot;debug&quot;)
# context.terminal = ['tmux','splitw','-h']
ip = '8.147.135.93'
port = 37051

local = 1
if local:
    p = process([elf_path])
else:
    p = remote(ip, port)

# session = ssh(host='node5.buuoj.cn', port=26482, user='CTFMan', password='guest')
# p = session.process(['./vuln'])
#-----------------------------------------------------------------------------------------
it      = lambda                    : p.interactive()
sd      = lambda data               : p.send((data))
sa     	= lambda delim,data         : p.sendafter((delim), (data))
sl      = lambda data               : p.sendline((data))
sla     = lambda delim,data         : p.sendlineafter((delim), (data))
r       = lambda numb=4096          : p.recv(numb)
ru      = lambda delims, drop=False : p.recvuntil(delims, drop)
rl      = lambda                    : p.recvline()
l       = lambda str1               : log.success(str1)
li      = lambda str1,data1         : log.success(str1+' ========&gt; '+hex(data1))
uu32    = lambda data               : u32(data.ljust(4, b&quot;\x00&quot;))
uu64    = lambda data               : u64(data.ljust(8, b&quot;\x00&quot;))
n64     = lambda x                  : (x + 0x10000000000000000) &amp; 0xFFFFFFFFFFFFFFFF
dbg     = lambda                    : gdb.attach(p) / pause()
u32Leakbase = lambda offset         : u32(ru(b&quot;\xf7&quot;)[-4:]) - offset
u64Leakbase = lambda offset         : u64(ru(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;)) - offset
#-----------------------------------------------------------------------------------------

def add_chunk(index, size):
    sla(b&quot;choice:\n&quot;, b&quot;1&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;size:\n&quot;, str(size).encode())

def delete_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;2&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())

def edit_chunk(index, content):
    sla(b&quot;choice:\n&quot;, b&quot;3&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())
    sla(b&quot;length:\n&quot;, str(len(content)).encode())
    sa(b&quot;content:\n&quot;, content)

def show_chunk(index):
    sla(b&quot;choice:\n&quot;, b&quot;4&quot;)
    sla(b&quot;index:\n&quot;, str(index).encode())

def exit_p():
    sla(b&quot;choice:\n&quot;, b&quot;5&quot;)

# use LibcSearcher get libc base addr
libc = LibcSearcher(&quot;puts&quot;, puts_addr)
libc.add_condition(&quot;printf&quot;, printf_addr)
libc_base = puts_addr - libc.dump(&quot;puts&quot;)
bin_sh = libc_base + libc.dump(&quot;str_bin_sh&quot;)
system_addr = libc_base + libc.dump(&quot;system&quot;)

gdb.attach(p)
pause()
p.interactive()
</code></pre>

        </main>
    </div>
</body>
</html>